{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Receiver} from \"./IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "solady/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// @dev Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /// @dev The input string must be a 7-bit ASCII.\n    error StringNot7BitASCII();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyz'.\n    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;\n\n    /// @dev Lookup for 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;\n\n    /// @dev Lookup for '0123456789'.\n    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefABCDEF'.\n    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;\n\n    /// @dev Lookup for '01234567'.\n    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;\n\n    /// @dev Lookup for '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'.\n    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;\n\n    /// @dev Lookup for ' \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end of the memory to calculate the length later.\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 1)`.\n                // Store the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(result, add(48, mod(temp, 10)))\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20) // Move the pointer 32 bytes back to make room for the length.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory result) {\n        if (value >= 0) return toString(uint256(value));\n        unchecked {\n            result = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let n := mload(result) // Load the string length.\n            mstore(result, 0x2d) // Store the '-' character.\n            result := sub(result, 1) // Move back the string pointer by a byte.\n            mstore(result, add(n, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is not prefixed with \"0x\" and is encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            result := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(result, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(result, start)) { break }\n            }\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(add(result, o), 0x3078) // Store the \"0x\" prefix, accounting for leading zero.\n            result := sub(add(result, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := mload(result) // Get the length.\n            result := add(result, o) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory result) {\n        result = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(result, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Allocate memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(result, 0x80))\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            result := add(result, 2)\n            mstore(result, 40) // Store the length.\n            let o := add(result, 0x20)\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\n            value := shl(96, value)\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(raw)\n            result := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(result, add(n, n)) // Store the length of the output.\n\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n            let o := add(result, 0x20)\n            let end := add(raw, n)\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let mask := shl(7, div(not(0), 255))\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string,\n    /// AND all characters are in the `allowed` lookup.\n    /// Note: If `s` is empty, returns true regardless of `allowed`.\n    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if mload(s) {\n                let allowed_ := shr(128, shl(128, allowed))\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\n                    o := add(o, 1)\n                    if iszero(and(result, lt(o, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Converts the bytes in the 7-bit ASCII string `s` to\n    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.\n    /// To save runtime gas, you can cache the result in an immutable variable.\n    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := or(result, shl(byte(0, mload(o)), 1))\n                    o := add(o, 1)\n                    if iszero(lt(o, end)) { break }\n                }\n                if shr(128, result) {\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(string memory subject, string memory needle, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let needleLen := mload(needle)\n            let replacementLen := mload(replacement)\n            let d := sub(result, subject) // Memory difference.\n            let i := add(subject, 0x20) // Subject bytes pointer.\n            let end := add(i, mload(subject))\n            if iszero(gt(needleLen, mload(subject))) {\n                let subjectSearchEnd := add(sub(end, needleLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(needleLen, 0x20)) { h := keccak256(add(needle, 0x20), needleLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, needleLen), h)) {\n                                mstore(add(i, d), t)\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let j := 0 } 1 {} {\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\n                            j := add(j, 0x20)\n                            if iszero(lt(j, replacementLen)) { break }\n                        }\n                        d := sub(add(d, replacementLen), needleLen)\n                        if needleLen {\n                            i := add(i, needleLen)\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(add(i, d), t)\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n            }\n            let n := add(sub(d, add(result, 0x20)), end)\n            // Copy the rest of the string one word at a time.\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\n            let o := add(i, d)\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            for { let subjectLen := mload(subject) } 1 {} {\n                if iszero(mload(needle)) {\n                    result := from\n                    if iszero(gt(from, subjectLen)) { break }\n                    result := subjectLen\n                    break\n                }\n                let needleLen := mload(needle)\n                let subjectStart := add(subject, 0x20)\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\n                let s := mload(add(needle, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\n\n                if iszero(lt(needleLen, 0x20)) {\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, needleLen), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, needle, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let needleLen := mload(needle)\n                if gt(needleLen, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), needleLen)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                    if eq(keccak256(subject, needleLen), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, needle, type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory needle) internal pure returns (bool) {\n        return indexOf(subject, needle) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(string memory subject, string memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let needleLen := mload(needle)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(needleLen, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), needleLen),\n                    keccak256(add(needle, 0x20), needleLen)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(string memory subject, string memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let needleLen := mload(needle)\n            // Whether `needle` is not longer than `subject`.\n            let inRange := iszero(gt(needleLen, mload(subject)))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLen - needleLen, 0)`.\n                        add(add(subject, 0x20), mul(inRange, sub(mload(subject), needleLen))),\n                        needleLen\n                    ),\n                    keccak256(add(needle, 0x20), needleLen)\n                ),\n                inRange\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLen := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLen))) {\n                result := mload(0x40)\n                subject := add(subject, 0x20)\n                let o := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let j := 0 } 1 {} {\n                        mstore(add(o, j), mload(add(subject, j)))\n                        j := add(j, 0x20)\n                        if iszero(lt(j, subjectLen)) { break }\n                    }\n                    o := add(o, subjectLen)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLen := mload(subject)\n            if iszero(gt(subjectLen, end)) { end := subjectLen }\n            if iszero(gt(subjectLen, start)) { start := subjectLen }\n            if lt(start, end) {\n                result := mload(0x40)\n                let n := sub(end, start)\n                let i := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\n                    mstore(add(result, j), mload(add(i, j)))\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    if iszero(j) { break }\n                }\n                let o := add(add(result, 0x20), n)\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, n) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, type(uint256).max);\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLen := mload(needle)\n            if iszero(gt(searchLen, mload(subject))) {\n                result := mload(0x40)\n                let i := add(subject, 0x20)\n                let o := add(result, 0x20)\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(searchLen, 0x20)) { h := keccak256(add(needle, 0x20), searchLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, searchLen), h)) {\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\n                        o := add(o, 0x20)\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\n                        if searchLen {\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(o, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            for { let prevIndex := 0 } 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let l := sub(index, prevIndex)\n                    mstore(element, l) // Store the length of the element.\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the string.\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\n                    mstore(indexPtr, element) // Store the `element` into the array.\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let w := not(0x1f)\n            let aLen := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLen := mload(b)\n            let output := add(result, aLen)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLen := add(aLen, bLen)\n            let last := add(add(result, 0x20), totalLen)\n            mstore(last, 0) // Zeroize the slot after the string.\n            mstore(result, totalLen) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(subject)\n            if n {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let d := sub(subject, result)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                for { let end := add(o, n) } 1 {} {\n                    let b := byte(0, mload(add(d, o)))\n                    mstore8(o, xor(and(shr(b, flags), 0x20), b))\n                    o := add(o, 1)\n                    if eq(o, end) { break }\n                }\n                mstore(result, n) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            mstore(o, s) // Store the bytes of the string.\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(result, 0x40)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(s, mload(s))\n            let o := add(result, 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(o, c)\n                    o := add(o, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(o, mload(and(t, 0x1f)))\n                o := add(o, shr(5, t))\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(o, c)\n                        o := add(o, 1)\n                        continue\n                    }\n                    mstore8(o, 0x5c) // \"\\\\\".\n                    mstore8(add(o, 1), c)\n                    o := add(o, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(o, mload(0x19)) // \"\\\\u00XX\".\n                    o := add(o, 6)\n                    continue\n                }\n                mstore8(o, 0x5c) // \"\\\\\".\n                mstore8(add(o, 1), mload(add(c, 8)))\n                o := add(o, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Encodes `s` so that it can be safely used in a URI,\n    /// just like `encodeURIComponent` in JavaScript.\n    /// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n    /// See: https://datatracker.ietf.org/doc/html/rfc2396\n    /// See: https://datatracker.ietf.org/doc/html/rfc3986\n    function encodeURIComponent(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Store \"0123456789ABCDEF\" in scratch space.\n            // Uppercased to be consistent with JavaScript's implementation.\n            mstore(0x0f, 0x30313233343536373839414243444546)\n            let o := add(result, 0x20)\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // If not in `[0-9A-Z-a-z-_.!~*'()]`.\n                if iszero(and(1, shr(c, 0x47fffffe87fffffe03ff678200000000))) {\n                    mstore8(o, 0x25) // '%'.\n                    mstore8(add(o, 1), mload(and(shr(4, c), 15)))\n                    mstore8(add(o, 2), mload(and(c, 15)))\n                    o := add(o, 3)\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(result, 0) // Zeroize the length slot.\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    or( // Load the length and the bytes of `a` and `b`.\n                    shl(shl(3, sub(0x1f, aLen)), mload(add(a, aLen))), mload(sub(add(b, 0x1e), aLen))),\n                    // `totalLen != 0 && totalLen < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLen, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            resultA := mload(0x40) // Grab the free memory pointer.\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the string.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n}\n"
    },
    "solady/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\n/// @author Modified from SSTORE3 (https://github.com/Philogy/sstore3)\nlibrary SSTORE2 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The proxy initialization code.\n    uint256 private constant _CREATE3_PROXY_INITCODE = 0x67363d3d37363d34f03d5260086018f3;\n\n    /// @dev Hash of the `_CREATE3_PROXY_INITCODE`.\n    /// Equivalent to `keccak256(abi.encodePacked(hex\"67363d3d37363d34f03d5260086018f3\"))`.\n    bytes32 internal constant CREATE3_PROXY_INITCODE_HASH =\n        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data) // Let `l` be `n + 1`. +1 as we prefix a STOP opcode.\n            /**\n             * ---------------------------------------------------+\n             * Opcode | Mnemonic       | Stack     | Memory       |\n             * ---------------------------------------------------|\n             * 61 l   | PUSH2 l        | l         |              |\n             * 80     | DUP1           | l l       |              |\n             * 60 0xa | PUSH1 0xa      | 0xa l l   |              |\n             * 3D     | RETURNDATASIZE | 0 0xa l l |              |\n             * 39     | CODECOPY       | l         | [0..l): code |\n             * 3D     | RETURNDATASIZE | 0 l       | [0..l): code |\n             * F3     | RETURN         |           | [0..l): code |\n             * 00     | STOP           |           |              |\n             * ---------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(n, 0xb))\n            if iszero(pointer) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\n    /// and returns its normal CREATE2 deterministic address.\n    function writeCounterfactual(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(n, 0xb), salt)\n            if iszero(pointer) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    /// This uses the so-called \"CREATE3\" workflow,\n    /// which means that `pointer` is agnostic to `data, and only depends on `salt`.\n    function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            mstore(0x00, _CREATE3_PROXY_INITCODE) // Store the `_PROXY_INITCODE`.\n            let proxy := create2(0, 0x10, 0x10, salt)\n            if iszero(proxy) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, proxy) // Store the proxy's address.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            pointer := keccak256(0x1e, 0x17)\n\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            if iszero(\n                mul( // The arguments of `mul` are evaluated last to first.\n                    extcodesize(pointer),\n                    call(gas(), proxy, 0, add(data, 0x15), add(n, 0xb), codesize(), 0x00)\n                )\n            ) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    ADDRESS CALCULATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xfffe))\n            mstore(data, add(0x61000180600a3d393df300, shl(0x40, n)))\n            hash := keccak256(add(data, 0x15), add(n, 0xb))\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /// @dev Equivalent to `predictCounterfactualAddress(data, salt, address(this))`\n    function predictCounterfactualAddress(bytes memory data, bytes32 salt)\n        internal\n        view\n        returns (address pointer)\n    {\n        pointer = predictCounterfactualAddress(data, salt, address(this));\n    }\n\n    /// @dev Returns the CREATE2 address of the storage contract for `data`\n    /// deployed with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictCounterfactualAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /// @dev Equivalent to `predictDeterministicAddress(salt, address(this))`.\n    function predictDeterministicAddress(bytes32 salt) internal view returns (address pointer) {\n        pointer = predictDeterministicAddress(salt, address(this));\n    }\n\n    /// @dev Returns the \"CREATE3\" deterministic address for `salt` with `deployer`.\n    function predictDeterministicAddress(bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, deployer) // Store `deployer`.\n            mstore8(0x0b, 0xff) // Store the prefix.\n            mstore(0x20, salt) // Store the salt.\n            mstore(0x40, CREATE3_PROXY_INITCODE_HASH) // Store the bytecode hash.\n\n            mstore(0x14, keccak256(0x0b, 0x55)) // Store the proxy's address.\n            mstore(0x40, m) // Restore the free memory pointer.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            pointer := keccak256(0x1e, 0x17)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         READ LOGIC                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `read(pointer, 0, 2 ** 256 - 1)`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(pointer), 0x01))\n            extcodecopy(pointer, add(data, 0x1f), 0x00, add(n, 0x21))\n            mstore(data, n) // Store the length.\n            mstore(0x40, add(n, add(data, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `read(pointer, start, 2 ** 256 - 1)`.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(pointer), 0x01))\n            extcodecopy(pointer, add(data, 0x1f), start, add(n, 0x21))\n            mstore(data, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(data, add(0x40, mload(data)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the data on `pointer` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `pointer` MUST be deployed via the SSTORE2 write functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `pointer` does not have any code.\n    function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(pointer, add(data, 0x1f), start, add(d, 0x01))\n            if iszero(and(0xff, mload(add(data, d)))) {\n                let n := sub(extcodesize(pointer), 0x01)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(data, d) // Store the length.\n            mstore(add(add(data, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(data, 0x40), d)) // Allocate memory.\n        }\n    }\n}\n"
    },
    "src/core/UniCardCollateral.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\nimport {IUniCardCollateral} from \"../interfaces/IUniCardCollateral.sol\";\nimport {IPriceFeed} from \"../interfaces/IPriceFeed.sol\";\n\ninterface IUSDU {\n    function mint(address to, uint256 amount) external;\n}\n\ncontract UniCardCollateral is\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    IUniCardCollateral\n{\n    using SafeERC20 for IERC20;\n\n    // @notice Allowed repay token\n    bytes32 public constant ALLOWED_REPAY_TOKEN = keccak256(\"ALLOWED_REPAY_TOKEN\");\n    // @notice Minimum collateral ratio (110%)\n    uint256 public constant MIN_COLLATERAL_RATIO = 11e17; // 110%\n    // @notice Native token\n    address public constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH\n\n    IUSDU public usdu;\n    // @notice Price feed\n    IPriceFeed public priceFeed;\n    // @notice Debts\n    mapping(address => uint256) public debts;\n    // @notice Collaterals\n    mapping(address => uint256) public collaterals;\n\n    // @notice Constructor for the UniCardRegistry\n    // @param anAdmin The address of the admin\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    // @notice Initialize the contract\n    // @param registry_ The UniCard registry address\n    // @param priceFeed_ The price feed address\n    function initialize(address anAdmin, address anUsdu, address aPriceFeed) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        usdu = IUSDU(anUsdu);\n        priceFeed = IPriceFeed(aPriceFeed);\n        _grantRole(DEFAULT_ADMIN_ROLE, anAdmin);\n    }\n\n    /**\n     * @notice Borrow USDU by providing ETH as collateral\n     * @param debtAmount The amount of USDU to borrow\n     */\n    function borrow(uint256 debtAmount) external payable whenNotPaused {\n        adjust(\n            IUniCardCollateral.AdjustParams({\n                collateralChange: msg.value,\n                isCollateralIncrease: true,\n                debtChange: debtAmount,\n                isDebtIncrease: true,\n                repayToken: NATIVE_TOKEN\n            })\n        );\n    }\n\n    /**\n     * @notice Repay USDU debt using allowed tokens\n     * @param repayToken The token used for repayment\n     * @param repayAmount The amount to repay\n     */\n    function repay(address repayToken, uint256 repayAmount) external whenNotPaused {\n        adjust(\n            IUniCardCollateral.AdjustParams({\n                collateralChange: 0,\n                isCollateralIncrease: false,\n                debtChange: repayAmount,\n                isDebtIncrease: false,\n                repayToken: repayToken\n            })\n        );\n    }\n\n    /**\n     * @notice Core function to adjust position (collateral and debt)\n     * @param params Struct containing all adjustment parameters\n     */\n    function adjust(IUniCardCollateral.AdjustParams memory params) public payable nonReentrant whenNotPaused {\n        LocalVariables_adjust memory vars;\n\n        // Get current position\n        uint256 currentCollateral = collaterals[_msgSender()];\n        uint256 currentDebt = debts[_msgSender()];\n\n        // Validate basic requirements\n        if (params.isCollateralIncrease) {\n            if (msg.value != params.collateralChange) {\n                revert Errors.UNICARD_COLLATERAL_INVALID_ETH_AMOUNT();\n            }\n        } else {\n            if (msg.value != 0) {\n                revert Errors.UNICARD_COLLATERAL_ETH_NOT_NEEDED();\n            }\n        }\n\n        // Calculate new collateral amount\n        vars.totalCollateralAfter =\n            _calculateNewCollateral(currentCollateral, params.collateralChange, params.isCollateralIncrease);\n\n        // Calculate new debt amount\n        vars.totalDebtAfter =\n            _calculateNewDebt(currentDebt, params.debtChange, params.isDebtIncrease, params.repayToken);\n\n        // Check collateral ratio if there's debt\n        if (vars.totalDebtAfter > 0) {\n            vars.price = priceFeed.lastGoodPrice();\n            vars.collateralRatio = _calculateCollateralRatio(vars.totalCollateralAfter, vars.totalDebtAfter, vars.price);\n            if (vars.collateralRatio < MIN_COLLATERAL_RATIO) {\n                revert Errors.UNICARD_COLLATERAL_INSUFFICIENT_COLLATERAL_RATIO();\n            }\n        }\n\n        // Update state\n        collaterals[_msgSender()] = vars.totalCollateralAfter;\n        debts[_msgSender()] = vars.totalDebtAfter;\n\n        // Handle token transfers\n        _handleTokenTransfers(params);\n\n        emit CollateralAdjusted(\n            _msgSender(),\n            params.collateralChange,\n            params.isCollateralIncrease,\n            params.debtChange,\n            params.isDebtIncrease,\n            params.repayToken\n        );\n    }\n\n    /**\n     * @notice Calculate new collateral amount\n     * @param currentCollateral Current collateral amount\n     * @param change Amount of collateral to add/remove\n     * @param isIncrease True if adding collateral, false if removing\n     * @return New collateral amount\n     */\n    function _calculateNewCollateral(uint256 currentCollateral, uint256 change, bool isIncrease)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (isIncrease) {\n            return currentCollateral + change;\n        } else {\n            if (change > currentCollateral) {\n                revert Errors.UNICARD_COLLATERAL_INSUFFICIENT_COLLATERAL();\n            }\n            return currentCollateral - change;\n        }\n    }\n\n    /**\n     * @notice Calculate new debt amount\n     * @param currentDebt Current debt amount\n     * @param change Amount of debt to add/remove\n     * @param isIncrease True if borrowing, false if repaying\n     * @param repayToken Token used for repayment (only used when repaying)\n     * @return New debt amount\n     */\n    function _calculateNewDebt(uint256 currentDebt, uint256 change, bool isIncrease, address repayToken)\n        internal\n        view\n        returns (uint256)\n    {\n        if (isIncrease) {\n            if (repayToken != NATIVE_TOKEN) {\n                revert Errors.UNICARD_COLLATERAL_INVALID_REPAY_TOKEN();\n            }\n            return currentDebt + change;\n        } else {\n            if (change > currentDebt) {\n                revert Errors.UNICARD_COLLATERAL_DEBT_REDUCTION_EXCEEDS_CURRENT_DEBT();\n            }\n            if (change > 0) {\n                if (!hasRole(ALLOWED_REPAY_TOKEN, repayToken)) {\n                    revert Errors.UNICARD_COLLATERAL_INVALID_REPAY_TOKEN();\n                }\n            }\n            return currentDebt - change;\n        }\n    }\n\n    /**\n     * @notice Handle token transfers\n     * @param params Struct containing all adjustment parameters\n     */\n    function _handleTokenTransfers(IUniCardCollateral.AdjustParams memory params) internal {\n        // Handle repayment token transfer\n        if (!params.isDebtIncrease && params.debtChange > 0) {\n            IERC20(params.repayToken).safeTransferFrom(_msgSender(), address(this), params.debtChange);\n        }\n\n        // Handle USDU minting for borrowing\n        if (params.isDebtIncrease && params.debtChange > 0) {\n            usdu.mint(_msgSender(), params.debtChange);\n        }\n    }\n\n    /**\n     * @notice Calculate collateral ratio\n     * @param collateralAmount Collateral amount\n     * @param debtAmount Debt amount\n     * @param price Price\n     * @return Collateral ratio\n     */\n    function _calculateCollateralRatio(uint256 collateralAmount, uint256 debtAmount, uint256 price)\n        internal\n        pure\n        returns (uint256)\n    {\n        // collateralAmount (18 decimals) * price (8 decimals) / (debtAmount (18 decimals) * 1e8) * 1 ether= ratio (18 decimals)\n        if (debtAmount > 0) {\n            uint256 newCollRatio = 1 ether * collateralAmount / debtAmount * price / 1e8;\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the debt is 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return 2 ** 256 - 1;\n        }\n    }\n\n    // @notice Toggle the pause status of the collateral\n    // @param enablePauseOrNot The flag to enable or disable the pause\n    function togglePause(bool enablePauseOrNot) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (enablePauseOrNot) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // @notice Receive ETH\n    receive() external payable {}\n}\n"
    },
    "src/core/UniCardRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\nimport {IUniCardRegistry} from \"../interfaces/IUniCardRegistry.sol\";\nimport {Enums} from \"../libraries/Enums.sol\";\n\n// @title UniCardRegistry\n// @author UniPay\n// @notice This contract is used to register and manage UniCards\ncontract UniCardRegistry is\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    IUniCardRegistry\n{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant CONTROLLER_ROLE = keccak256(\"CONTROLLER_ROLE\");\n    bytes32 public constant ALLOWED_TOKEN_PAYMENT = keccak256(\"ALLOWED_TOKEN_PAYMENT\");\n\n    address public constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    mapping(address => uint256) public nonces;\n    mapping(bytes32 => Card) public cards;\n\n    // @notice Constructor for the UniCardRegistry\n    // @param anAdmin The address of the admin\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address anAdmin) public initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, anAdmin);\n        _setRoleAdmin(CONTROLLER_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(ALLOWED_TOKEN_PAYMENT, DEFAULT_ADMIN_ROLE);\n    }\n\n    // @notice Open a card with a commitment request\n    // @param holder The address of the card holder\n    // @param paymentToken The payment token of the card\n    // @param productCode The product code of card\n    // @param inviteCode The invite code of card\n    // @param referralCode The referral code of card\n    function openCardRequest(\n        address holder,\n        address paymentToken,\n        uint256 amount,\n        string memory productCode,\n        string memory inviteCode,\n        string memory referralCode\n    ) external payable nonReentrant whenNotPaused {\n        if (!hasRole(ALLOWED_TOKEN_PAYMENT, paymentToken)) {\n            revert Errors.UNICARD_REGISTRY_PAYMENT_TOKEN_NOT_ALLOWED();\n        }\n        if (amount > 0) {\n            if (paymentToken != NATIVE_TOKEN) {\n                IERC20(paymentToken).safeTransferFrom(holder, address(this), amount);\n            } else {\n                payable(address(this)).transfer(amount);\n                // refund the extra amount\n                if (msg.value > amount) {\n                    payable(holder).transfer(msg.value - amount);\n                }\n            }\n        }\n\n        uint256 nonce = nonces[holder];\n        bytes32 key = keccak256(abi.encodePacked(holder, nonce));\n        if (cards[key].status == Enums.CardStatus.UNOPENED) {\n            cards[key] = Card({\n                holder: holder,\n                paymentToken: paymentToken,\n                nonce: nonce,\n                openCardAmount: amount,\n                productCode: productCode,\n                inviteCode: inviteCode,\n                referralCode: referralCode,\n                status: Enums.CardStatus.ACTIVATED\n            });\n        } else {\n            revert Errors.UNICARD_REGISTRY_CARD_ALREADY_OPENED();\n        }\n\n        emit CardOpenRequest(holder, paymentToken, nonce, amount, productCode, inviteCode, referralCode);\n    }\n\n    // @notice Close a card\n    // @param holder The address of the card holder\n    // @param nonce The nonce of the card\n    function closeCardRequest(address holder, uint256 nonce) external onlyRole(CONTROLLER_ROLE) {\n        bytes32 key = keccak256(abi.encodePacked(holder, nonce));\n        if (cards[key].status == Enums.CardStatus.DEACTIVATED) {\n            revert Errors.UNICARD_REGISTRY_CARD_ALREADY_DEACTIVATED();\n        } else if (cards[key].status == Enums.CardStatus.UNOPENED) {\n            revert Errors.UNICARD_REGISTRY_CARD_NOT_OPENED();\n        }\n        cards[key].status = Enums.CardStatus.DEACTIVATED;\n\n        // refund the amount\n        if (cards[key].paymentToken != NATIVE_TOKEN) {\n            IERC20(cards[key].paymentToken).safeTransfer(holder, cards[key].openCardAmount);\n        } else {\n            payable(holder).transfer(cards[key].openCardAmount);\n        }\n\n        emit CardCloseRequest(holder, nonce);\n    }\n\n    // @notice Withdraw the funds from the registry\n    // @param paymentToken The payment token to withdraw\n    // @param amount The amount to withdraw\n    function withdrawRegistryFunds(address paymentToken, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        nonReentrant\n        whenNotPaused\n    {\n        if (paymentToken != NATIVE_TOKEN) {\n            IERC20(paymentToken).safeTransfer(msg.sender, amount);\n        } else {\n            payable(msg.sender).transfer(amount);\n        }\n    }\n\n    // @notice Toggle the pause status of the registry\n    // @param enablePauseOrNot The flag to enable or disable the pause\n    function togglePause(bool enablePauseOrNot) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (enablePauseOrNot) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // @notice Receive native token\n    receive() external payable {}\n}\n"
    },
    "src/core/UniCardVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\nimport {IUniCardVault} from \"../interfaces/IUniCardVault.sol\";\n\n// @title UniCardVault\n// @author UniPay\n// @notice This contract is used to deposit funds into a UniCard\ncontract UniCardVault is AccessControlUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable, IUniCardVault {\n    using SafeERC20 for IERC20;\n\n    address public usdu;\n\n    mapping(string => Account) public cardAccounts;\n\n    // @notice Constructor for the UniCardRegistry\n    // @param anAdmin The address of the admin\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    // @notice Initialize the UniCardVault\n    // @param anAdmin The address of the admin\n    // @param aPaymentToken The address of the payment token. eg USDU\n    // @param aRegistry The address of the UniCardRegistry\n    function initialize(address anAdmin, address anUsdu) public initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, anAdmin);\n        usdu = anUsdu;\n    }\n\n    // @notice Deposit funds into a UniCard\n    // @param cardId The id of the card\n    // @param amount The amount of the deposit\n    function deposit(string memory cardId, uint256 amount) public override nonReentrant whenNotPaused {\n        IERC20(usdu).safeTransferFrom(_msgSender(), address(this), amount);\n        if (!cardAccounts[cardId].initialized) {\n            cardAccounts[cardId] = Account({holder: _msgSender(), balance: amount, initialized: true});\n        } else {\n            cardAccounts[cardId].balance += amount;\n        }\n        emit Deposit(cardId, cardAccounts[cardId].holder, amount);\n    }\n\n    // @notice Withdraw funds from a UniCard\n    // @param cardId The id of the card\n    // @param amount The amount of the withdrawal\n    function withdraw(string memory cardId, uint256 amount) public override nonReentrant whenNotPaused {\n        if (!cardAccounts[cardId].initialized) {\n            revert Errors.UNICARD_VAULT_CARD_NOT_INITIALIZED();\n        }\n        if (cardAccounts[cardId].balance < amount) {\n            revert Errors.UNICARD_VAULT_INSUFFICIENT_BALANCE();\n        }\n        if (cardAccounts[cardId].holder != _msgSender()) {\n            revert Errors.UNICARD_VAULT_INVALID_HOLDER();\n        }\n        IERC20(usdu).safeTransfer(_msgSender(), amount);\n        cardAccounts[cardId].balance -= amount;\n        emit Withdraw(cardId, cardAccounts[cardId].holder, amount);\n    }\n\n    // @notice Toggle the pause status of the vault\n    // @param enablePauseOrNot The flag to enable or disable the pause\n    function togglePause(bool enablePauseOrNot) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (enablePauseOrNot) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n}\n"
    },
    "src/core/USDU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {Errors} from \"../libraries/Errors.sol\";\n\ncontract USDU is ERC20Permit, Ownable {\n    string public constant NAME = \"USDU\";\n    string public constant SYMBOL = \"USDU\";\n    uint8 public constant DECIMALS = 18;\n\n    address public UNICARD_COLLATERAL;\n\n    constructor(address anOwner) Ownable(anOwner) ERC20Permit(NAME) ERC20(NAME, SYMBOL) {}\n\n    function initialize(address anUniCardCollateral) external onlyOwner {\n        UNICARD_COLLATERAL = anUniCardCollateral;\n        _transferOwnership(address(0)); // disable ownership\n    }\n\n    function mint(address to, uint256 amount) external {\n        if (_msgSender() != UNICARD_COLLATERAL) {\n            revert Errors.UNICARD_COLLATERAL_INVALID_MINT_CALLER();\n        }\n        _mint(to, amount);\n    }\n}\n"
    },
    "src/dependencies/AddRemoveManagers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IAddRemoveManagers.sol\";\nimport \"../interfaces/IAddressesRegistry.sol\";\nimport \"../interfaces/ITroveNFT.sol\";\n\ncontract AddRemoveManagers is IAddRemoveManagers {\n    ITroveNFT internal immutable troveNFT;\n\n    struct RemoveManagerReceiver {\n        address manager;\n        address receiver;\n    }\n\n    /*\n     * Mapping from TroveId to granted address for operations that \"give\" money to the trove (add collateral, pay debt).\n     * Useful for instance for cold/hot wallet setups.\n     * If its value is zero address, any address is allowed to do those operations on behalf of trove owner.\n     * Otherwise, only the address in this mapping (and the trove owner) will be allowed.\n     * To restrict this permission to no one, trove owner should be set in this mapping.\n     */\n    mapping(uint256 => address) public addManagerOf;\n\n    /*\n     * Mapping from TroveId to granted addresses for operations that \"withdraw\" money from the trove (withdraw collateral, borrow),\n     * and for each of those addresses another address for the receiver of those withdrawn funds.\n     * Useful for instance for cold/hot wallet setups or for automations.\n     * Only the address in this mapping, if any, and the trove owner, will be allowed.\n     * Therefore, by default this permission is restricted to no one.\n     * If the receiver is zero, the owner is assumed as the receiver.\n     */\n    mapping(uint256 => RemoveManagerReceiver) public removeManagerReceiverOf;\n\n    error EmptyManager();\n    error NotBorrower();\n    error NotOwnerNorAddManager();\n    error NotOwnerNorRemoveManager();\n\n    event TroveNFTAddressChanged(address _newTroveNFTAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) {\n        troveNFT = _addressesRegistry.troveNFT();\n        emit TroveNFTAddressChanged(address(troveNFT));\n    }\n\n    function setAddManager(uint256 _troveId, address _manager) external {\n        _requireCallerIsBorrower(_troveId);\n        _setAddManager(_troveId, _manager);\n    }\n\n    function _setAddManager(uint256 _troveId, address _manager) internal {\n        addManagerOf[_troveId] = _manager;\n    }\n\n    function setRemoveManager(uint256 _troveId, address _manager) external {\n        setRemoveManagerWithReceiver(_troveId, _manager, troveNFT.ownerOf(_troveId));\n    }\n\n    function setRemoveManagerWithReceiver(uint256 _troveId, address _manager, address _receiver) public {\n        _requireCallerIsBorrower(_troveId);\n        _setRemoveManagerAndReceiver(_troveId, _manager, _receiver);\n    }\n\n    function _setRemoveManagerAndReceiver(uint256 _troveId, address _manager, address _receiver) internal {\n        _requireNonZeroManagerUnlessWiping(_manager, _receiver);\n        removeManagerReceiverOf[_troveId].manager = _manager;\n        removeManagerReceiverOf[_troveId].receiver = _receiver;\n    }\n\n    function _requireNonZeroManagerUnlessWiping(address _manager, address _receiver) internal pure {\n        if (_manager == address(0) && _receiver != address(0)) {\n            revert EmptyManager();\n        }\n    }\n\n    function _requireCallerIsBorrower(uint256 _troveId) internal view {\n        if (msg.sender != troveNFT.ownerOf(_troveId)) {\n            revert NotBorrower();\n        }\n    }\n\n    function _requireSenderIsOwnerOrAddManager(uint256 _troveId, address _owner) internal view {\n        address addManager = addManagerOf[_troveId];\n        if (msg.sender != _owner && addManager != address(0) && msg.sender != addManager) {\n            revert NotOwnerNorAddManager();\n        }\n    }\n\n    function _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(uint256 _troveId, address _owner)\n        internal\n        view\n        returns (address)\n    {\n        address manager = removeManagerReceiverOf[_troveId].manager;\n        address receiver = removeManagerReceiverOf[_troveId].receiver;\n        if (msg.sender != _owner && msg.sender != manager) {\n            revert NotOwnerNorRemoveManager();\n        }\n        if (receiver == address(0)) {\n            return _owner;\n        }\n        return receiver;\n    }\n}\n"
    },
    "src/dependencies/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Code from https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\n\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "src/dependencies/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity  ^0.8.0;\n\naddress constant ZERO_ADDRESS = address(0);\n\nuint256 constant MAX_UINT256 = type(uint256).max;\n\nuint256 constant DECIMAL_PRECISION = 1e18;\nuint256 constant _100pct = DECIMAL_PRECISION;\nuint256 constant _1pct = DECIMAL_PRECISION / 100;\n\n// Amount of ETH to be locked in gas pool on opening troves\nuint256 constant ETH_GAS_COMPENSATION = 0.0375 ether;\n\n// Fraction of collateral awarded to liquidator\nuint256 constant COLL_GAS_COMPENSATION_DIVISOR = 200; // dividing by 200 yields 0.5%\nuint256 constant COLL_GAS_COMPENSATION_CAP = 2 ether; // Max coll gas compensation capped at 2 ETH\n\n// Minimum amount of net Bold debt a trove must have\nuint256 constant MIN_DEBT = 2000e18;\n\nuint256 constant MIN_ANNUAL_INTEREST_RATE = _1pct / 2; // 0.5%\nuint256 constant MAX_ANNUAL_INTEREST_RATE = _100pct;\n\n// Batch management params\nuint128 constant MAX_ANNUAL_BATCH_MANAGEMENT_FEE = uint128(_100pct);\nuint128 constant MIN_INTEREST_RATE_CHANGE_PERIOD = 1 seconds; // prevents more than one adjustment per block\n\nuint256 constant REDEMPTION_FEE_FLOOR = _1pct / 2; // 0.5%\n\n// Half-life of 12h. 12h = 720 min\n// (1/2) = d^720 => d = (1/2)^(1/720)\nuint256 constant REDEMPTION_MINUTE_DECAY_FACTOR = 999037758833783000;\n\n// BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\n// Corresponds to (1 / ALPHA) in the white paper.\nuint256 constant REDEMPTION_BETA = 2;\n\n// To prevent redemptions unless Bold depegs below 0.95 and allow the system to take off\nuint256 constant INITIAL_BASE_RATE = 5 * _1pct - REDEMPTION_FEE_FLOOR; // 5% initial redemption rate\n\n// Discount to be used once the shutdown thas been triggered\nuint256 constant URGENT_REDEMPTION_BONUS = 1e16; // 1%\n\nuint256 constant ONE_MINUTE = 1 minutes;\nuint256 constant ONE_YEAR = 365 days;\nuint256 constant UPFRONT_INTEREST_PERIOD = 7 days;\nuint256 constant INTEREST_RATE_ADJ_COOLDOWN = 3 days;\nuint256 constant STALE_TROVE_DURATION = 90 days;\n\nuint256 constant SP_YIELD_SPLIT = 72 * _1pct; // 72%\n\n// Dummy contract that lets legacy Hardhat tests query some of the constants\ncontract Constants {\n    uint256 public constant _ETH_GAS_COMPENSATION = ETH_GAS_COMPENSATION;\n    uint256 public constant _MIN_DEBT = MIN_DEBT;\n}\n"
    },
    "src/dependencies/IOsTokenVaultController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity  ^0.8.0;\n\ninterface IOsTokenVaultController {\n    function convertToAssets(uint256 shares) external view returns (uint256);\n}\n"
    },
    "src/dependencies/IRETHToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IRETHToken {\n    function getExchangeRate() external view returns (uint256);\n}\n"
    },
    "src/dependencies/IStaderOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity  ^0.8.0;\n\ninterface IStaderOracle {\n    function exchangeRate() external view returns (uint256, uint256, uint256);\n}\n"
    },
    "src/dependencies/LiquityBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity  ^0.8.0;\n\nimport \"./Constants.sol\";\nimport \"./LiquityMath.sol\";\nimport \"../interfaces/IAddressesRegistry.sol\";\nimport \"../interfaces/IActivePool.sol\";\nimport \"../interfaces/IDefaultPool.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/ILiquityBase.sol\";\n\n// import \"forge-std/console2.sol\";\n\n/*\n* Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n* common functions.\n*/\ncontract LiquityBase is ILiquityBase {\n    IActivePool public activePool;\n    IDefaultPool internal defaultPool;\n    IPriceFeed internal priceFeed;\n\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) {\n        activePool = _addressesRegistry.activePool();\n        defaultPool = _addressesRegistry.defaultPool();\n        priceFeed = _addressesRegistry.priceFeed();\n\n        emit ActivePoolAddressChanged(address(activePool));\n        emit DefaultPoolAddressChanged(address(defaultPool));\n        emit PriceFeedAddressChanged(address(priceFeed));\n    }\n    // --- Gas compensation functions ---\n\n    function getEntireSystemColl() public view returns (uint256 entireSystemColl) {\n        uint256 activeColl = activePool.getCollBalance();\n        uint256 liquidatedColl = defaultPool.getCollBalance();\n\n        return activeColl + liquidatedColl;\n    }\n\n    function getEntireSystemDebt() public view returns (uint256 entireSystemDebt) {\n        uint256 activeDebt = activePool.getBoldDebt();\n        uint256 closedDebt = defaultPool.getBoldDebt();\n\n        return activeDebt + closedDebt;\n    }\n\n    function _getTCR(uint256 _price) internal view returns (uint256 TCR) {\n        uint256 entireSystemColl = getEntireSystemColl();\n        uint256 entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, _price);\n\n        return TCR;\n    }\n\n    function _checkBelowCriticalThreshold(uint256 _price, uint256 _CCR) internal view returns (bool) {\n        uint256 TCR = _getTCR(_price);\n\n        return TCR < _CCR;\n    }\n\n    function _calcInterest(uint256 _weightedDebt, uint256 _period) internal pure returns (uint256) {\n        return _weightedDebt * _period / ONE_YEAR / DECIMAL_PRECISION;\n    }\n}\n"
    },
    "src/dependencies/LiquityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity  ^0.8.0;\n\nimport {DECIMAL_PRECISION} from \"./Constants.sol\";\n\nlibrary LiquityMath {\n    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a < _b) ? _a : _b;\n    }\n\n    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a >= _b) ? _a : _b;\n    }\n\n    function _sub_min_0(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a > _b) ? _a - _b : 0;\n    }\n\n    /* \n    * Multiply two decimal numbers and use normal rounding rules:\n    * -round product up if 19'th mantissa digit >= 5\n    * -round product down if 19'th mantissa digit < 5\n    *\n    * Used only inside the exponentiation, _decPow().\n    */\n    function decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {\n        uint256 prod_xy = x * y;\n\n        decProd = (prod_xy + DECIMAL_PRECISION / 2) / DECIMAL_PRECISION;\n    }\n\n    /* \n    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n    * \n    * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity. \n    * \n    * Called by two functions that represent time in units of minutes:\n    * 1) TroveManager._calcDecayedBaseRate\n    * 2) CommunityIssuance._getCumulativeIssuanceFraction \n    * \n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n    * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n    * \n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n    * negligibly different from just passing the cap, since: \n    *\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n    */\n    function _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {\n        if (_minutes > 525600000) _minutes = 525600000; // cap to avoid overflow\n\n        if (_minutes == 0) return DECIMAL_PRECISION;\n\n        uint256 y = DECIMAL_PRECISION;\n        uint256 x = _base;\n        uint256 n = _minutes;\n\n        // Exponentiation-by-squaring\n        while (n > 1) {\n            if (n % 2 == 0) {\n                x = decMul(x, x);\n                n = n / 2;\n            } else {\n                // if (n % 2 != 0)\n                y = decMul(x, y);\n                x = decMul(x, x);\n                n = (n - 1) / 2;\n            }\n        }\n\n        return decMul(x, y);\n    }\n\n    function _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a >= _b) ? _a - _b : _b - _a;\n    }\n\n    function _computeCR(uint256 _coll, uint256 _debt, uint256 _price) internal pure returns (uint256) {\n        if (_debt > 0) {\n            uint256 newCollRatio = _coll * _price / _debt;\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the debt is 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return 2 ** 256 - 1;\n        }\n    }\n}\n"
    },
    "src/dependencies/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity  ^0.8.0;\n\n/**\n * Based on OpenZeppelin's Ownable contract:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n *\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting `initialOwner` as the initial owner.\n     */\n    constructor(address initialOwner) {\n        _owner = initialOwner;\n        emit OwnershipTransferred(address(0), initialOwner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\n     * NOTE: This function is not safe, as it doesn’t check owner is calling it.\n     * Make sure you check it before calling it.\n     */\n    function _renounceOwnership() internal {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n}\n"
    },
    "src/interfaces/IActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IInterestRouter.sol\";\nimport \"./IBoldRewardsReceiver.sol\";\nimport \"../types/TroveChange.sol\";\n\ninterface IActivePool {\n    function defaultPoolAddress() external view returns (address);\n    function borrowerOperationsAddress() external view returns (address);\n    function troveManagerAddress() external view returns (address);\n    function interestRouter() external view returns (IInterestRouter);\n    // We avoid IStabilityPool here in order to prevent creating a dependency cycle that would break flattening\n    function stabilityPool() external view returns (IBoldRewardsReceiver);\n\n    function getCollBalance() external view returns (uint256);\n    function getBoldDebt() external view returns (uint256);\n    function lastAggUpdateTime() external view returns (uint256);\n    function aggRecordedDebt() external view returns (uint256);\n    function aggWeightedDebtSum() external view returns (uint256);\n    function aggBatchManagementFees() external view returns (uint256);\n    function aggWeightedBatchManagementFeeSum() external view returns (uint256);\n    function calcPendingAggInterest() external view returns (uint256);\n    function calcPendingSPYield() external view returns (uint256);\n    function calcPendingAggBatchManagementFee() external view returns (uint256);\n    function getNewApproxAvgInterestRateFromTroveChange(TroveChange calldata _troveChange)\n        external\n        view\n        returns (uint256);\n\n    function mintAggInterest() external;\n    function mintAggInterestAndAccountForTroveChange(TroveChange calldata _troveChange, address _batchManager)\n        external;\n    function mintBatchManagementFeeAndAccountForChange(TroveChange calldata _troveChange, address _batchAddress)\n        external;\n\n    function setShutdownFlag() external;\n    function hasBeenShutDown() external view returns (bool);\n    function shutdownTime() external view returns (uint256);\n\n    function sendColl(address _account, uint256 _amount) external;\n    function sendCollToDefaultPool(uint256 _amount) external;\n    function receiveColl(uint256 _amount) external;\n    function accountForReceivedColl(uint256 _amount) external;\n}\n"
    },
    "src/interfaces/IAddRemoveManagers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IAddRemoveManagers {\n    function setAddManager(uint256 _troveId, address _manager) external;\n    function setRemoveManager(uint256 _troveId, address _manager) external;\n    function setRemoveManagerWithReceiver(uint256 _troveId, address _manager, address _receiver) external;\n    function addManagerOf(uint256 _troveId) external view returns (address);\n    function removeManagerReceiverOf(uint256 _troveId) external view returns (address, address);\n}\n"
    },
    "src/interfaces/IAddressesRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IActivePool.sol\";\nimport \"./IBoldToken.sol\";\nimport \"./IBorrowerOperations.sol\";\nimport \"./ICollSurplusPool.sol\";\nimport \"./IDefaultPool.sol\";\nimport \"./IHintHelpers.sol\";\nimport \"./IMultiTroveGetter.sol\";\nimport \"./ISortedTroves.sol\";\nimport \"./IStabilityPool.sol\";\nimport \"./ITroveManager.sol\";\nimport \"./ITroveNFT.sol\";\nimport \"./ICollateralRegistry.sol\";\nimport \"./IInterestRouter.sol\";\nimport \"./IPriceFeed.sol\";\nimport {IMetadataNFT} from \"../nft_metadata/MetadataNFT.sol\";\n\ninterface IAddressesRegistry {\n    struct AddressVars {\n        IERC20Metadata collToken;\n        IBorrowerOperations borrowerOperations;\n        ITroveManager troveManager;\n        ITroveNFT troveNFT;\n        IMetadataNFT metadataNFT;\n        IStabilityPool stabilityPool;\n        IPriceFeed priceFeed;\n        IActivePool activePool;\n        IDefaultPool defaultPool;\n        address gasPoolAddress;\n        ICollSurplusPool collSurplusPool;\n        ISortedTroves sortedTroves;\n        IInterestRouter interestRouter;\n        IHintHelpers hintHelpers;\n        IMultiTroveGetter multiTroveGetter;\n        ICollateralRegistry collateralRegistry;\n        IBoldToken boldToken;\n        IWETH WETH;\n    }\n\n    function CCR() external returns (uint256);\n    function SCR() external returns (uint256);\n    function MCR() external returns (uint256);\n    function LIQUIDATION_PENALTY_SP() external returns (uint256);\n    function LIQUIDATION_PENALTY_REDISTRIBUTION() external returns (uint256);\n\n    function collToken() external view returns (IERC20Metadata);\n    function borrowerOperations() external view returns (IBorrowerOperations);\n    function troveManager() external view returns (ITroveManager);\n    function troveNFT() external view returns (ITroveNFT);\n    function metadataNFT() external view returns (IMetadataNFT);\n    function stabilityPool() external view returns (IStabilityPool);\n    function priceFeed() external view returns (IPriceFeed);\n    function activePool() external view returns (IActivePool);\n    function defaultPool() external view returns (IDefaultPool);\n    function gasPoolAddress() external view returns (address);\n    function collSurplusPool() external view returns (ICollSurplusPool);\n    function sortedTroves() external view returns (ISortedTroves);\n    function interestRouter() external view returns (IInterestRouter);\n    function hintHelpers() external view returns (IHintHelpers);\n    function multiTroveGetter() external view returns (IMultiTroveGetter);\n    function collateralRegistry() external view returns (ICollateralRegistry);\n    function boldToken() external view returns (IBoldToken);\n    function WETH() external returns (IWETH);\n\n    function setAddresses(AddressVars memory _vars) external;\n}\n"
    },
    "src/interfaces/IBoldRewardsReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IBoldRewardsReceiver {\n    function triggerBoldRewards(uint256 _boldYield) external;\n}\n"
    },
    "src/interfaces/IBoldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\n\ninterface IBoldToken is IERC20Metadata, IERC20Permit, IERC5267 {\n    function setBranchAddresses(\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) external;\n\n    function setCollateralRegistry(address _collateralRegistryAddress) external;\n\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n\n    function sendToPool(address _sender, address poolAddress, uint256 _amount) external;\n\n    function returnFromPool(address poolAddress, address user, uint256 _amount) external;\n\n    function nonces(address owner) external view returns (uint256);\n}\n"
    },
    "src/interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ILiquityBase.sol\";\nimport \"./IAddRemoveManagers.sol\";\nimport \"./IBoldToken.sol\";\nimport \"./IPriceFeed.sol\";\nimport \"./ISortedTroves.sol\";\nimport \"./ITroveManager.sol\";\nimport \"./IWETH.sol\";\n\n// Common interface for the Borrower Operations.\ninterface IBorrowerOperations is ILiquityBase, IAddRemoveManagers {\n    function CCR() external view returns (uint256);\n    function MCR() external view returns (uint256);\n    function SCR() external view returns (uint256);\n\n    function openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _ETHAmount,\n        uint256 _boldAmount,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _annualInterestRate,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver\n    ) external returns (uint256);\n\n    struct OpenTroveAndJoinInterestBatchManagerParams {\n        address owner;\n        uint256 ownerIndex;\n        uint256 collAmount;\n        uint256 boldAmount;\n        uint256 upperHint;\n        uint256 lowerHint;\n        address interestBatchManager;\n        uint256 maxUpfrontFee;\n        address addManager;\n        address removeManager;\n        address receiver;\n    }\n\n    function openTroveAndJoinInterestBatchManager(OpenTroveAndJoinInterestBatchManagerParams calldata _params)\n        external\n        returns (uint256);\n\n    function addColl(uint256 _troveId, uint256 _ETHAmount) external;\n\n    function withdrawColl(uint256 _troveId, uint256 _amount) external;\n\n    function withdrawBold(uint256 _troveId, uint256 _amount, uint256 _maxUpfrontFee) external;\n\n    function repayBold(uint256 _troveId, uint256 _amount) external;\n\n    function closeTrove(uint256 _troveId) external;\n\n    function adjustTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool isDebtIncrease,\n        uint256 _maxUpfrontFee\n    ) external;\n\n    function adjustUnredeemableTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n\n    function adjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n\n    function applyPendingDebt(uint256 _troveId, uint256 _lowerHint, uint256 _upperHint) external;\n\n    function onLiquidateTrove(uint256 _troveId) external;\n\n    function claimCollateral() external;\n\n    function hasBeenShutDown() external view returns (bool);\n    function shutdown() external;\n    function shutdownFromOracleFailure(address _failedOracleAddr) external;\n\n    function checkBatchManagerExists(address _batchMananger) external view returns (bool);\n\n    // -- individual delegation --\n    struct InterestIndividualDelegate {\n        address account;\n        uint128 minInterestRate; // TODO: If we change decimal precision for interest across all codebase, we can switch to uint48 and save 1 storage slot\n        uint128 maxInterestRate;\n    }\n\n    function getInterestIndividualDelegateOf(uint256 _troveId)\n        external\n        view\n        returns (InterestIndividualDelegate memory);\n    function setInterestIndividualDelegate(\n        uint256 _troveId,\n        address _delegate,\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        // only needed if trove was previously in a batch:\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n    function removeInterestIndividualDelegate(uint256 _troveId) external;\n\n    // -- batches --\n    struct InterestBatchManager {\n        uint128 minInterestRate;\n        uint128 maxInterestRate;\n        uint256 minInterestRateChangePeriod;\n    }\n\n    function registerBatchManager(\n        uint128 minInterestRate,\n        uint128 maxInterestRate,\n        uint128 currentInterestRate,\n        uint128 fee,\n        uint128 minInterestRateChangePeriod\n    ) external;\n    function lowerBatchManagementFee(uint256 _newAnnualFee) external;\n    function setBatchManagerAnnualInterestRate(\n        uint128 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n    function interestBatchManagerOf(uint256 _troveId) external view returns (address);\n    function getInterestBatchManager(address _account) external view returns (InterestBatchManager memory);\n    function setInterestBatchManager(\n        uint256 _troveId,\n        address _newBatchManager,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n    function removeFromBatch(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n    function switchBatchManager(\n        uint256 _troveId,\n        uint256 _removeUpperHint,\n        uint256 _removeLowerHint,\n        address _newBatchManager,\n        uint256 _addUpperHint,\n        uint256 _addLowerHint,\n        uint256 _maxUpfrontFee\n    ) external;\n}\n"
    },
    "src/interfaces/ICollateralRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./IBoldToken.sol\";\nimport \"./ITroveManager.sol\";\n\ninterface ICollateralRegistry {\n    function baseRate() external view returns (uint256);\n    function lastFeeOperationTime() external view returns (uint256);\n\n    function redeemCollateral(uint256 _boldamount, uint256 _maxIterations, uint256 _maxFeePercentage) external;\n    // getters\n    function totalCollaterals() external view returns (uint256);\n    function getToken(uint256 _index) external view returns (IERC20Metadata);\n    function getTroveManager(uint256 _index) external view returns (ITroveManager);\n    function boldToken() external view returns (IBoldToken);\n\n    function getRedemptionRate() external view returns (uint256);\n    function getRedemptionRateWithDecay() external view returns (uint256);\n    function getRedemptionRateForRedeemedAmount(uint256 _redeemAmount) external view returns (uint256);\n\n    function getRedemptionFeeWithDecay(uint256 _ETHDrawn) external view returns (uint256);\n    function getEffectiveRedemptionFeeInBold(uint256 _redeemAmount) external view returns (uint256);\n}\n"
    },
    "src/interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ICollSurplusPool {\n    function getCollBalance() external view returns (uint256);\n\n    function getCollateral(address _account) external view returns (uint256);\n\n    function accountSurplus(address _account, uint256 _amount) external;\n\n    function claimColl(address _account) external;\n}\n"
    },
    "src/interfaces/ICommunityIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ICommunityIssuance {\n    function setAddresses(address _lqtyTokenAddress, address _stabilityPoolAddress) external;\n\n    function issueLQTY() external returns (uint256);\n\n    function sendLQTY(address _account, uint256 _LQTYamount) external;\n}\n"
    },
    "src/interfaces/ICompositePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../dependencies/AggregatorV3Interface.sol\";\n\npragma solidity ^0.8.0;\n\ninterface ICompositePriceFeed is IPriceFeed {\n    function ethUsdOracle() external view returns (AggregatorV3Interface, uint256, uint8);\n    function lstEthOracle() external view returns (AggregatorV3Interface, uint256, uint8);\n}\n"
    },
    "src/interfaces/IDefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IDefaultPool {\n    function troveManagerAddress() external view returns (address);\n    function activePoolAddress() external view returns (address);\n    // --- Functions ---\n    function getCollBalance() external view returns (uint256);\n    function getBoldDebt() external view returns (uint256);\n    function sendCollToActivePool(uint256 _amount) external;\n    function receiveColl(uint256 _amount) external;\n\n    function increaseBoldDebt(uint256 _amount) external;\n    function decreaseBoldDebt(uint256 _amount) external;\n}\n"
    },
    "src/interfaces/IHintHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IHintHelpers {\n    function getApproxHint(uint256 _collIndex, uint256 _interestRate, uint256 _numTrials, uint256 _inputRandomSeed)\n        external\n        view\n        returns (uint256 hintId, uint256 diff, uint256 latestRandomSeed);\n\n    function predictOpenTroveUpfrontFee(uint256 _collIndex, uint256 _borrowedAmount, uint256 _interestRate)\n        external\n        view\n        returns (uint256);\n\n    function predictAdjustInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)\n        external\n        view\n        returns (uint256);\n\n    function forcePredictAdjustInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)\n        external\n        view\n        returns (uint256);\n\n    function predictAdjustTroveUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _debtIncrease)\n        external\n        view\n        returns (uint256);\n\n    function predictAdjustBatchInterestRateUpfrontFee(\n        uint256 _collIndex,\n        address _batchAddress,\n        uint256 _newInterestRate\n    ) external view returns (uint256);\n\n    function predictJoinBatchInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, address _batchAddress)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "src/interfaces/IInterestRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IInterestRouter {\n// TODO: functions that the interest router will have\n}\n"
    },
    "src/interfaces/ILiquityBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IActivePool.sol\";\nimport \"./IDefaultPool.sol\";\nimport \"./IPriceFeed.sol\";\n\ninterface ILiquityBase {\n    function activePool() external view returns (IActivePool);\n    function getEntireSystemDebt() external view returns (uint256);\n    function getEntireSystemColl() external view returns (uint256);\n}\n"
    },
    "src/interfaces/ILQTYStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ILQTYStaking {\n    function setAddresses(\n        address _lqtyTokenAddress,\n        address _boldTokenAddress,\n        address _troveManagerAddress,\n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) external;\n\n    function stake(uint256 _LQTYamount) external;\n\n    function unstake(uint256 _LQTYamount) external;\n\n    function increaseF_ETH(uint256 _ETHFee) external;\n\n    function increaseF_bold(uint256 _LQTYFee) external;\n\n    function getPendingETHGain(address _user) external view returns (uint256);\n\n    function getPendingBoldGain(address _user) external view returns (uint256);\n}\n"
    },
    "src/interfaces/ILQTYToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\ninterface ILQTYToken is IERC20, IERC20Permit {\n    function sendToLQTYStaking(address _sender, uint256 _amount) external;\n\n    function getDeploymentStartTime() external view returns (uint256);\n\n    function getLpRewardsEntitlement() external view returns (uint256);\n}\n"
    },
    "src/interfaces/IMultiTroveGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IMultiTroveGetter {\n    struct CombinedTroveData {\n        uint256 id;\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        uint256 annualInterestRate;\n        uint256 lastDebtUpdateTime;\n        uint256 lastInterestRateAdjTime;\n        address interestBatchManager;\n        uint256 batchDebtShares;\n        uint256 batchCollShares;\n        uint256 snapshotETH;\n        uint256 snapshotBoldDebt;\n    }\n\n    struct DebtPerInterestRate {\n        address interestBatchManager;\n        uint256 interestRate;\n        uint256 debt;\n    }\n\n    function getMultipleSortedTroves(uint256 _collIndex, int256 _startIdx, uint256 _count)\n        external\n        view\n        returns (CombinedTroveData[] memory _troves);\n\n    function getDebtPerInterestRateAscending(uint256 _collIndex, uint256 _startId, uint256 _maxIterations)\n        external\n        view\n        returns (DebtPerInterestRate[] memory, uint256 currId);\n}\n"
    },
    "src/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256, bool);\n    function lastGoodPrice() external view returns (uint256);\n    function setAddresses(address _borrowerOperationsAddress) external;\n}\n"
    },
    "src/interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ITroveManager.sol\";\nimport {BatchId, BATCH_ID_ZERO} from \"../types/BatchId.sol\";\n\ninterface ISortedTroves {\n    // -- Mutating functions (permissioned) --\n    function insert(uint256 _id, uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId) external;\n    function insertIntoBatch(\n        uint256 _troveId,\n        BatchId _batchId,\n        uint256 _annualInterestRate,\n        uint256 _prevId,\n        uint256 _nextId\n    ) external;\n\n    function remove(uint256 _id) external;\n    function removeFromBatch(uint256 _id) external;\n\n    function reInsert(uint256 _id, uint256 _newAnnualInterestRate, uint256 _prevId, uint256 _nextId) external;\n    function reInsertBatch(BatchId _id, uint256 _newAnnualInterestRate, uint256 _prevId, uint256 _nextId) external;\n\n    // -- View functions --\n\n    function contains(uint256 _id) external view returns (bool);\n    function isBatchedNode(uint256 _id) external view returns (bool);\n    function isEmptyBatch(BatchId _id) external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n    function getSize() external view returns (uint256);\n\n    function getFirst() external view returns (uint256);\n    function getLast() external view returns (uint256);\n    function getNext(uint256 _id) external view returns (uint256);\n    function getPrev(uint256 _id) external view returns (uint256);\n\n    function validInsertPosition(uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId)\n        external\n        view\n        returns (bool);\n    function findInsertPosition(uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId)\n        external\n        view\n        returns (uint256, uint256);\n\n    // Public state variable getters\n    function borrowerOperationsAddress() external view returns (address);\n    function troveManager() external view returns (ITroveManager);\n    function size() external view returns (uint256);\n    function nodes(uint256 _id) external view returns (uint256 nextId, uint256 prevId, BatchId batchId, bool exists);\n    function batches(BatchId _id) external view returns (uint256 head, uint256 tail);\n}\n"
    },
    "src/interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IActivePool.sol\";\nimport \"./ILiquityBase.sol\";\nimport \"./IBoldToken.sol\";\nimport \"./ITroveManager.sol\";\nimport \"./IBoldRewardsReceiver.sol\";\n\n/*\n * The Stability Pool holds Bold tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its Bold debt gets offset with\n * Bold in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of Bold tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a Bold loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Coll gain, as the collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total Bold in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Coll gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n*/\ninterface IStabilityPool is ILiquityBase, IBoldRewardsReceiver {\n    function boldToken() external view returns (IBoldToken);\n    function troveManager() external view returns (ITroveManager);\n\n    /*  provideToSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Increases deposit, and takes new snapshots of accumulators P and S\n    * - Sends depositor's accumulated Coll gains to depositor\n    */\n    function provideToSP(uint256 _amount, bool _doClaim) external;\n\n    /*  withdrawFromSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Sends the requested BOLD withdrawal to depositor\n    * - (If _amount > userDeposit, the user withdraws all of their compounded deposit)\n    * - Decreases deposit by withdrawn amount and takes new snapshots of accumulators P and S\n    */\n    function withdrawFromSP(uint256 _amount, bool doClaim) external;\n\n    function claimAllCollGains() external;\n\n    /*\n     * Initial checks:\n     * - Caller is TroveManager\n     * ---\n     * Cancels out the specified debt against the Bold contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(uint256 _debt, uint256 _coll) external;\n\n    function deposits(address _depositor) external view returns (uint256 initialValue);\n    function stashedColl(address _depositor) external view returns (uint256);\n\n    /*\n     * Returns the total amount of Coll held by the pool, accounted in an internal variable instead of `balance`,\n     * to exclude edge cases like Coll received from a self-destruct.\n     */\n    function getCollBalance() external view returns (uint256);\n\n    /*\n     * Returns Bold held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n     */\n    function getTotalBoldDeposits() external view returns (uint256);\n\n    function getYieldGainsOwed() external view returns (uint256);\n    function getYieldGainsPending() external view returns (uint256);\n\n    /*\n     * Calculates the Coll gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorCollGain(address _depositor) external view returns (uint256);\n\n    /*\n     * Calculates the BOLD yield gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorYieldGain(address _depositor) external view returns (uint256);\n\n    /*\n     * Calculates what `getDepositorYieldGain` will be if interest is minted now.\n     */\n    function getDepositorYieldGainWithPending(address _depositor) external view returns (uint256);\n\n    /*\n     * Return the user's compounded deposit.\n     */\n    function getCompoundedBoldDeposit(address _depositor) external view returns (uint256);\n\n    function epochToScaleToS(uint128 _epoch, uint128 _scale) external view returns (uint256);\n\n    function epochToScaleToB(uint128 _epoch, uint128 _scale) external view returns (uint256);\n\n    function P() external view returns (uint256);\n    function currentScale() external view returns (uint128);\n    function currentEpoch() external view returns (uint128);\n}\n"
    },
    "src/interfaces/IStabilityPoolEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IStabilityPoolEvents {\n    enum Operation {\n        provideToSP,\n        withdrawFromSP,\n        claimAllCollGains\n    }\n\n    event StabilityPoolCollBalanceUpdated(uint256 _newBalance);\n    event StabilityPoolBoldBalanceUpdated(uint256 _newBalance);\n\n    event P_Updated(uint256 _P);\n    event S_Updated(uint256 _S, uint128 _epoch, uint128 _scale);\n    event B_Updated(uint256 _B, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event DepositUpdated(\n        address indexed _depositor,\n        uint256 _newDeposit,\n        uint256 _stashedColl,\n        uint256 _snapshotP,\n        uint256 _snapshotS,\n        uint256 _snapshotB,\n        uint256 _snapshotScale,\n        uint256 _snapshotEpoch\n    );\n\n    event DepositOperation(\n        address indexed _depositor,\n        Operation _operation,\n        uint256 _depositLossSinceLastOperation,\n        int256 _depositChange,\n        uint256 _yieldGainSinceLastOperation,\n        uint256 _yieldGainClaimed,\n        uint256 _ethGainSinceLastOperation,\n        uint256 _ethGainClaimed\n    );\n\n    // TODO: Do we still need this, as we’ll likely have the ERC20 transfer event?\n    // This goes for ActivePool, DefaultPool, CollSurplusPool too.\n    event EtherSent(address _to, uint256 _amount);\n}\n"
    },
    "src/interfaces/ITroveEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ITroveEvents {\n    enum Operation {\n        openTrove,\n        closeTrove,\n        adjustTrove,\n        adjustTroveInterestRate,\n        applyPendingDebt,\n        liquidate,\n        redeemCollateral,\n        // batch management\n        openTroveAndJoinBatch,\n        setInterestBatchManager,\n        removeFromBatch\n    }\n\n    event Liquidation(\n        uint256 _debtOffsetBySP,\n        uint256 _debtRedistributed,\n        uint256 _boldGasCompensation,\n        uint256 _collGasCompensation,\n        uint256 _collSentToSP,\n        uint256 _collRedistributed,\n        uint256 _collSurplus,\n        uint256 _L_ETH,\n        uint256 _L_boldDebt,\n        uint256 _price\n    );\n\n    event Redemption(\n        uint256 _attemptedBoldAmount, uint256 _actualBoldAmount, uint256 _ETHSent, uint256 _ETHFee, uint256 _price\n    );\n\n    // A snapshot of the Trove's latest state on-chain\n    event TroveUpdated(\n        uint256 indexed _troveId,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _stake,\n        uint256 _annualInterestRate,\n        uint256 _snapshotOfTotalCollRedist,\n        uint256 _snapshotOfTotalDebtRedist\n    );\n\n    // Details of an operation that modifies a Trove\n    event TroveOperation(\n        uint256 indexed _troveId,\n        Operation _operation,\n        uint256 _annualInterestRate,\n        uint256 _debtIncreaseFromRedist,\n        uint256 _debtIncreaseFromUpfrontFee,\n        int256 _debtChangeFromOperation,\n        uint256 _collIncreaseFromRedist,\n        int256 _collChangeFromOperation\n    );\n\n    event RedemptionFeePaidToTrove(uint256 indexed _troveId, uint256 _ETHFee);\n\n    // Batch management\n\n    enum BatchOperation {\n        registerBatchManager,\n        lowerBatchManagerAnnualFee,\n        setBatchManagerAnnualInterestRate,\n        applyBatchInterestAndFee,\n        joinBatch,\n        exitBatch,\n        // used when the batch is updated as a result of a Trove change inside the batch\n        troveChange\n    }\n\n    event BatchUpdated(\n        address indexed _interestBatchManager,\n        BatchOperation _operation,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _annualInterestRate,\n        uint256 _annualManagementFee,\n        uint256 _totalDebtShares,\n        uint256 _debtIncreaseFromUpfrontFee\n    );\n\n    event BatchedTroveUpdated(\n        uint256 indexed _troveId,\n        address _interestBatchManager,\n        uint256 _batchDebtShares,\n        uint256 _coll,\n        uint256 _stake,\n        uint256 _snapshotOfTotalCollRedist,\n        uint256 _snapshotOfTotalDebtRedist\n    );\n}\n"
    },
    "src/interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ILiquityBase.sol\";\nimport \"./ITroveNFT.sol\";\nimport \"./IBorrowerOperations.sol\";\nimport \"./IStabilityPool.sol\";\nimport \"./IBoldToken.sol\";\nimport \"./ISortedTroves.sol\";\nimport \"../types/LatestTroveData.sol\";\nimport \"../types/LatestBatchData.sol\";\n\n// Common interface for the Trove Manager.\ninterface ITroveManager is ILiquityBase {\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        unredeemable\n    }\n\n    function shutdownTime() external view returns (uint256);\n\n    function troveNFT() external view returns (ITroveNFT);\n    function stabilityPool() external view returns (IStabilityPool);\n    //function boldToken() external view returns (IBoldToken);\n    function sortedTroves() external view returns (ISortedTroves);\n    function borrowerOperations() external view returns (IBorrowerOperations);\n\n    function Troves(uint256 _id)\n        external\n        view\n        returns (\n            uint256 debt,\n            uint256 coll,\n            uint256 stake,\n            Status status,\n            uint64 arrayIndex,\n            uint64 lastDebtUpdateTime,\n            uint64 lastInterestRateAdjTime,\n            uint256 annualInterestRate,\n            address interestBatchManager,\n            uint256 batchDebtShares\n        );\n\n    function rewardSnapshots(uint256 _id) external view returns (uint256 coll, uint256 boldDebt);\n\n    function getTroveIdsCount() external view returns (uint256);\n\n    function getTroveFromTroveIdsArray(uint256 _index) external view returns (uint256);\n\n    function getCurrentICR(uint256 _troveId, uint256 _price) external view returns (uint256);\n\n    function batchLiquidateTroves(uint256[] calldata _troveArray) external;\n\n    function redeemCollateral(\n        address _sender,\n        uint256 _boldAmount,\n        uint256 _price,\n        uint256 _redemptionRate,\n        uint256 _maxIterations\n    ) external returns (uint256 _redemeedAmount);\n\n    function shutdown() external;\n    function urgentRedemption(uint256 _boldAmount, uint256[] calldata _troveIds, uint256 _minCollateral) external;\n\n    function getUnbackedPortionPriceAndRedeemability() external returns (uint256, uint256, bool);\n\n    function getLatestTroveData(uint256 _troveId) external view returns (LatestTroveData memory);\n    function getTroveAnnualInterestRate(uint256 _troveId) external view returns (uint256);\n\n    function getTroveStatus(uint256 _troveId) external view returns (Status);\n\n    function getLatestBatchData(address _batchAddress) external view returns (LatestBatchData memory);\n\n    // -- permissioned functions called by BorrowerOperations\n\n    function onOpenTrove(address _owner, uint256 _troveId, TroveChange memory _troveChange, uint256 _annualInterestRate)\n        external;\n    function onOpenTroveAndJoinBatch(\n        address _owner,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _batchColl,\n        uint256 _batchDebt\n    ) external;\n\n    // Called from `adjustUnredeemableTrove()`\n    function setTroveStatusToActive(uint256 _troveId) external;\n\n    function onAdjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        TroveChange calldata _troveChange\n    ) external;\n\n    function onAdjustTrove(uint256 _troveId, uint256 _newColl, uint256 _newDebt, TroveChange calldata _troveChange)\n        external;\n\n    function onAdjustTroveInsideBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl,\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt\n    ) external;\n\n    function onApplyTroveInterest(\n        uint256 _troveId,\n        uint256 _newTroveColl,\n        uint256 _newTroveDebt,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt,\n        TroveChange calldata _troveChange\n    ) external;\n\n    function onCloseTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt // entire, with interest and batch fee\n    ) external;\n\n    // -- batches --\n    function onRegisterBatchManager(address _batchAddress, uint256 _annualInterestRate, uint256 _annualFee) external;\n    function onLowerBatchManagerAnnualFee(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualManagementFee\n    ) external;\n    function onSetBatchManagerAnnualInterestRate(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        uint256 _upfrontFee // needed by BatchUpdated event\n    ) external;\n\n    struct OnSetInterestBatchManagerParams {\n        uint256 troveId;\n        uint256 troveColl; // entire, with redistribution\n        uint256 troveDebt; // entire, with interest, batch fee and redistribution\n        TroveChange troveChange;\n        address newBatchAddress;\n        uint256 newBatchColl; // updated collateral for new batch manager\n        uint256 newBatchDebt; // updated debt for new batch manager\n    }\n\n    function onSetInterestBatchManager(OnSetInterestBatchManagerParams calldata _params) external;\n    function onRemoveFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        uint256 _newAnnualInterestRate\n    ) external;\n\n    // -- end of permissioned functions --\n}\n"
    },
    "src/interfaces/ITroveNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport \"./ITroveManager.sol\";\n\ninterface ITroveNFT is IERC721Metadata {\n    function mint(address _owner, uint256 _troveId) external;\n    function burn(uint256 _troveId) external;\n}\n"
    },
    "src/interfaces/IUniCardCollateral.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniCardCollateral {\n    struct AdjustParams {\n        uint256 collateralChange; // Amount of collateral to add/remove\n        bool isCollateralIncrease; // True if adding collateral, false if removing\n        uint256 debtChange; // Amount of debt to add/remove\n        bool isDebtIncrease; // True if borrowing, false if repaying\n        address repayToken; // Token used for repayment (only used when repaying)\n    }\n\n    struct LocalVariables_adjust {\n        // @notice Price\n        uint256 price;\n        // @notice Total collateral after adjustment\n        uint256 totalCollateralAfter;\n        // @notice Total debt after adjustment\n        uint256 totalDebtAfter;\n        // @notice Collateral ratio\n        uint256 collateralRatio;\n    }\n\n    event CollateralAdjusted(\n        address indexed holder,\n        uint256 collateralAmount,\n        bool isCollateralIncrease,\n        uint256 debtAmount,\n        bool isDebtIncrease,\n        address repayToken\n    );\n}\n"
    },
    "src/interfaces/IUniCardRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Enums} from \"../libraries/Enums.sol\";\n\ninterface IUniCardRegistry {\n    // Card\n    struct Card {\n        // The address of the card holder\n        address holder;\n        // The payment token of the card\n        address paymentToken;\n        // The nonce of the card\n        uint256 nonce;\n        // The amount of the card\n        uint256 openCardAmount;\n        // The product code of the card\n        string productCode;\n        // The invite code of the card\n        string inviteCode;\n        // The referral code of the card\n        string referralCode;\n        // The status of the card\n        Enums.CardStatus status;\n    }\n\n    // The address of the card holder\n    event CardOpenRequest(\n        address indexed holder,\n        // The payment token of the card\n        address indexed paymentToken,\n        // The nonce of the card\n        uint256 indexed nonce,\n        // The amount of the card\n        uint256 amount,\n        // The product code of the card\n        string productCode,\n        // The invite code of the card\n        string inviteCode,\n        // The referral code of the card\n        string referralCode\n    );\n\n    // The address of the card holder\n    // The address of the card holder\n    event CardCloseRequest(\n        address indexed holder,\n        // The nonce of the card\n        uint256 indexed nonce\n    );\n}\n"
    },
    "src/interfaces/IUniCardVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniCardVault {\n    struct Account {\n        address holder;\n        uint256 balance;\n        bool initialized;\n    }\n\n    event Deposit(string indexed cardId, address indexed holder, uint256 amount);\n    event Withdraw(string indexed cardId, address indexed holder, uint256 amount);\n\n    function deposit(string memory cardId, uint256 amount) external;\n    function withdraw(string memory cardId, uint256 amount) external;\n}\n"
    },
    "src/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IWETH is IERC20Metadata {\n    function deposit() external payable;\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "src/interfaces/IWETHPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\nimport \"./IPriceFeed.sol\";\nimport \"../dependencies/AggregatorV3Interface.sol\";\n\npragma solidity ^0.8.0;\n\ninterface IWETHPriceFeed is IPriceFeed {\n    function ethUsdOracle() external view returns (AggregatorV3Interface, uint256, uint8);\n}\n"
    },
    "src/interfaces/IWSTETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IWSTETH {\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);\n    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);\n    function stEthPerToken() external view returns (uint256);\n    function tokensPerStEth() external view returns (uint256);\n}\n"
    },
    "src/interfaces/IWSTETHPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\nimport \"./IPriceFeed.sol\";\nimport \"../dependencies/AggregatorV3Interface.sol\";\n\npragma solidity ^0.8.0;\n\ninterface IWSTETHPriceFeed is IPriceFeed {\n    function stEthUsdOracle() external view returns (AggregatorV3Interface, uint256, uint8);\n}\n"
    },
    "src/libraries/Enums.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Enums {\n    // CardStatus\n    enum CardStatus {\n        // The card is not opened yet\n        UNOPENED,\n        // The card is activated\n        ACTIVATED,\n        // The card is deactivated, so it cannot be used, user can close the card\n        // and claim the funds\n        DEACTIVATED\n    }\n}\n"
    },
    "src/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Errors {\n    // UniCardRegistry\n    error UNICARD_REGISTRY_PAYMENT_TOKEN_NOT_ALLOWED();\n    error UNICARD_REGISTRY_CARD_ALREADY_OPENED();\n    error UNICARD_REGISTRY_CARD_ALREADY_DEACTIVATED();\n    error UNICARD_REGISTRY_CARD_NOT_OPENED();\n\n    // UniCardVault\n    error UNICARD_VAULT_INVALID_HOLDER();\n    error UNICARD_VAULT_CARD_NOT_INITIALIZED();\n    error UNICARD_VAULT_INSUFFICIENT_BALANCE();\n\n    // UniCardCollateral\n    error UNICARD_COLLATERAL_INVALID_ETH_AMOUNT();\n    error UNICARD_COLLATERAL_ETH_NOT_NEEDED();\n    error UNICARD_COLLATERAL_INSUFFICIENT_COLLATERAL_RATIO();\n    error UNICARD_COLLATERAL_INSUFFICIENT_COLLATERAL();\n    error UNICARD_COLLATERAL_DEBT_REDUCTION_EXCEEDS_CURRENT_DEBT();\n    error UNICARD_COLLATERAL_INVALID_REPAY_TOKEN();\n    error UNICARD_COLLATERAL_INVALID_MINT_CALLER();\n}\n"
    },
    "src/liquity/ActivePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../dependencies/Constants.sol\";\nimport \"../interfaces/IActivePool.sol\";\nimport \"../interfaces/IAddressesRegistry.sol\";\nimport \"../interfaces/IBoldToken.sol\";\nimport \"../interfaces/IInterestRouter.sol\";\nimport \"../interfaces/IDefaultPool.sol\";\n\n// import \"forge-std/console2.sol\";\n\n/*\n * The Active Pool holds the collateral and Bold debt (but not Bold tokens) for all active troves.\n *\n * When a trove is liquidated, it's Coll and Bold debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is IActivePool {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"ActivePool\";\n\n    IERC20 public immutable collToken;\n    address public immutable borrowerOperationsAddress;\n    address public immutable troveManagerAddress;\n    address public immutable defaultPoolAddress;\n\n    IBoldToken boldToken;\n\n    IInterestRouter public interestRouter;\n    IBoldRewardsReceiver public stabilityPool;\n\n    uint256 internal collBalance; // deposited ether tracker\n\n    // Aggregate recorded debt tracker. Updated whenever a Trove's debt is touched AND whenever the aggregate pending interest is minted.\n    // \"D\" in the spec.\n    uint256 public aggRecordedDebt;\n\n    /* Sum of individual recorded Trove debts weighted by their respective chosen interest rates.\n    * Updated at individual Trove operations.\n    * \"S\" in the spec.\n    */\n    uint256 public aggWeightedDebtSum;\n\n    // Last time at which the aggregate recorded debt and weighted sum were updated\n    uint256 public lastAggUpdateTime;\n\n    // Timestamp at which branch was shut down. 0 if not shut down.\n    uint256 public shutdownTime;\n\n    // Aggregate batch fees tracker\n    uint256 public aggBatchManagementFees;\n    /* Sum of individual recorded Trove debts weighted by their respective batch management fees\n     * Updated at individual batched Trove operations.\n     */\n    uint256 public aggWeightedBatchManagementFeeSum;\n    // Last time at which the aggregate batch fees and weighted sum were updated\n    uint256 public lastAggBatchManagementFeesUpdateTime;\n\n    // --- Events ---\n\n    event CollTokenAddressChanged(address _newCollTokenAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event EtherSent(address _to, uint256 _amount);\n    event ActivePoolBoldDebtUpdated(uint256 _recordedDebtSum);\n    event ActivePoolCollBalanceUpdated(uint256 _collBalance);\n\n    constructor(IAddressesRegistry _addressesRegistry) {\n        collToken = _addressesRegistry.collToken();\n        borrowerOperationsAddress = address(_addressesRegistry.borrowerOperations());\n        troveManagerAddress = address(_addressesRegistry.troveManager());\n        stabilityPool = IBoldRewardsReceiver(_addressesRegistry.stabilityPool());\n        defaultPoolAddress = address(_addressesRegistry.defaultPool());\n        interestRouter = _addressesRegistry.interestRouter();\n        boldToken = _addressesRegistry.boldToken();\n\n        emit CollTokenAddressChanged(address(collToken));\n        emit BorrowerOperationsAddressChanged(borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(troveManagerAddress);\n        emit StabilityPoolAddressChanged(address(stabilityPool));\n        emit DefaultPoolAddressChanged(defaultPoolAddress);\n\n        // Allow funds movements between Liquity contracts\n        collToken.approve(defaultPoolAddress, type(uint256).max);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the Coll state variable.\n    *\n    *Not necessarily equal to the the contract's raw Coll balance - ether can be forcibly sent to contracts.\n    */\n    function getCollBalance() external view override returns (uint256) {\n        return collBalance;\n    }\n\n    function calcPendingAggInterest() public view returns (uint256) {\n        if (shutdownTime != 0) return 0;\n\n        // We use the ceiling of the division here to ensure positive error, while we use regular floor division\n        // when calculating the interest accrued by individual Troves.\n        // This ensures that `system debt >= sum(trove debt)` always holds, and thus system debt won't turn negative\n        // even if all Trove debt is repaid. The difference should be small and it should scale with the number of\n        // interest minting events.\n        return Math.ceilDiv(aggWeightedDebtSum * (block.timestamp - lastAggUpdateTime), ONE_YEAR * DECIMAL_PRECISION);\n    }\n\n    function calcPendingSPYield() external view returns (uint256) {\n        return calcPendingAggInterest() * SP_YIELD_SPLIT / DECIMAL_PRECISION;\n    }\n\n    function calcPendingAggBatchManagementFee() public view returns (uint256) {\n        uint256 periodEnd = shutdownTime != 0 ? shutdownTime : block.timestamp;\n        uint256 periodStart = Math.min(lastAggBatchManagementFeesUpdateTime, periodEnd);\n\n        return Math.ceilDiv(aggWeightedBatchManagementFeeSum * (periodEnd - periodStart), ONE_YEAR * DECIMAL_PRECISION);\n    }\n\n    function getNewApproxAvgInterestRateFromTroveChange(TroveChange calldata _troveChange)\n        external\n        view\n        returns (uint256)\n    {\n        // We are ignoring the upfront fee when calculating the approx. avg. interest rate.\n        // This is a simple way to resolve the circularity in:\n        //   fee depends on avg. interest rate -> avg. interest rate is weighted by debt -> debt includes fee -> ...\n        assert(_troveChange.upfrontFee == 0);\n\n        if (shutdownTime != 0) return 0;\n\n        uint256 newAggRecordedDebt = aggRecordedDebt;\n        newAggRecordedDebt += calcPendingAggInterest();\n        newAggRecordedDebt += _troveChange.appliedRedistBoldDebtGain;\n        newAggRecordedDebt += _troveChange.debtIncrease;\n        newAggRecordedDebt += _troveChange.batchAccruedManagementFee;\n        newAggRecordedDebt -= _troveChange.debtDecrease;\n\n        uint256 newAggWeightedDebtSum = aggWeightedDebtSum;\n        newAggWeightedDebtSum += _troveChange.newWeightedRecordedDebt;\n        newAggWeightedDebtSum -= _troveChange.oldWeightedRecordedDebt;\n\n        // Avoid division by 0 if the first ever borrower tries to borrow 0 BOLD\n        // Borrowing 0 BOLD is not allowed, but our check of debt >= MIN_DEBT happens _after_ calculating the upfront\n        // fee, which involves getting the new approx. avg. interest rate\n        return newAggRecordedDebt > 0 ? newAggWeightedDebtSum / newAggRecordedDebt : 0;\n    }\n\n    // Returns sum of agg.recorded debt plus agg. pending interest. Excludes pending redist. gains.\n    function getBoldDebt() external view returns (uint256) {\n        return aggRecordedDebt + calcPendingAggInterest() + aggBatchManagementFees + calcPendingAggBatchManagementFee();\n    }\n\n    // --- Pool functionality ---\n\n    function sendColl(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n\n        _accountForSendColl(_account, _amount);\n\n        collToken.safeTransfer(_account, _amount);\n    }\n\n    function sendCollToDefaultPool(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n\n        _accountForSendColl(defaultPoolAddress, _amount);\n\n        IDefaultPool(defaultPoolAddress).receiveColl(_amount);\n    }\n\n    function _accountForSendColl(address _account, uint256 _amount) internal {\n        uint256 newCollBalance = collBalance - _amount;\n        collBalance = newCollBalance;\n        emit ActivePoolCollBalanceUpdated(newCollBalance);\n        emit EtherSent(_account, _amount);\n    }\n\n    function receiveColl(uint256 _amount) external {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n\n        _accountForReceivedColl(_amount);\n\n        // Pull Coll tokens from sender\n        collToken.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function accountForReceivedColl(uint256 _amount) public {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n\n        _accountForReceivedColl(_amount);\n    }\n\n    function _accountForReceivedColl(uint256 _amount) internal {\n        uint256 newCollBalance = collBalance + _amount;\n        collBalance = newCollBalance;\n\n        emit ActivePoolCollBalanceUpdated(newCollBalance);\n    }\n\n    // --- Aggregate interest operations ---\n\n    // This function is called inside all state-changing user ops: borrower ops, liquidations, redemptions and SP deposits/withdrawals.\n    // Some user ops trigger debt changes to Trove(s), in which case _troveDebtChange will be non-zero.\n    // The aggregate recorded debt is incremented by the aggregate pending interest, plus the net Trove debt change.\n    // The net Trove debt change consists of the sum of a) any debt issued/repaid and b) any redistribution debt gain applied in the encapsulating operation.\n    // It does *not* include the Trove's individual accrued interest - this gets accounted for in the aggregate accrued interest.\n    // The net Trove debt change could be positive or negative in a repayment (depending on whether its redistribution gain or repayment amount is larger),\n    // so this function accepts both the increase and the decrease to avoid using (and converting to/from) signed ints.\n    function mintAggInterestAndAccountForTroveChange(TroveChange calldata _troveChange, address _batchAddress)\n        external\n    {\n        _requireCallerIsBOorTroveM();\n\n        // Batch management fees\n        if (_batchAddress != address(0)) {\n            _mintBatchManagementFeeAndAccountForChange(boldToken, _troveChange, _batchAddress);\n        }\n\n        // Do the arithmetic in 2 steps here to avoid overflow from the decrease\n        uint256 newAggRecordedDebt = aggRecordedDebt; // 1 SLOAD\n        newAggRecordedDebt += _mintAggInterest(boldToken, _troveChange.upfrontFee); // adds minted agg. interest + upfront fee\n        newAggRecordedDebt += _troveChange.appliedRedistBoldDebtGain;\n        newAggRecordedDebt += _troveChange.debtIncrease;\n        newAggRecordedDebt -= _troveChange.debtDecrease;\n        aggRecordedDebt = newAggRecordedDebt; // 1 SSTORE\n\n        // assert(aggRecordedDebt >= 0) // This should never be negative. If all redistribution gians and all aggregate interest was applied\n        // and all Trove debts were repaid, it should become 0.\n\n        // Do the arithmetic in 2 steps here to avoid overflow from the decrease\n        uint256 newAggWeightedDebtSum = aggWeightedDebtSum; // 1 SLOAD\n        newAggWeightedDebtSum += _troveChange.newWeightedRecordedDebt;\n        newAggWeightedDebtSum -= _troveChange.oldWeightedRecordedDebt;\n        aggWeightedDebtSum = newAggWeightedDebtSum; // 1 SSTORE\n    }\n\n    function mintAggInterest() external override {\n        _requireCallerIsBOorSP();\n        aggRecordedDebt += _mintAggInterest(boldToken, 0);\n    }\n\n    function _mintAggInterest(IBoldToken _boldToken, uint256 _upfrontFee) internal returns (uint256 mintedAmount) {\n        mintedAmount = calcPendingAggInterest() + _upfrontFee;\n\n        // Mint part of the BOLD interest to the SP and part to the router for LPs.\n        if (mintedAmount > 0) {\n            uint256 spYield = SP_YIELD_SPLIT * mintedAmount / DECIMAL_PRECISION;\n            uint256 remainderToLPs = mintedAmount - spYield;\n\n            _boldToken.mint(address(interestRouter), remainderToLPs);\n\n            if (spYield > 0) {\n                _boldToken.mint(address(stabilityPool), spYield);\n                stabilityPool.triggerBoldRewards(spYield);\n            }\n        }\n\n        lastAggUpdateTime = block.timestamp;\n    }\n\n    function mintBatchManagementFeeAndAccountForChange(TroveChange calldata _troveChange, address _batchAddress)\n        external\n        override\n    {\n        _requireCallerIsBOorTroveM();\n        _mintBatchManagementFeeAndAccountForChange(boldToken, _troveChange, _batchAddress);\n    }\n\n    function _mintBatchManagementFeeAndAccountForChange(\n        IBoldToken _boldToken,\n        TroveChange memory _troveChange,\n        address _batchAddress\n    ) internal {\n        aggRecordedDebt += _troveChange.batchAccruedManagementFee;\n\n        // Do the arithmetic in 2 steps here to avoid overflow from the decrease\n        uint256 newAggBatchManagementFees = aggBatchManagementFees; // 1 SLOAD\n        newAggBatchManagementFees += calcPendingAggBatchManagementFee();\n        newAggBatchManagementFees -= _troveChange.batchAccruedManagementFee;\n        aggBatchManagementFees = newAggBatchManagementFees; // 1 SSTORE\n\n        // Do the arithmetic in 2 steps here to avoid overflow from the decrease\n        uint256 newAggWeightedBatchManagementFeeSum = aggWeightedBatchManagementFeeSum; // 1 SLOAD\n        newAggWeightedBatchManagementFeeSum += _troveChange.newWeightedRecordedBatchManagementFee;\n        newAggWeightedBatchManagementFeeSum -= _troveChange.oldWeightedRecordedBatchManagementFee;\n        aggWeightedBatchManagementFeeSum = newAggWeightedBatchManagementFeeSum; // 1 SSTORE\n\n        // mint fee to batch address\n        if (_troveChange.batchAccruedManagementFee > 0) {\n            _boldToken.mint(_batchAddress, _troveChange.batchAccruedManagementFee);\n        }\n\n        lastAggBatchManagementFeesUpdateTime = block.timestamp;\n    }\n\n    // --- Shutdown ---\n\n    function setShutdownFlag() external {\n        _requireCallerIsTroveManager();\n        shutdownTime = block.timestamp;\n    }\n\n    function hasBeenShutDown() external view returns (bool) {\n        return shutdownTime != 0;\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == defaultPoolAddress,\n            \"ActivePool: Caller is neither BO nor Default Pool\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == troveManagerAddress\n                || msg.sender == address(stabilityPool),\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsBOorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == address(stabilityPool),\n            \"ActivePool: Caller is not BorrowerOperations nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == troveManagerAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager\"\n        );\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, \"ActivePool: Caller is not TroveManager\");\n    }\n}\n"
    },
    "src/liquity/AddressesRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../dependencies/Ownable.sol\";\nimport \"../interfaces/IAddressesRegistry.sol\";\n\ncontract AddressesRegistry is Ownable, IAddressesRegistry {\n    IERC20Metadata public collToken;\n    IBorrowerOperations public borrowerOperations;\n    ITroveManager public troveManager;\n    ITroveNFT public troveNFT;\n    IMetadataNFT public metadataNFT;\n    IStabilityPool public stabilityPool;\n    IPriceFeed public priceFeed;\n    IActivePool public activePool;\n    IDefaultPool public defaultPool;\n    address public gasPoolAddress;\n    ICollSurplusPool public collSurplusPool;\n    ISortedTroves public sortedTroves;\n    IInterestRouter public interestRouter;\n    IHintHelpers public hintHelpers;\n    IMultiTroveGetter public multiTroveGetter;\n    ICollateralRegistry public collateralRegistry;\n    IBoldToken public boldToken;\n    IWETH public WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 public immutable SCR;\n\n    // Minimum collateral ratio for individual troves\n    uint256 public immutable MCR;\n\n    // Liquidation penalty for troves offset to the SP\n    uint256 public immutable LIQUIDATION_PENALTY_SP;\n    // Liquidation penalty for troves redistributed\n    uint256 public immutable LIQUIDATION_PENALTY_REDISTRIBUTION;\n\n    error InvalidCCR();\n    error InvalidMCR();\n    error InvalidSCR();\n    error SPPenaltyTooLow();\n    error SPPenaltyGtRedist();\n    error RedistPenaltyTooHigh();\n\n    event CollTokenAddressChanged(address _collTokenAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event TroveNFTAddressChanged(address _troveNFTAddress);\n    event MetadataNFTAddressChanged(address _metadataNFTAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event PriceFeedAddressChanged(address _priceFeedAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event InterestRouterAddressChanged(address _interestRouterAddress);\n    event HintHelpersAddressChanged(address _hintHelpersAddress);\n    event MultiTroveGetterAddressChanged(address _multiTroveGetterAddress);\n    event CollateralRegistryAddressChanged(address _collateralRegistryAddress);\n    event BoldTokenAddressChanged(address _boldTokenAddress);\n    event WETHAddressChanged(address _wethAddress);\n\n    constructor(\n        address _owner,\n        uint256 _ccr,\n        uint256 _mcr,\n        uint256 _scr,\n        uint256 _liquidationPenaltySP,\n        uint256 _liquidationPenaltyRedistribution\n    ) Ownable(_owner) {\n        if (_ccr <= 1e18 || _ccr >= 2e18) revert InvalidCCR();\n        if (_mcr <= 1e18 || _mcr >= 2e18) revert InvalidMCR();\n        if (_scr <= 1e18 || _scr >= 2e18) revert InvalidSCR();\n        if (_liquidationPenaltySP < 5e16) revert SPPenaltyTooLow();\n        if (_liquidationPenaltySP > _liquidationPenaltyRedistribution) revert SPPenaltyGtRedist();\n        if (_liquidationPenaltyRedistribution > 10e16) revert RedistPenaltyTooHigh();\n\n        CCR = _ccr;\n        SCR = _scr;\n        MCR = _mcr;\n        LIQUIDATION_PENALTY_SP = _liquidationPenaltySP;\n        LIQUIDATION_PENALTY_REDISTRIBUTION = _liquidationPenaltyRedistribution;\n    }\n\n    function setAddresses(AddressVars memory _vars) external onlyOwner {\n        collToken = _vars.collToken;\n        borrowerOperations = _vars.borrowerOperations;\n        troveManager = _vars.troveManager;\n        troveNFT = _vars.troveNFT;\n        metadataNFT = _vars.metadataNFT;\n        stabilityPool = _vars.stabilityPool;\n        priceFeed = _vars.priceFeed;\n        activePool = _vars.activePool;\n        defaultPool = _vars.defaultPool;\n        gasPoolAddress = _vars.gasPoolAddress;\n        collSurplusPool = _vars.collSurplusPool;\n        sortedTroves = _vars.sortedTroves;\n        interestRouter = _vars.interestRouter;\n        hintHelpers = _vars.hintHelpers;\n        multiTroveGetter = _vars.multiTroveGetter;\n        collateralRegistry = _vars.collateralRegistry;\n        boldToken = _vars.boldToken;\n        WETH = _vars.WETH;\n\n        emit CollTokenAddressChanged(address(_vars.collToken));\n        emit BorrowerOperationsAddressChanged(address(_vars.borrowerOperations));\n        emit TroveManagerAddressChanged(address(_vars.troveManager));\n        emit TroveNFTAddressChanged(address(_vars.troveNFT));\n        emit MetadataNFTAddressChanged(address(_vars.metadataNFT));\n        emit StabilityPoolAddressChanged(address(_vars.stabilityPool));\n        emit PriceFeedAddressChanged(address(_vars.priceFeed));\n        emit ActivePoolAddressChanged(address(_vars.activePool));\n        emit DefaultPoolAddressChanged(address(_vars.defaultPool));\n        emit GasPoolAddressChanged(_vars.gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(_vars.collSurplusPool));\n        emit SortedTrovesAddressChanged(address(_vars.sortedTroves));\n        emit InterestRouterAddressChanged(address(_vars.interestRouter));\n        emit HintHelpersAddressChanged(address(_vars.hintHelpers));\n        emit MultiTroveGetterAddressChanged(address(_vars.multiTroveGetter));\n        emit CollateralRegistryAddressChanged(address(_vars.collateralRegistry));\n        emit BoldTokenAddressChanged(address(_vars.boldToken));\n        emit WETHAddressChanged(address(_vars.WETH));\n\n        _renounceOwnership();\n    }\n}\n"
    },
    "src/liquity/BoldToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"../dependencies/Ownable.sol\";\nimport \"../interfaces/IBoldToken.sol\";\n\n/*\n * --- Functionality added specific to the BoldToken ---\n *\n * 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external\n * transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending Bold directly to a Liquity\n * core contract, when they should rather call the right function.\n *\n * 2) sendToPool() and returnFromPool(): functions callable only Liquity core contracts, which move Bold tokens between Liquity <-> user.\n */\n\ncontract BoldToken is Ownable, IBoldToken, ERC20Permit {\n    string internal constant _NAME = \"Bold Stablecoin\";\n    string internal constant _SYMBOL = \"Bold\";\n\n    // --- Addresses ---\n\n    // TODO: optimize to make them immutable\n    address public collateralRegistryAddress;\n    mapping(address => bool) troveManagerAddresses;\n    mapping(address => bool) stabilityPoolAddresses;\n    mapping(address => bool) borrowerOperationsAddresses;\n    mapping(address => bool) activePoolAddresses;\n\n    // --- Events ---\n    event CollateralRegistryAddressChanged(address _newCollateralRegistryAddress);\n    event TroveManagerAddressAdded(address _newTroveManagerAddress);\n    event StabilityPoolAddressAdded(address _newStabilityPoolAddress);\n    event BorrowerOperationsAddressAdded(address _newBorrowerOperationsAddress);\n    event ActivePoolAddressAdded(address _newActivePoolAddress);\n\n    constructor(address _owner) Ownable(_owner) ERC20(_NAME, _SYMBOL) ERC20Permit(_NAME) {}\n\n    function setBranchAddresses(\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) external override onlyOwner {\n        troveManagerAddresses[_troveManagerAddress] = true;\n        emit TroveManagerAddressAdded(_troveManagerAddress);\n\n        stabilityPoolAddresses[_stabilityPoolAddress] = true;\n        emit StabilityPoolAddressAdded(_stabilityPoolAddress);\n\n        borrowerOperationsAddresses[_borrowerOperationsAddress] = true;\n        emit BorrowerOperationsAddressAdded(_borrowerOperationsAddress);\n\n        activePoolAddresses[_activePoolAddress] = true;\n        emit ActivePoolAddressAdded(_activePoolAddress);\n    }\n\n    function setCollateralRegistry(address _collateralRegistryAddress) external override onlyOwner {\n        collateralRegistryAddress = _collateralRegistryAddress;\n        emit CollateralRegistryAddressChanged(_collateralRegistryAddress);\n\n        _renounceOwnership();\n    }\n\n    function nonces(address owner) public view virtual override(ERC20Permit, IBoldToken) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    // --- Functions for intra-Liquity calls ---\n\n    function mint(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorAP();\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override {\n        _requireCallerIsCRorBOorTMorSP();\n        _burn(_account, _amount);\n    }\n\n    function sendToPool(address _sender, address _poolAddress, uint256 _amount) external override {\n        _requireCallerIsStabilityPool();\n        _transfer(_sender, _poolAddress, _amount);\n    }\n\n    function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {\n        _requireCallerIsStabilityPool();\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    // --- External functions ---\n\n    function transfer(address recipient, uint256 amount) public override(ERC20, IERC20) returns (bool) {\n        _requireValidRecipient(recipient);\n        return super.transfer(recipient, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n        public\n        override(ERC20, IERC20)\n        returns (bool)\n    {\n        _requireValidRecipient(recipient);\n        return super.transferFrom(sender, recipient, amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && _recipient != address(this),\n            \"Bold: Cannot transfer tokens directly to the Bold token contract or the zero address\"\n        );\n    }\n\n    function _requireCallerIsBOorAP() internal view {\n        require(\n            borrowerOperationsAddresses[msg.sender] || activePoolAddresses[msg.sender],\n            \"BoldToken: Caller is not BO or AP\"\n        );\n    }\n\n    function _requireCallerIsCRorBOorTMorSP() internal view {\n        require(\n            msg.sender == collateralRegistryAddress || borrowerOperationsAddresses[msg.sender]\n                || troveManagerAddresses[msg.sender] || stabilityPoolAddresses[msg.sender],\n            \"Bold: Caller is neither CR nor BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(stabilityPoolAddresses[msg.sender], \"Bold: Caller is not the StabilityPool\");\n    }\n}\n"
    },
    "src/liquity/BorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/IAddressesRegistry.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IBoldToken.sol\";\nimport \"../interfaces/ICollSurplusPool.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../dependencies/LiquityBase.sol\";\nimport \"../dependencies/AddRemoveManagers.sol\";\nimport \"../types/LatestTroveData.sol\";\nimport \"../types/LatestBatchData.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract BorrowerOperations is LiquityBase, AddRemoveManagers, IBorrowerOperations {\n    using SafeERC20 for IERC20;\n\n    // --- Connected contract declarations ---\n\n    IERC20 internal immutable collToken;\n    ITroveManager internal troveManager;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    IBoldToken internal boldToken;\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n    // Wrapped ETH for liquidation reserve (gas compensation)\n    IWETH internal immutable WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 public immutable SCR;\n    bool public hasBeenShutDown;\n\n    // Minimum collateral ratio for individual troves\n    uint256 public immutable MCR;\n\n    /*\n    * Mapping from TroveId to individual delegate for interest rate setting.\n    *\n    * This address then has the ability to update the borrower’s interest rate, but not change its debt or collateral.\n    * Useful for instance for cold/hot wallet setups.\n    */\n    mapping(uint256 => InterestIndividualDelegate) private interestIndividualDelegateOf;\n\n    /*\n     * Mapping from TroveId to granted address for interest rate setting (batch manager).\n     *\n     * Batch managers set the interest rate for every Trove in the batch. The interest rate is the same for all Troves in the batch.\n     */\n    mapping(uint256 => address) public interestBatchManagerOf;\n\n    // List of registered Interest Batch Managers\n    mapping(address => InterestBatchManager) private interestBatchManagers;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct OpenTroveVars {\n        ITroveManager troveManager;\n        uint256 troveId;\n        TroveChange change;\n        LatestBatchData batch;\n    }\n\n    struct LocalVariables_openTrove {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IBoldToken boldToken;\n        uint256 troveId;\n        uint256 price;\n        uint256 avgInterestRate;\n        uint256 entireDebt;\n        uint256 ICR;\n        uint256 newTCR;\n        bool newOracleFailureDetected;\n    }\n\n    struct LocalVariables_adjustTrove {\n        IActivePool activePool;\n        IBoldToken boldToken;\n        LatestTroveData trove;\n        uint256 price;\n        bool isBelowCriticalThreshold;\n        uint256 newICR;\n        uint256 newDebt;\n        uint256 newColl;\n        bool newOracleFailureDetected;\n    }\n\n    struct LocalVariables_setInterestBatchManager {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ISortedTroves sortedTroves;\n        address oldBatchManager;\n        LatestTroveData trove;\n        LatestBatchData oldBatch;\n        LatestBatchData newBatch;\n    }\n\n    struct LocalVariables_removeFromBatch {\n        ITroveManager troveManager;\n        ISortedTroves sortedTroves;\n        address batchManager;\n        LatestTroveData trove;\n        LatestBatchData batch;\n        uint256 newBatchDebt;\n    }\n\n    error IsShutDown();\n    error NotShutDown();\n    error TCRNotBelowSCR();\n    error ZeroAdjustment();\n    error NotOwnerNorInterestManager();\n    error TroveInBatch();\n    error TroveNotInBatch();\n    error InterestNotInRange();\n    error BatchInterestRateChangePeriodNotPassed();\n    error TroveNotOpen();\n    error TroveNotActive();\n    error TroveNotUnredeemable();\n    error TroveOpen();\n    error UpfrontFeeTooHigh();\n    error BelowCriticalThreshold();\n    error BorrowingNotPermittedBelowCT();\n    error ICRBelowMCR();\n    error RepaymentNotMatchingCollWithdrawal();\n    error TCRBelowCCR();\n    error DebtBelowMin();\n    error CollWithdrawalTooHigh();\n    error NotEnoughBoldBalance();\n    error InterestRateTooLow();\n    error InterestRateTooHigh();\n    error InterestRateNotNew();\n    error InvalidInterestBatchManager();\n    error BatchManagerExists();\n    error BatchManagerNotNew();\n    error NewFeeNotLower();\n    error CallerNotTroveManager();\n    error CallerNotPriceFeed();\n    error MinGeMax();\n    error AnnualManagementFeeTooHigh();\n    error MinInterestRateChangePeriodTooLow();\n    error NewOracleFailureDetected();\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event BoldTokenAddressChanged(address _boldTokenAddress);\n\n    event ShutDown(uint256 _tcr);\n    event ShutDownFromOracleFailure(address _oracleAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry)\n        AddRemoveManagers(_addressesRegistry)\n        LiquityBase(_addressesRegistry)\n    {\n        // This makes impossible to open a trove with zero withdrawn Bold\n        assert(MIN_DEBT > 0);\n\n        collToken = _addressesRegistry.collToken();\n\n        WETH = _addressesRegistry.WETH();\n\n        CCR = _addressesRegistry.CCR();\n        SCR = _addressesRegistry.SCR();\n        MCR = _addressesRegistry.MCR();\n\n        troveManager = _addressesRegistry.troveManager();\n        gasPoolAddress = _addressesRegistry.gasPoolAddress();\n        collSurplusPool = _addressesRegistry.collSurplusPool();\n        sortedTroves = _addressesRegistry.sortedTroves();\n        boldToken = _addressesRegistry.boldToken();\n\n        emit TroveManagerAddressChanged(address(troveManager));\n        emit GasPoolAddressChanged(gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(collSurplusPool));\n        emit SortedTrovesAddressChanged(address(sortedTroves));\n        emit BoldTokenAddressChanged(address(boldToken));\n\n        // Allow funds movements between Liquity contracts\n        collToken.approve(address(activePool), type(uint256).max);\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _annualInterestRate,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver\n    ) external override returns (uint256) {\n        _requireValidAnnualInterestRate(_annualInterestRate);\n\n        OpenTroveVars memory vars;\n\n        vars.troveId = _openTrove(\n            _owner,\n            _ownerIndex,\n            _collAmount,\n            _boldAmount,\n            _annualInterestRate,\n            address(0),\n            0,\n            0,\n            _maxUpfrontFee,\n            _addManager,\n            _removeManager,\n            _receiver,\n            vars.change\n        );\n\n        // Set the stored Trove properties and mint the NFT\n        troveManager.onOpenTrove(_owner, vars.troveId, vars.change, _annualInterestRate);\n\n        sortedTroves.insert(vars.troveId, _annualInterestRate, _upperHint, _lowerHint);\n\n        return vars.troveId;\n    }\n\n    function openTroveAndJoinInterestBatchManager(OpenTroveAndJoinInterestBatchManagerParams calldata _params)\n        external\n        override\n        returns (uint256)\n    {\n        _requireValidInterestBatchManager(_params.interestBatchManager);\n\n        OpenTroveVars memory vars;\n        vars.troveManager = troveManager;\n\n        vars.batch = vars.troveManager.getLatestBatchData(_params.interestBatchManager);\n\n        // We set old weighted values here, as it’s only necessary for batches, so we don’t need to pass them to _openTrove func\n        vars.change.batchAccruedManagementFee = vars.batch.accruedManagementFee;\n        vars.change.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt;\n        vars.change.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee;\n        vars.troveId = _openTrove(\n            _params.owner,\n            _params.ownerIndex,\n            _params.collAmount,\n            _params.boldAmount,\n            vars.batch.annualInterestRate,\n            _params.interestBatchManager,\n            vars.batch.entireDebtWithoutRedistribution,\n            vars.batch.annualManagementFee,\n            _params.maxUpfrontFee,\n            _params.addManager,\n            _params.removeManager,\n            _params.receiver,\n            vars.change\n        );\n\n        interestBatchManagerOf[vars.troveId] = _params.interestBatchManager;\n\n        // Set the stored Trove properties and mint the NFT\n        vars.troveManager.onOpenTroveAndJoinBatch(\n            _params.owner,\n            vars.troveId,\n            vars.change,\n            _params.interestBatchManager,\n            vars.batch.entireCollWithoutRedistribution,\n            vars.batch.entireDebtWithoutRedistribution\n        );\n\n        sortedTroves.insertIntoBatch(\n            vars.troveId,\n            BatchId.wrap(_params.interestBatchManager),\n            vars.batch.annualInterestRate,\n            _params.upperHint,\n            _params.lowerHint\n        );\n\n        return vars.troveId;\n    }\n\n    function _openTrove(\n        address _owner,\n        uint256 _ownerIndex,\n        uint256 _collAmount,\n        uint256 _boldAmount,\n        uint256 _annualInterestRate,\n        address _interestBatchManager,\n        uint256 _batchEntireDebt,\n        uint256 _batchManagementAnnualFee,\n        uint256 _maxUpfrontFee,\n        address _addManager,\n        address _removeManager,\n        address _receiver,\n        TroveChange memory _change\n    ) internal returns (uint256) {\n        _requireIsNotShutDown();\n\n        LocalVariables_openTrove memory vars;\n\n        // TODO: stack too deep not allowing to reuse troveManager from outer functions\n        vars.troveManager = troveManager;\n        vars.activePool = activePool;\n        vars.boldToken = boldToken;\n\n        vars.price = _requireOraclesLive();\n\n        // --- Checks ---\n\n        _requireNotBelowCriticalThreshold(vars.price);\n\n        vars.troveId = uint256(keccak256(abi.encode(_owner, _ownerIndex)));\n        _requireTroveIsNotOpen(vars.troveManager, vars.troveId);\n\n        _change.collIncrease = _collAmount;\n        _change.debtIncrease = _boldAmount;\n\n        // For simplicity, we ignore the fee when calculating the approx. interest rate\n        _change.newWeightedRecordedDebt = (_batchEntireDebt + _change.debtIncrease) * _annualInterestRate;\n\n        vars.avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_change);\n        _change.upfrontFee = _calcUpfrontFee(_change.debtIncrease, vars.avgInterestRate);\n        _requireUserAcceptsUpfrontFee(_change.upfrontFee, _maxUpfrontFee);\n\n        vars.entireDebt = _change.debtIncrease + _change.upfrontFee;\n        _requireAtLeastMinDebt(vars.entireDebt);\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee, and the batch fee if needed\n        if (_interestBatchManager == address(0)) {\n            _change.newWeightedRecordedDebt = vars.entireDebt * _annualInterestRate;\n        } else {\n            // old values have been set outside, before calling this function\n            _change.newWeightedRecordedDebt = (_batchEntireDebt + vars.entireDebt) * _annualInterestRate;\n            _change.newWeightedRecordedBatchManagementFee =\n                (_batchEntireDebt + vars.entireDebt) * _batchManagementAnnualFee;\n        }\n\n        // ICR is based on the composite debt, i.e. the requested Bold amount + Bold gas comp + upfront fee.\n        vars.ICR = LiquityMath._computeCR(_collAmount, vars.entireDebt, vars.price);\n        _requireICRisAboveMCR(vars.ICR);\n\n        vars.newTCR = _getNewTCRFromTroveChange(_change, vars.price);\n        _requireNewTCRisAboveCCR(vars.newTCR);\n\n        // --- Effects & interactions ---\n\n        // Set add/remove managers\n        // TODO: We can restore the condition for non-zero managers if we end up ipmlementing at least one of:\n        // - wipe them out on closing troves\n        // - do not reuse troveIds\n        // for now it is safer to make sure they are set\n        _setAddManager(vars.troveId, _addManager);\n        _setRemoveManagerAndReceiver(vars.troveId, _removeManager, _receiver);\n\n        vars.activePool.mintAggInterestAndAccountForTroveChange(_change, _interestBatchManager);\n\n        // Pull coll tokens from sender and move them to the Active Pool\n        _pullCollAndSendToActivePool(vars.activePool, _collAmount);\n\n        // Mint the requested _boldAmount to the borrower and mint the gas comp to the GasPool\n        vars.boldToken.mint(msg.sender, _boldAmount);\n        WETH.transferFrom(msg.sender, gasPoolAddress, ETH_GAS_COMPENSATION);\n\n        return vars.troveId;\n    }\n\n    // Send collateral to a trove\n    function addColl(uint256 _troveId, uint256 _collAmount) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.collIncrease = _collAmount;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    // Withdraw collateral from a trove\n    function withdrawColl(uint256 _troveId, uint256 _collWithdrawal) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.collDecrease = _collWithdrawal;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    // Withdraw Bold tokens from a trove: mint new Bold tokens to the owner, and increase the trove's debt accordingly\n    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.debtIncrease = _boldAmount;\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n    }\n\n    // Repay Bold tokens to a Trove: Burn the repaid Bold tokens, and reduce the trove's debt accordingly\n    function repayBold(uint256 _troveId, uint256 _boldAmount) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        troveChange.debtDecrease = _boldAmount;\n\n        _adjustTrove(\n            troveManagerCached,\n            _troveId,\n            troveChange,\n            0 // _maxUpfrontFee\n        );\n    }\n\n    function _initTroveChange(\n        TroveChange memory _troveChange,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease\n    ) internal pure {\n        if (_isCollIncrease) {\n            _troveChange.collIncrease = _collChange;\n        } else {\n            _troveChange.collDecrease = _collChange;\n        }\n\n        if (_isDebtIncrease) {\n            _troveChange.debtIncrease = _boldChange;\n        } else {\n            _troveChange.debtDecrease = _boldChange;\n        }\n    }\n\n    function adjustTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _maxUpfrontFee\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n    }\n\n    function adjustUnredeemableTrove(\n        uint256 _troveId,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _boldChange,\n        bool _isDebtIncrease,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n        _requireTroveIsUnredeemable(troveManagerCached, _troveId);\n\n        TroveChange memory troveChange;\n        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);\n        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);\n\n        troveManagerCached.setTroveStatusToActive(_troveId);\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        uint256 batchAnnualInteresRate;\n        if (batchManager != address(0)) {\n            LatestBatchData memory batch = troveManagerCached.getLatestBatchData(batchManager);\n            batchAnnualInteresRate = batch.annualInterestRate;\n        }\n        _reInsertIntoSortedTroves(\n            _troveId,\n            troveManagerCached.getTroveAnnualInterestRate(_troveId),\n            _upperHint,\n            _lowerHint,\n            batchManager,\n            batchAnnualInteresRate\n        );\n    }\n\n    function adjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireValidAnnualInterestRate(_newAnnualInterestRate);\n        _requireIsNotInBatch(_troveId);\n        address owner = troveNFT.ownerOf(_troveId);\n        _requireSenderIsOwnerOrInterestManager(_troveId, owner);\n        _requireInterestRateInDelegateRange(_troveId, _newAnnualInterestRate);\n        _requireTroveIsActive(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n        _requireAnnualInterestRateIsNew(trove.annualInterestRate, _newAnnualInterestRate);\n\n        uint256 newDebt = trove.entireDebt;\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n        troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n\n        // Apply upfront fee on premature adjustments\n        if (\n            trove.annualInterestRate != _newAnnualInterestRate\n                && block.timestamp < trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            newDebt = _applyUpfrontFee(trove.entireColl, newDebt, troveChange, _maxUpfrontFee);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n\n        activePool.mintAggInterestAndAccountForTroveChange(troveChange, address(0));\n\n        sortedTroves.reInsert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);\n        troveManagerCached.onAdjustTroveInterestRate(\n            _troveId, trove.entireColl, newDebt, _newAnnualInterestRate, troveChange\n        );\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n    */\n    function _adjustTrove(\n        ITroveManager _troveManager,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        uint256 _maxUpfrontFee\n    ) internal {\n        _requireIsNotShutDown();\n\n        LocalVariables_adjustTrove memory vars;\n        vars.activePool = activePool;\n        vars.boldToken = boldToken;\n\n        vars.price = _requireOraclesLive();\n        vars.isBelowCriticalThreshold = _checkBelowCriticalThreshold(vars.price, CCR);\n\n        // --- Checks ---\n\n        _requireTroveIsOpen(_troveManager, _troveId);\n\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = owner; // If it’s a withdrawal, and manager has receive privilege, manager would be the receiver\n\n        if (_troveChange.collDecrease > 0 || _troveChange.debtIncrease > 0) {\n            receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        }\n\n        if (_troveChange.collIncrease > 0 || _troveChange.debtDecrease > 0) {\n            _requireSenderIsOwnerOrAddManager(_troveId, owner);\n        }\n\n        vars.trove = _troveManager.getLatestTroveData(_troveId);\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough Bold\n        if (_troveChange.debtDecrease > 0) {\n            uint256 maxRepayment = vars.trove.entireDebt > MIN_DEBT ? vars.trove.entireDebt - MIN_DEBT : 0;\n            if (_troveChange.debtDecrease > maxRepayment) {\n                _troveChange.debtDecrease = maxRepayment;\n            }\n            _requireSufficientBoldBalance(vars.boldToken, msg.sender, _troveChange.debtDecrease);\n        }\n\n        _requireNonZeroAdjustment(_troveChange);\n\n        // When the adjustment is a collateral withdrawal, check that it's no more than the Trove's entire collateral\n        if (_troveChange.collDecrease > 0) {\n            _requireValidCollWithdrawal(vars.trove.entireColl, _troveChange.collDecrease);\n        }\n\n        vars.newColl = vars.trove.entireColl + _troveChange.collIncrease - _troveChange.collDecrease;\n        vars.newDebt = vars.trove.entireDebt + _troveChange.debtIncrease - _troveChange.debtDecrease;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        bool isTroveInBatch = batchManager != address(0);\n        LatestBatchData memory batch;\n        uint256 batchFutureDebt;\n        if (isTroveInBatch) {\n            batch = _troveManager.getLatestBatchData(batchManager);\n\n            batchFutureDebt = batch.entireDebtWithoutRedistribution + vars.trove.redistBoldDebtGain\n                + _troveChange.debtIncrease - _troveChange.debtDecrease;\n\n            // TODO: comment\n            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n            _troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            _troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n            _troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n        } else {\n            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n            _troveChange.oldWeightedRecordedDebt = vars.trove.weightedRecordedDebt;\n            _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;\n        }\n\n        // Pay an upfront fee on debt increases\n        if (_troveChange.debtIncrease > 0) {\n            uint256 avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);\n            _troveChange.upfrontFee = _calcUpfrontFee(_troveChange.debtIncrease, avgInterestRate);\n            _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);\n\n            vars.newDebt += _troveChange.upfrontFee;\n            if (isTroveInBatch) {\n                batchFutureDebt += _troveChange.upfrontFee;\n                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n                _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n                _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n            } else {\n                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n                _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;\n            }\n        }\n\n        // Make sure the Trove doesn't end up unredeemable\n        // Now the max repayment is capped to stay above MIN_DEBT, so this only applies to adjustUnredeemableTrove\n        _requireAtLeastMinDebt(vars.newDebt);\n\n        vars.newICR = LiquityMath._computeCR(vars.newColl, vars.newDebt, vars.price);\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(_troveChange, vars);\n\n        // --- Effects and interactions ---\n\n        if (isTroveInBatch) {\n            _troveManager.onAdjustTroveInsideBatch(\n                _troveId,\n                vars.newColl,\n                _troveChange,\n                batchManager,\n                batch.entireCollWithoutRedistribution,\n                batch.entireDebtWithoutRedistribution\n            );\n        } else {\n            _troveManager.onAdjustTrove(_troveId, vars.newColl, vars.newDebt, _troveChange);\n        }\n\n        vars.activePool.mintAggInterestAndAccountForTroveChange(_troveChange, batchManager);\n        _moveTokensFromAdjustment(receiver, _troveChange, vars.boldToken, vars.activePool);\n    }\n\n    function closeTrove(uint256 _troveId) external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        IBoldToken boldTokenCached = boldToken;\n\n        // --- Checks ---\n\n        address owner = troveNFT.ownerOf(_troveId);\n        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);\n        _requireTroveIsOpen(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n\n        // The borrower must repay their entire debt including accrued interest, batch fee and redist. gains\n        _requireSufficientBoldBalance(boldTokenCached, msg.sender, trove.entireDebt);\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.collDecrease = trove.entireColl;\n        troveChange.debtDecrease = trove.entireDebt;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        LatestBatchData memory batch;\n        if (batchManager != address(0)) {\n            batch = troveManagerCached.getLatestBatchData(batchManager);\n            uint256 batchFutureDebt =\n                batch.entireDebtWithoutRedistribution - (trove.entireDebt - trove.redistBoldDebtGain);\n            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;\n            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;\n        } else {\n            troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n            // troveChange.newWeightedRecordedDebt = 0;\n        }\n\n        (uint256 price,) = priceFeed.fetchPrice();\n        uint256 newTCR = _getNewTCRFromTroveChange(troveChange, price);\n        if (!hasBeenShutDown) _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.onCloseTrove(\n            _troveId,\n            troveChange,\n            batchManager,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution\n        );\n\n        // If trove is in batch\n        if (batchManager != address(0)) {\n            // Unlink here in BorrowerOperations\n            interestBatchManagerOf[_troveId] = address(0);\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, batchManager);\n\n        // Return ETH gas compensation\n        WETH.transferFrom(gasPoolAddress, receiver, ETH_GAS_COMPENSATION);\n        // Burn the remainder of the Trove's entire debt from the user\n        boldTokenCached.burn(msg.sender, trove.entireDebt);\n\n        // Send the collateral back to the user\n        activePoolCached.sendColl(receiver, trove.entireColl);\n\n        _wipeTroveMappings(_troveId);\n    }\n\n    function applyPendingDebt(uint256 _troveId, uint256 _lowerHint, uint256 _upperHint) public {\n        _requireIsNotShutDown();\n\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireTroveIsOpen(troveManagerCached, _troveId);\n\n        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);\n        TroveChange memory change;\n        change.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        change.appliedRedistCollGain = trove.redistCollGain;\n\n        address batchManager = interestBatchManagerOf[_troveId];\n        LatestBatchData memory batch;\n\n        if (batchManager == address(0)) {\n            change.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n            change.newWeightedRecordedDebt = trove.entireDebt * trove.annualInterestRate;\n        } else {\n            batch = troveManagerCached.getLatestBatchData(batchManager);\n            change.batchAccruedManagementFee = batch.accruedManagementFee;\n            change.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n            change.newWeightedRecordedDebt =\n                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualInterestRate;\n            change.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n            change.newWeightedRecordedBatchManagementFee =\n                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualManagementFee;\n        }\n\n        troveManagerCached.onApplyTroveInterest(\n            _troveId,\n            trove.entireColl,\n            trove.entireDebt,\n            batchManager,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            change\n        );\n        activePool.mintAggInterestAndAccountForTroveChange(change, batchManager);\n\n        // If the trove was unredeemable, and now it’s not anymore, put it back in the list\n        if (_checkTroveIsUnredeemable(troveManagerCached, _troveId) && trove.entireDebt >= MIN_DEBT) {\n            troveManagerCached.setTroveStatusToActive(_troveId);\n            _reInsertIntoSortedTroves(\n                _troveId, trove.annualInterestRate, _upperHint, _lowerHint, batchManager, batch.annualInterestRate\n            );\n        }\n    }\n\n    function getInterestIndividualDelegateOf(uint256 _troveId)\n        external\n        view\n        returns (InterestIndividualDelegate memory)\n    {\n        return interestIndividualDelegateOf[_troveId];\n    }\n\n    function setInterestIndividualDelegate(\n        uint256 _troveId,\n        address _delegate,\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        // only needed if trove was previously in a batch:\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n        _requireTroveIsActive(troveManager, _troveId);\n        _requireCallerIsBorrower(_troveId);\n        _requireValidAnnualInterestRate(_minInterestRate);\n        _requireValidAnnualInterestRate(_maxInterestRate);\n        // With the check below, it could only be ==\n        _requireOrderedRange(_minInterestRate, _maxInterestRate);\n\n        interestIndividualDelegateOf[_troveId] =\n            InterestIndividualDelegate(_delegate, _minInterestRate, _maxInterestRate);\n        // Can’t have both individual delegation and batch manager\n        if (interestBatchManagerOf[_troveId] != address(0)) {\n            // Not needed, implicitly checked in removeFromBatch\n            //_requireValidAnnualInterestRate(_newAnnualInterestRate);\n            removeFromBatch(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint, _maxUpfrontFee);\n        }\n    }\n\n    function removeInterestIndividualDelegate(uint256 _troveId) external {\n        _requireCallerIsBorrower(_troveId);\n        delete interestIndividualDelegateOf[_troveId];\n    }\n\n    function getInterestBatchManager(address _account) external view returns (InterestBatchManager memory) {\n        return interestBatchManagers[_account];\n    }\n\n    function registerBatchManager(\n        uint128 _minInterestRate,\n        uint128 _maxInterestRate,\n        uint128 _currentInterestRate,\n        uint128 _annualManagementFee,\n        uint128 _minInterestRateChangePeriod\n    ) external {\n        _requireIsNotShutDown();\n        _requireNonExistentInterestBatchManager(msg.sender);\n        _requireValidAnnualInterestRate(_minInterestRate);\n        _requireValidAnnualInterestRate(_maxInterestRate);\n        // With the check below, it could only be ==\n        _requireOrderedRange(_minInterestRate, _maxInterestRate);\n        _requireInterestRateInRange(_currentInterestRate, _minInterestRate, _maxInterestRate);\n        // Not needed, implicitly checked in the condition above:\n        //_requireValidAnnualInterestRate(_currentInterestRate);\n        if (_annualManagementFee > MAX_ANNUAL_BATCH_MANAGEMENT_FEE) revert AnnualManagementFeeTooHigh();\n        if (_minInterestRateChangePeriod < MIN_INTEREST_RATE_CHANGE_PERIOD) revert MinInterestRateChangePeriodTooLow();\n\n        interestBatchManagers[msg.sender] =\n            InterestBatchManager(_minInterestRate, _maxInterestRate, _minInterestRateChangePeriod);\n\n        troveManager.onRegisterBatchManager(msg.sender, _currentInterestRate, _annualManagementFee);\n    }\n\n    function lowerBatchManagementFee(uint256 _newAnnualManagementFee) external {\n        _requireIsNotShutDown();\n        _requireValidInterestBatchManager(msg.sender);\n\n        ITroveManager troveManagerCached = troveManager;\n\n        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);\n        if (_newAnnualManagementFee >= batch.annualManagementFee) {\n            revert NewFeeNotLower();\n        }\n\n        // Lower batch fee on TM\n        troveManagerCached.onLowerBatchManagerAnnualFee(\n            msg.sender,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            _newAnnualManagementFee\n        );\n\n        // active pool mint\n        TroveChange memory batchChange;\n        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee =\n            batch.entireDebtWithoutRedistribution * _newAnnualManagementFee;\n\n        activePool.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);\n    }\n\n    function setBatchManagerAnnualInterestRate(\n        uint128 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) external {\n        _requireIsNotShutDown();\n        _requireValidInterestBatchManager(msg.sender);\n        _requireInterestRateInBatchManagerRange(msg.sender, _newAnnualInterestRate);\n        // Not needed, implicitly checked in the condition above:\n        //_requireValidAnnualInterestRate(_newAnnualInterestRate);\n\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n\n        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);\n        _requireInterestRateChangePeriodPassed(msg.sender, uint256(batch.lastInterestRateAdjTime));\n\n        uint256 newDebt = batch.entireDebtWithoutRedistribution;\n\n        TroveChange memory batchChange;\n        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;\n\n        // Apply upfront fee on premature adjustments\n        if (\n            batch.annualInterestRate != _newAnnualInterestRate\n                && block.timestamp < batch.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            uint256 price = _requireOraclesLive();\n\n            uint256 avgInterestRate = activePoolCached.getNewApproxAvgInterestRateFromTroveChange(batchChange);\n            batchChange.upfrontFee = _calcUpfrontFee(newDebt, avgInterestRate);\n            _requireUserAcceptsUpfrontFee(batchChange.upfrontFee, _maxUpfrontFee);\n\n            newDebt += batchChange.upfrontFee;\n\n            // Recalculate the batch's weighted terms, now taking into account the upfront fee\n            batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;\n            batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;\n\n            // Disallow a premature adjustment if it would result in TCR < CCR\n            // (which includes the case when TCR is already below CCR before the adjustment).\n            uint256 newTCR = _getNewTCRFromTroveChange(batchChange, price);\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);\n\n        // Check batch is not empty, and then reinsert in sorted list\n        if (!sortedTroves.isEmptyBatch(BatchId.wrap(msg.sender))) {\n            sortedTroves.reInsertBatch(BatchId.wrap(msg.sender), _newAnnualInterestRate, _upperHint, _lowerHint);\n        }\n\n        troveManagerCached.onSetBatchManagerAnnualInterestRate(\n            msg.sender, batch.entireCollWithoutRedistribution, newDebt, _newAnnualInterestRate, batchChange.upfrontFee\n        );\n    }\n\n    function setInterestBatchManager(\n        uint256 _troveId,\n        address _newBatchManager,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) public override {\n        _requireIsNotShutDown();\n        LocalVariables_setInterestBatchManager memory vars;\n        vars.troveManager = troveManager;\n        vars.activePool = activePool;\n        vars.sortedTroves = sortedTroves;\n\n        _requireTroveIsActive(vars.troveManager, _troveId);\n        _requireCallerIsBorrower(_troveId);\n        _requireValidInterestBatchManager(_newBatchManager);\n        _requireIsNotInBatch(_troveId);\n\n        interestBatchManagerOf[_troveId] = _newBatchManager;\n        // Can’t have both individual delegation and batch manager\n        if (interestIndividualDelegateOf[_troveId].account != address(0)) delete interestIndividualDelegateOf[_troveId];\n\n        vars.trove = vars.troveManager.getLatestTroveData(_troveId);\n        vars.newBatch = vars.troveManager.getLatestBatchData(_newBatchManager);\n\n        TroveChange memory newBatchTroveChange;\n        newBatchTroveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n        newBatchTroveChange.appliedRedistCollGain = vars.trove.redistCollGain;\n        newBatchTroveChange.batchAccruedManagementFee = vars.newBatch.accruedManagementFee;\n        newBatchTroveChange.oldWeightedRecordedDebt =\n            vars.newBatch.weightedRecordedDebt + vars.trove.weightedRecordedDebt;\n        newBatchTroveChange.newWeightedRecordedDebt =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;\n\n        // We may check the old rate to see if it’s different than the new one, but then we should check the\n        // last interest adjustment times to avoid gaming. So we decided to keep it simple and account it always\n        // as a change. It’s probably not so common to join a batch with the exact same interest rate.\n        // Apply upfront fee on premature adjustments\n        if (block.timestamp < vars.trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN) {\n            vars.trove.entireDebt =\n                _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, newBatchTroveChange, _maxUpfrontFee);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        newBatchTroveChange.newWeightedRecordedDebt =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;\n\n        // Add batch fees\n        newBatchTroveChange.oldWeightedRecordedBatchManagementFee = vars.newBatch.weightedRecordedBatchManagementFee;\n        newBatchTroveChange.newWeightedRecordedBatchManagementFee =\n            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualManagementFee;\n        vars.activePool.mintAggInterestAndAccountForTroveChange(newBatchTroveChange, _newBatchManager);\n\n        vars.troveManager.onSetInterestBatchManager(\n            ITroveManager.OnSetInterestBatchManagerParams({\n                troveId: _troveId,\n                troveColl: vars.trove.entireColl,\n                troveDebt: vars.trove.entireDebt,\n                troveChange: newBatchTroveChange,\n                newBatchAddress: _newBatchManager,\n                newBatchColl: vars.newBatch.entireCollWithoutRedistribution,\n                newBatchDebt: vars.newBatch.entireDebtWithoutRedistribution\n            })\n        );\n\n        vars.sortedTroves.remove(_troveId);\n        vars.sortedTroves.insertIntoBatch(\n            _troveId, BatchId.wrap(_newBatchManager), vars.newBatch.annualInterestRate, _upperHint, _lowerHint\n        );\n    }\n\n    function removeFromBatch(\n        uint256 _troveId,\n        uint256 _newAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        uint256 _maxUpfrontFee\n    ) public override {\n        _requireIsNotShutDown();\n\n        LocalVariables_removeFromBatch memory vars;\n        vars.troveManager = troveManager;\n        vars.sortedTroves = sortedTroves;\n\n        _requireTroveIsActive(vars.troveManager, _troveId);\n        _requireCallerIsBorrower(_troveId);\n        _requireValidAnnualInterestRate(_newAnnualInterestRate);\n\n        vars.batchManager = _requireIsInBatch(_troveId);\n        delete interestBatchManagerOf[_troveId];\n\n        // Remove trove from Batch in SortedTroves\n        vars.sortedTroves.removeFromBatch(_troveId);\n        // Reinsert as single trove\n        vars.sortedTroves.insert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);\n\n        vars.trove = vars.troveManager.getLatestTroveData(_troveId);\n        vars.batch = vars.troveManager.getLatestBatchData(vars.batchManager);\n\n        uint256 batchFutureDebt =\n            vars.batch.entireDebtWithoutRedistribution - (vars.trove.entireDebt - vars.trove.redistBoldDebtGain);\n\n        TroveChange memory batchChange;\n        batchChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;\n        batchChange.appliedRedistCollGain = vars.trove.redistCollGain;\n        batchChange.batchAccruedManagementFee = vars.batch.accruedManagementFee;\n        batchChange.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt;\n        batchChange.newWeightedRecordedDebt =\n            batchFutureDebt * vars.batch.annualInterestRate + vars.trove.entireDebt * _newAnnualInterestRate;\n\n        // Apply upfront fee on premature adjustments\n        if (\n            vars.batch.annualInterestRate != _newAnnualInterestRate\n                && block.timestamp < vars.trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            vars.trove.entireDebt =\n                _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, batchChange, _maxUpfrontFee);\n        }\n\n        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee\n        batchChange.newWeightedRecordedDebt =\n            batchFutureDebt * vars.batch.annualInterestRate + vars.trove.entireDebt * _newAnnualInterestRate;\n        // Add batch fees\n        batchChange.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee;\n        batchChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * vars.batch.annualManagementFee;\n\n        activePool.mintAggInterestAndAccountForTroveChange(batchChange, vars.batchManager);\n\n        vars.troveManager.onRemoveFromBatch(\n            _troveId,\n            vars.trove.entireColl,\n            vars.trove.entireDebt,\n            batchChange,\n            vars.batchManager,\n            vars.batch.entireCollWithoutRedistribution,\n            vars.batch.entireDebtWithoutRedistribution,\n            _newAnnualInterestRate\n        );\n    }\n\n    function switchBatchManager(\n        uint256 _troveId,\n        uint256 _removeUpperHint,\n        uint256 _removeLowerHint,\n        address _newBatchManager,\n        uint256 _addUpperHint,\n        uint256 _addLowerHint,\n        uint256 _maxUpfrontFee\n    ) external override {\n        address oldBatchManager = _requireIsInBatch(_troveId);\n        _requireNewInterestBatchManager(oldBatchManager, _newBatchManager);\n\n        LatestBatchData memory oldBatch = troveManager.getLatestBatchData(oldBatchManager);\n\n        removeFromBatch(_troveId, oldBatch.annualInterestRate, _removeUpperHint, _removeLowerHint, 0);\n        setInterestBatchManager(_troveId, _newBatchManager, _addUpperHint, _addLowerHint, _maxUpfrontFee);\n    }\n\n    function _applyUpfrontFee(\n        uint256 _troveEntireColl,\n        uint256 _troveEntireDebt,\n        TroveChange memory _troveChange,\n        uint256 _maxUpfrontFee\n    ) internal returns (uint256) {\n        uint256 price = _requireOraclesLive();\n\n        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);\n        _troveChange.upfrontFee = _calcUpfrontFee(_troveEntireDebt, avgInterestRate);\n        _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);\n\n        _troveEntireDebt += _troveChange.upfrontFee;\n\n        // ICR is based on the composite debt, i.e. the requested Bold amount + Bold gas comp + upfront fee.\n        uint256 newICR = LiquityMath._computeCR(_troveEntireColl, _troveEntireDebt, price);\n        _requireICRisAboveMCR(newICR);\n\n        // Disallow a premature adjustment if it would result in TCR < CCR\n        // (which includes the case when TCR is already below CCR before the adjustment).\n        uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, price);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        return _troveEntireDebt;\n    }\n\n    function _calcUpfrontFee(uint256 _debt, uint256 _avgInterestRate) internal pure returns (uint256) {\n        return _calcInterest(_debt * _avgInterestRate, UPFRONT_INTEREST_PERIOD);\n    }\n\n    // Call from TM to clean state here\n    function onLiquidateTrove(uint256 _troveId) external {\n        _requireCallerIsTroveManager();\n\n        _wipeTroveMappings(_troveId);\n    }\n\n    function _wipeTroveMappings(uint256 _troveId) internal {\n        delete interestIndividualDelegateOf[_troveId];\n        delete interestBatchManagerOf[_troveId];\n        delete addManagerOf[_troveId];\n        delete removeManagerReceiverOf[_troveId];\n    }\n\n    /**\n     * Claim remaining collateral from a liquidation with ICR exceeding the liquidation penalty\n     */\n    function claimCollateral() external override {\n        // send coll from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    function shutdown() external {\n        if (hasBeenShutDown) revert IsShutDown();\n\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n        (uint256 price,) = priceFeed.fetchPrice();\n\n        uint256 TCR = LiquityMath._computeCR(totalColl, totalDebt, price);\n        if (TCR >= SCR) revert TCRNotBelowSCR();\n\n        _applyShutdown();\n\n        emit ShutDown(TCR);\n    }\n\n    // Not technically a \"Borrower op\", but seems best placed here given current shutdown logic.\n    function shutdownFromOracleFailure(address _failedOracleAddr) external {\n        _requireCallerIsPriceFeed();\n\n        // No-op rather than revert here, so that the outer function call which fetches the price does not revert\n        // if the system is already shut down.\n        if (hasBeenShutDown) return;\n\n        _applyShutdown();\n\n        emit ShutDownFromOracleFailure(_failedOracleAddr);\n    }\n\n    function _applyShutdown() internal {\n        activePool.mintAggInterest();\n        hasBeenShutDown = true;\n        troveManager.shutdown();\n    }\n\n    // --- Helper functions ---\n\n    function _reInsertIntoSortedTroves(\n        uint256 _troveId,\n        uint256 _troveAnnualInterestRate,\n        uint256 _upperHint,\n        uint256 _lowerHint,\n        address _batchManager,\n        uint256 _batchAnnualInterestRate\n    ) internal {\n        // If it was in a batch, we need to put it back, otherwise we insert it normally\n        if (_batchManager == address(0)) {\n            sortedTroves.insert(_troveId, _troveAnnualInterestRate, _upperHint, _lowerHint);\n        } else {\n            sortedTroves.insertIntoBatch(\n                _troveId, BatchId.wrap(_batchManager), _batchAnnualInterestRate, _upperHint, _lowerHint\n            );\n        }\n    }\n\n    // This function mints the BOLD corresponding to the borrower's chosen debt increase\n    // (it does not mint the accrued interest).\n    function _moveTokensFromAdjustment(\n        address withdrawalReceiver,\n        TroveChange memory _troveChange,\n        IBoldToken _boldToken,\n        IActivePool _activePool\n    ) internal {\n        if (_troveChange.debtIncrease > 0) {\n            _boldToken.mint(withdrawalReceiver, _troveChange.debtIncrease);\n        } else if (_troveChange.debtDecrease > 0) {\n            _boldToken.burn(msg.sender, _troveChange.debtDecrease);\n        }\n\n        if (_troveChange.collIncrease > 0) {\n            // Pull coll tokens from sender and move them to the Active Pool\n            _pullCollAndSendToActivePool(_activePool, _troveChange.collIncrease);\n        } else if (_troveChange.collDecrease > 0) {\n            // Pull Coll from Active Pool and decrease its recorded Coll balance\n            _activePool.sendColl(withdrawalReceiver, _troveChange.collDecrease);\n        }\n    }\n\n    function _pullCollAndSendToActivePool(IActivePool _activePool, uint256 _amount) internal {\n        // Send Coll tokens from sender to active pool\n        collToken.safeTransferFrom(msg.sender, address(_activePool), _amount);\n        // Make sure Active Pool accountancy is right\n        _activePool.accountForReceivedColl(_amount);\n    }\n\n    function checkBatchManagerExists(address _batchManager) external view returns (bool) {\n        return interestBatchManagers[_batchManager].maxInterestRate > 0;\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireIsNotShutDown() internal view {\n        if (hasBeenShutDown) {\n            revert IsShutDown();\n        }\n    }\n\n    function _requireIsShutDown() internal view {\n        if (!hasBeenShutDown) {\n            revert NotShutDown();\n        }\n    }\n\n    function _requireNonZeroAdjustment(TroveChange memory _troveChange) internal pure {\n        if (\n            _troveChange.collIncrease == 0 && _troveChange.collDecrease == 0 && _troveChange.debtIncrease == 0\n                && _troveChange.debtDecrease == 0\n        ) {\n            revert ZeroAdjustment();\n        }\n    }\n\n    function _requireSenderIsOwnerOrInterestManager(uint256 _troveId, address _owner) internal view {\n        if (msg.sender != _owner && msg.sender != interestIndividualDelegateOf[_troveId].account) {\n            revert NotOwnerNorInterestManager();\n        }\n    }\n\n    function _requireIsNotInBatch(uint256 _troveId) internal view {\n        if (interestBatchManagerOf[_troveId] != address(0)) {\n            revert TroveInBatch();\n        }\n    }\n\n    function _requireIsInBatch(uint256 _troveId) internal view returns (address) {\n        address batchManager = interestBatchManagerOf[_troveId];\n        if (batchManager == address(0)) {\n            revert TroveNotInBatch();\n        }\n\n        return batchManager;\n    }\n\n    function _requireTroveIsOpen(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.active && status != ITroveManager.Status.unredeemable) {\n            revert TroveNotOpen();\n        }\n    }\n\n    function _requireTroveIsActive(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status != ITroveManager.Status.active) {\n            revert TroveNotActive();\n        }\n    }\n\n    function _requireTroveIsUnredeemable(ITroveManager _troveManager, uint256 _troveId) internal view {\n        if (!_checkTroveIsUnredeemable(_troveManager, _troveId)) {\n            revert TroveNotUnredeemable();\n        }\n    }\n\n    function _checkTroveIsUnredeemable(ITroveManager _troveManager, uint256 _troveId) internal view returns (bool) {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        return status == ITroveManager.Status.unredeemable;\n    }\n\n    function _requireTroveIsNotOpen(ITroveManager _troveManager, uint256 _troveId) internal view {\n        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);\n        if (status == ITroveManager.Status.active || status == ITroveManager.Status.unredeemable) {\n            revert TroveOpen();\n        }\n    }\n\n    function _requireUserAcceptsUpfrontFee(uint256 _fee, uint256 _maxFee) internal pure {\n        if (_fee > _maxFee) {\n            revert UpfrontFeeTooHigh();\n        }\n    }\n\n    function _requireNotBelowCriticalThreshold(uint256 _price) internal view {\n        if (_checkBelowCriticalThreshold(_price, CCR)) {\n            revert BelowCriticalThreshold();\n        }\n    }\n\n    function _requireNoBorrowing(uint256 _debtIncrease) internal pure {\n        if (_debtIncrease > 0) {\n            revert BorrowingNotPermittedBelowCT();\n        }\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        TroveChange memory _troveChange,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /*\n        * Below Critical Threshold, it is not permitted:\n        *\n        * - Borrowing\n        * - Collateral withdrawal except accompanied by a debt repayment of at least the same value\n        *\n        * In Normal Mode, ensure:\n        *\n        * - The adjustment won't pull the TCR below CCR\n        *\n        * In Both cases:\n        * - The new ICR is above MCR\n        */\n        _requireICRisAboveMCR(_vars.newICR);\n\n        if (_vars.isBelowCriticalThreshold) {\n            _requireNoBorrowing(_troveChange.debtIncrease);\n            _requireDebtRepaymentGeCollWithdrawal(_troveChange, _vars.price);\n        } else {\n            // if Normal Mode\n            uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, _vars.price);\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal view {\n        if (_newICR < MCR) {\n            revert ICRBelowMCR();\n        }\n    }\n\n    function _requireDebtRepaymentGeCollWithdrawal(TroveChange memory _troveChange, uint256 _price) internal pure {\n        if ((_troveChange.debtDecrease * DECIMAL_PRECISION < _troveChange.collDecrease * _price)) {\n            revert RepaymentNotMatchingCollWithdrawal();\n        }\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal view {\n        if (_newTCR < CCR) {\n            revert TCRBelowCCR();\n        }\n    }\n\n    function _requireAtLeastMinDebt(uint256 _debt) internal pure {\n        if (_debt < MIN_DEBT) {\n            revert DebtBelowMin();\n        }\n    }\n\n    function _requireValidCollWithdrawal(uint256 _currentColl, uint256 _collWithdrawal) internal pure {\n        if (_collWithdrawal > _currentColl) {\n            revert CollWithdrawalTooHigh();\n        }\n    }\n\n    function _requireSufficientBoldBalance(IBoldToken _boldToken, address _borrower, uint256 _debtRepayment)\n        internal\n        view\n    {\n        if (_boldToken.balanceOf(_borrower) < _debtRepayment) {\n            revert NotEnoughBoldBalance();\n        }\n    }\n\n    function _requireValidAnnualInterestRate(uint256 _annualInterestRate) internal pure {\n        if (_annualInterestRate < MIN_ANNUAL_INTEREST_RATE) {\n            revert InterestRateTooLow();\n        }\n        if (_annualInterestRate > MAX_ANNUAL_INTEREST_RATE) {\n            revert InterestRateTooHigh();\n        }\n    }\n\n    function _requireAnnualInterestRateIsNew(uint256 _oldAnnualInterestRate, uint256 _newAnnualInterestRate)\n        internal\n        pure\n    {\n        if (_oldAnnualInterestRate == _newAnnualInterestRate) {\n            revert InterestRateNotNew();\n        }\n    }\n\n    function _requireOrderedRange(uint256 _minInterestRate, uint256 _maxInterestRate) internal pure {\n        if (_minInterestRate >= _maxInterestRate) revert MinGeMax();\n    }\n\n    function _requireInterestRateInDelegateRange(uint256 _troveId, uint256 _annualInterestRate) internal view {\n        InterestIndividualDelegate memory individualDelegate = interestIndividualDelegateOf[_troveId];\n        if (individualDelegate.account != address(0)) {\n            _requireInterestRateInRange(\n                _annualInterestRate, individualDelegate.minInterestRate, individualDelegate.maxInterestRate\n            );\n        }\n    }\n\n    function _requireInterestRateInBatchManagerRange(address _interestBatchManagerAddress, uint256 _annualInterestRate)\n        internal\n        view\n    {\n        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];\n        _requireInterestRateInRange(\n            _annualInterestRate, interestBatchManager.minInterestRate, interestBatchManager.maxInterestRate\n        );\n    }\n\n    function _requireInterestRateInRange(\n        uint256 _annualInterestRate,\n        uint256 _minInterestRate,\n        uint256 _maxInterestRate\n    ) internal pure {\n        if (_minInterestRate > _annualInterestRate || _annualInterestRate > _maxInterestRate) {\n            revert InterestNotInRange();\n        }\n    }\n\n    function _requireInterestRateChangePeriodPassed(\n        address _interestBatchManagerAddress,\n        uint256 _lastInterestRateAdjTime\n    ) internal view {\n        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];\n        if (block.timestamp < _lastInterestRateAdjTime + uint256(interestBatchManager.minInterestRateChangePeriod)) {\n            revert BatchInterestRateChangePeriodNotPassed();\n        }\n    }\n\n    function _requireValidInterestBatchManager(address _interestBatchManagerAddress) internal view {\n        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate == 0) {\n            revert InvalidInterestBatchManager();\n        }\n    }\n\n    function _requireNonExistentInterestBatchManager(address _interestBatchManagerAddress) internal view {\n        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate > 0) {\n            revert BatchManagerExists();\n        }\n    }\n\n    function _requireNewInterestBatchManager(address _oldBatchManagerAddress, address _newBatchManagerAddress)\n        internal\n        pure\n    {\n        if (_oldBatchManagerAddress == _newBatchManagerAddress) {\n            revert BatchManagerNotNew();\n        }\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        if (msg.sender != address(troveManager)) {\n            revert CallerNotTroveManager();\n        }\n    }\n\n    function _requireCallerIsPriceFeed() internal view {\n        if (msg.sender != address(priceFeed)) {\n            revert CallerNotPriceFeed();\n        }\n    }\n\n    function _requireOraclesLive() internal returns (uint256) {\n        (uint256 price, bool newOracleFailureDetected) = priceFeed.fetchPrice();\n        if (newOracleFailureDetected) {\n            revert NewOracleFailureDetected();\n        }\n\n        return price;\n    }\n\n    // --- ICR and TCR getters ---\n\n    function _getNewTCRFromTroveChange(TroveChange memory _troveChange, uint256 _price)\n        internal\n        view\n        returns (uint256 newTCR)\n    {\n        uint256 totalColl = getEntireSystemColl();\n        totalColl += _troveChange.collIncrease;\n        totalColl -= _troveChange.collDecrease;\n\n        uint256 totalDebt = getEntireSystemDebt();\n        totalDebt += _troveChange.debtIncrease;\n        totalDebt += _troveChange.upfrontFee;\n        totalDebt -= _troveChange.debtDecrease;\n\n        newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n    }\n}\n"
    },
    "src/liquity/CollateralRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IBoldToken.sol\";\nimport \"../dependencies/Constants.sol\";\nimport \"../dependencies/LiquityMath.sol\";\n\nimport \"../interfaces/ICollateralRegistry.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract CollateralRegistry is ICollateralRegistry {\n    // mapping from Collateral token address to the corresponding TroveManagers\n    //mapping(address => address) troveManagers;\n    // See: https://github.com/ethereum/solidity/issues/12587\n    uint256 public immutable totalCollaterals;\n\n    IERC20Metadata internal immutable token0;\n    IERC20Metadata internal immutable token1;\n    IERC20Metadata internal immutable token2;\n    IERC20Metadata internal immutable token3;\n    IERC20Metadata internal immutable token4;\n    IERC20Metadata internal immutable token5;\n    IERC20Metadata internal immutable token6;\n    IERC20Metadata internal immutable token7;\n    IERC20Metadata internal immutable token8;\n    IERC20Metadata internal immutable token9;\n\n    ITroveManager internal immutable troveManager0;\n    ITroveManager internal immutable troveManager1;\n    ITroveManager internal immutable troveManager2;\n    ITroveManager internal immutable troveManager3;\n    ITroveManager internal immutable troveManager4;\n    ITroveManager internal immutable troveManager5;\n    ITroveManager internal immutable troveManager6;\n    ITroveManager internal immutable troveManager7;\n    ITroveManager internal immutable troveManager8;\n    ITroveManager internal immutable troveManager9;\n\n    IBoldToken public immutable boldToken;\n\n    uint256 public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new Bold issuance)\n    uint256 public lastFeeOperationTime = block.timestamp;\n\n    event BaseRateUpdated(uint256 _baseRate);\n    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\n\n    constructor(IBoldToken _boldToken, IERC20Metadata[] memory _tokens, ITroveManager[] memory _troveManagers) {\n        uint256 numTokens = _tokens.length;\n        require(numTokens > 0, \"Collateral list cannot be empty\");\n        require(numTokens <= 10, \"Collateral list too long\");\n        totalCollaterals = numTokens;\n\n        boldToken = _boldToken;\n\n        token0 = _tokens[0];\n        token1 = numTokens > 1 ? _tokens[1] : IERC20Metadata(address(0));\n        token2 = numTokens > 2 ? _tokens[2] : IERC20Metadata(address(0));\n        token3 = numTokens > 3 ? _tokens[3] : IERC20Metadata(address(0));\n        token4 = numTokens > 4 ? _tokens[4] : IERC20Metadata(address(0));\n        token5 = numTokens > 5 ? _tokens[5] : IERC20Metadata(address(0));\n        token6 = numTokens > 6 ? _tokens[6] : IERC20Metadata(address(0));\n        token7 = numTokens > 7 ? _tokens[7] : IERC20Metadata(address(0));\n        token8 = numTokens > 8 ? _tokens[8] : IERC20Metadata(address(0));\n        token9 = numTokens > 9 ? _tokens[9] : IERC20Metadata(address(0));\n\n        troveManager0 = _troveManagers[0];\n        troveManager1 = numTokens > 1 ? _troveManagers[1] : ITroveManager(address(0));\n        troveManager2 = numTokens > 2 ? _troveManagers[2] : ITroveManager(address(0));\n        troveManager3 = numTokens > 3 ? _troveManagers[3] : ITroveManager(address(0));\n        troveManager4 = numTokens > 4 ? _troveManagers[4] : ITroveManager(address(0));\n        troveManager5 = numTokens > 5 ? _troveManagers[5] : ITroveManager(address(0));\n        troveManager6 = numTokens > 6 ? _troveManagers[6] : ITroveManager(address(0));\n        troveManager7 = numTokens > 7 ? _troveManagers[7] : ITroveManager(address(0));\n        troveManager8 = numTokens > 8 ? _troveManagers[8] : ITroveManager(address(0));\n        troveManager9 = numTokens > 9 ? _troveManagers[9] : ITroveManager(address(0));\n\n        // Initialize the baseRate state variable\n        baseRate = INITIAL_BASE_RATE;\n        emit BaseRateUpdated(INITIAL_BASE_RATE);\n    }\n\n    struct RedemptionTotals {\n        uint256 numCollaterals;\n        uint256 boldSupplyAtStart;\n        uint256 unbacked;\n        uint256 redeemedAmount;\n    }\n\n    function redeemCollateral(uint256 _boldAmount, uint256 _maxIterationsPerCollateral, uint256 _maxFeePercentage)\n        external\n    {\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAmountGreaterThanZero(_boldAmount);\n        _requireBoldBalanceCoversRedemption(boldToken, msg.sender, _boldAmount);\n\n        RedemptionTotals memory totals;\n\n        totals.numCollaterals = totalCollaterals;\n        uint256[] memory unbackedPortions = new uint256[](totals.numCollaterals);\n        uint256[] memory prices = new uint256[](totals.numCollaterals);\n\n        totals.boldSupplyAtStart = boldToken.totalSupply();\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total Bold supply value, from before it was reduced by the redemption.\n        // We only compute it here, and update it at the end,\n        // because the final redeemed amount may be less than the requested amount\n        // Redeemers should take this into account in order to request the optimal amount to not overpay\n        uint256 redemptionRate =\n            _calcRedemptionRate(_getUpdatedBaseRateFromRedemption(_boldAmount, totals.boldSupplyAtStart));\n        require(redemptionRate <= _maxFeePercentage, \"CR: Fee exceeded provided maximum\");\n        // Implicit by the above and the _requireValidMaxFeePercentage checks\n        //require(newBaseRate < DECIMAL_PRECISION, \"CR: Fee would eat up all collateral\");\n\n        // Gather and accumulate unbacked portions\n        for (uint256 index = 0; index < totals.numCollaterals; index++) {\n            ITroveManager troveManager = getTroveManager(index);\n            (uint256 unbackedPortion, uint256 price, bool redeemable) =\n                troveManager.getUnbackedPortionPriceAndRedeemability();\n            prices[index] = price;\n            if (redeemable) {\n                totals.unbacked += unbackedPortion;\n                unbackedPortions[index] = unbackedPortion;\n            }\n        }\n\n        // There’s an unlikely scenario where all the normally redeemable branches (i.e. having TCR > SCR) have 0 unbacked\n        // In that case, we redeem proportinally to branch size\n        if (totals.unbacked == 0) {\n            unbackedPortions = new uint256[](totals.numCollaterals);\n            for (uint256 index = 0; index < totals.numCollaterals; index++) {\n                ITroveManager troveManager = getTroveManager(index);\n                (,, bool redeemable) = troveManager.getUnbackedPortionPriceAndRedeemability();\n                if (redeemable) {\n                    uint256 unbackedPortion = troveManager.getEntireSystemDebt();\n                    totals.unbacked += unbackedPortion;\n                    unbackedPortions[index] = unbackedPortion;\n                }\n            }\n        }\n\n        // Compute redemption amount for each collateral and redeem against the corresponding TroveManager\n        for (uint256 index = 0; index < totals.numCollaterals; index++) {\n            //uint256 unbackedPortion = unbackedPortions[index];\n            if (unbackedPortions[index] > 0) {\n                uint256 redeemAmount = _boldAmount * unbackedPortions[index] / totals.unbacked;\n                if (redeemAmount > 0) {\n                    ITroveManager troveManager = getTroveManager(index);\n                    uint256 redeemedAmount = troveManager.redeemCollateral(\n                        msg.sender, redeemAmount, prices[index], redemptionRate, _maxIterationsPerCollateral\n                    );\n                    totals.redeemedAmount += redeemedAmount;\n                }\n            }\n        }\n\n        _updateBaseRateAndGetRedemptionRate(totals.redeemedAmount, totals.boldSupplyAtStart);\n\n        // Burn the total Bold that is cancelled with debt\n        if (totals.redeemedAmount > 0) {\n            boldToken.burn(msg.sender, totals.redeemedAmount);\n        }\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint256 timePassed = block.timestamp - lastFeeOperationTime;\n\n        if (timePassed >= ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint256) {\n        return (block.timestamp - lastFeeOperationTime) / ONE_MINUTE;\n    }\n\n    // Updates the `baseRate` state with math from `_getUpdatedBaseRateFromRedemption`\n    function _updateBaseRateAndGetRedemptionRate(uint256 _boldAmount, uint256 _totalBoldSupplyAtStart) internal {\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_boldAmount, _totalBoldSupplyAtStart);\n\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in `_getUpdatedBaseRateFromRedemption`\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n    /*\n     * This function calculates the new baseRate in the following way:\n     * 1) decays the baseRate based on time passed since last redemption or Bold borrowing operation.\n     * then,\n     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n     */\n    function _getUpdatedBaseRateFromRedemption(uint256 _redeemAmount, uint256 _totalBoldSupply)\n        internal\n        view\n        returns (uint256)\n    {\n        // decay the base rate\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\n\n        // get the fraction of total supply that was redeemed\n        uint256 redeemedBoldFraction = _redeemAmount * DECIMAL_PRECISION / _totalBoldSupply;\n\n        uint256 newBaseRate = decayedBaseRate + redeemedBoldFraction / REDEMPTION_BETA;\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n\n        return newBaseRate;\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint256) {\n        uint256 minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint256 decayFactor = LiquityMath._decPow(REDEMPTION_MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate * decayFactor / DECIMAL_PRECISION;\n    }\n\n    function _calcRedemptionRate(uint256 _baseRate) internal pure returns (uint256) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR + _baseRate,\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _calcRedemptionFee(uint256 _redemptionRate, uint256 _amount) internal pure returns (uint256) {\n        uint256 redemptionFee = _redemptionRate * _amount / DECIMAL_PRECISION;\n        return redemptionFee;\n    }\n\n    // external redemption rate/fee getters\n\n    function getRedemptionRate() external view override returns (uint256) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint256) {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function getRedemptionRateForRedeemedAmount(uint256 _redeemAmount) external view returns (uint256) {\n        uint256 totalBoldSupply = boldToken.totalSupply();\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_redeemAmount, totalBoldSupply);\n        return _calcRedemptionRate(newBaseRate);\n    }\n\n    function getRedemptionFeeWithDecay(uint256 _ETHDrawn) external view override returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _ETHDrawn);\n    }\n\n    function getEffectiveRedemptionFeeInBold(uint256 _redeemAmount) external view override returns (uint256) {\n        uint256 totalBoldSupply = boldToken.totalSupply();\n        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_redeemAmount, totalBoldSupply);\n        return _calcRedemptionFee(_calcRedemptionRate(newBaseRate), _redeemAmount);\n    }\n\n    // getters\n\n    function getToken(uint256 _index) external view returns (IERC20Metadata) {\n        if (_index == 0) return token0;\n        else if (_index == 1) return token1;\n        else if (_index == 2) return token2;\n        else if (_index == 3) return token3;\n        else if (_index == 4) return token4;\n        else if (_index == 5) return token5;\n        else if (_index == 6) return token6;\n        else if (_index == 7) return token7;\n        else if (_index == 8) return token8;\n        else if (_index == 9) return token9;\n        else revert(\"Invalid index\");\n    }\n\n    function getTroveManager(uint256 _index) public view returns (ITroveManager) {\n        if (_index == 0) return troveManager0;\n        else if (_index == 1) return troveManager1;\n        else if (_index == 2) return troveManager2;\n        else if (_index == 3) return troveManager3;\n        else if (_index == 4) return troveManager4;\n        else if (_index == 5) return troveManager5;\n        else if (_index == 6) return troveManager6;\n        else if (_index == 7) return troveManager7;\n        else if (_index == 8) return troveManager8;\n        else if (_index == 9) return troveManager9;\n        else revert(\"Invalid index\");\n    }\n\n    // require functions\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal pure {\n        require(\n            _maxFeePercentage >= REDEMPTION_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n            \"Max fee percentage must be between 0.5% and 100%\"\n        );\n    }\n\n    function _requireAmountGreaterThanZero(uint256 _amount) internal pure {\n        require(_amount > 0, \"CollateralRegistry: Amount must be greater than zero\");\n    }\n\n    function _requireBoldBalanceCoversRedemption(IBoldToken _boldToken, address _redeemer, uint256 _amount)\n        internal\n        view\n    {\n        uint256 boldBalance = _boldToken.balanceOf(_redeemer);\n        // Confirm redeemer's balance is less than total Bold supply\n        assert(boldBalance <= _boldToken.totalSupply());\n        require(\n            boldBalance >= _amount,\n            \"CollateralRegistry: Requested redemption amount must be <= user's Bold token balance\"\n        );\n    }\n}\n"
    },
    "src/liquity/CollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/ICollSurplusPool.sol\";\nimport \"../interfaces/IAddressesRegistry.sol\";\n\ncontract CollSurplusPool is ICollSurplusPool {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"CollSurplusPool\";\n\n    IERC20 public immutable collToken;\n    address public immutable borrowerOperationsAddress;\n    address public immutable troveManagerAddress;\n\n    // deposited ether tracker\n    uint256 internal collBalance;\n    // Collateral surplus claimable by trove owners\n    mapping(address => uint256) internal balances;\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n\n    event CollBalanceUpdated(address indexed _account, uint256 _newBalance);\n    event CollSent(address _to, uint256 _amount);\n\n    constructor(IAddressesRegistry _addressesRegistry) {\n        collToken = _addressesRegistry.collToken();\n        borrowerOperationsAddress = address(_addressesRegistry.borrowerOperations());\n        troveManagerAddress = address(_addressesRegistry.troveManager());\n\n        emit BorrowerOperationsAddressChanged(borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(troveManagerAddress);\n    }\n\n    /* Returns the collBalance state variable\n       Not necessarily equal to the raw coll balance - coll can be forcibly sent to contracts. */\n    function getCollBalance() external view override returns (uint256) {\n        return collBalance;\n    }\n\n    function getCollateral(address _account) external view override returns (uint256) {\n        return balances[_account];\n    }\n\n    // --- Pool functionality ---\n\n    function accountSurplus(address _account, uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n\n        uint256 newAmount = balances[_account] + _amount;\n        balances[_account] = newAmount;\n        collBalance = collBalance + _amount;\n\n        emit CollBalanceUpdated(_account, newAmount);\n    }\n\n    function claimColl(address _account) external override {\n        _requireCallerIsBorrowerOperations();\n        uint256 claimableColl = balances[_account];\n        require(claimableColl > 0, \"CollSurplusPool: No collateral available to claim\");\n\n        balances[_account] = 0;\n        emit CollBalanceUpdated(_account, 0);\n\n        collBalance = collBalance - claimableColl;\n        emit CollSent(_account, claimableColl);\n\n        collToken.safeTransfer(_account, claimableColl);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"CollSurplusPool: Caller is not Borrower Operations\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, \"CollSurplusPool: Caller is not TroveManager\");\n    }\n}\n"
    },
    "src/liquity/DefaultPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IDefaultPool.sol\";\nimport \"../interfaces/IAddressesRegistry.sol\";\nimport \"../interfaces/IActivePool.sol\";\n\n// import \"forge-std/console2.sol\";\n\n/*\n * The Default Pool holds the Coll and Bold debt (but not Bold tokens) from liquidations that have been redistributed\n * to active troves but not yet \"applied\", i.e. not yet recorded on a recipient active trove's struct.\n *\n * When a trove makes an operation that applies its pending Coll and Bold debt, its pending Coll and Bold debt is moved\n * from the Default Pool to the Active Pool.\n */\ncontract DefaultPool is IDefaultPool {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"DefaultPool\";\n\n    IERC20 public immutable collToken;\n    address public immutable troveManagerAddress;\n    address public immutable activePoolAddress;\n    uint256 internal collBalance; // deposited Coll tracker\n    uint256 internal BoldDebt; // debt\n\n    event CollTokenAddressChanged(address _newCollTokenAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event EtherSent(address _to, uint256 _amount);\n    event DefaultPoolBoldDebtUpdated(uint256 _boldDebt);\n    event DefaultPoolCollBalanceUpdated(uint256 _collBalance);\n\n    constructor(IAddressesRegistry _addressesRegistry) {\n        collToken = _addressesRegistry.collToken();\n        troveManagerAddress = address(_addressesRegistry.troveManager());\n        activePoolAddress = address(_addressesRegistry.activePool());\n\n        emit CollTokenAddressChanged(address(collToken));\n        emit TroveManagerAddressChanged(troveManagerAddress);\n        emit ActivePoolAddressChanged(activePoolAddress);\n\n        // Allow funds movements between Liquity contracts\n        collToken.approve(activePoolAddress, type(uint256).max);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the collBalance state variable.\n    *\n    * Not necessarily equal to the the contract's raw Coll balance - ether can be forcibly sent to contracts.\n    */\n    function getCollBalance() external view override returns (uint256) {\n        return collBalance;\n    }\n\n    function getBoldDebt() external view override returns (uint256) {\n        return BoldDebt;\n    }\n\n    // --- Pool functionality ---\n\n    function sendCollToActivePool(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n        uint256 newCollBalance = collBalance - _amount;\n        collBalance = newCollBalance;\n        emit DefaultPoolCollBalanceUpdated(newCollBalance);\n        emit EtherSent(activePoolAddress, _amount);\n\n        // Send Coll to Active Pool and increase its recorded Coll balance\n        IActivePool(activePoolAddress).receiveColl(_amount);\n    }\n\n    function receiveColl(uint256 _amount) external {\n        _requireCallerIsActivePool();\n\n        uint256 newCollBalance = collBalance + _amount;\n        collBalance = newCollBalance;\n\n        // Pull Coll tokens from ActivePool\n        collToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit DefaultPoolCollBalanceUpdated(newCollBalance);\n    }\n\n    function increaseBoldDebt(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n        BoldDebt = BoldDebt + _amount;\n        emit DefaultPoolBoldDebtUpdated(BoldDebt);\n    }\n\n    function decreaseBoldDebt(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n        BoldDebt = BoldDebt - _amount;\n        emit DefaultPoolBoldDebtUpdated(BoldDebt);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require(msg.sender == activePoolAddress, \"DefaultPool: Caller is not the ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, \"DefaultPool: Caller is not the TroveManager\");\n    }\n}\n"
    },
    "src/liquity/GasPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IAddressesRegistry.sol\";\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/ITroveManager.sol\";\n\n/**\n * The purpose of this contract is to hold WETH tokens for gas compensation:\n * https://github.com/liquity/bold/?tab=readme-ov-file#liquidation-gas-compensation\n * When a borrower opens a trove, an additional amount of WETH is pulled,\n * and sent to this contract.\n * When a borrower closes their active trove, this gas compensation is refunded\n * When a trove is liquidated, this gas compensation is paid to liquidator\n */\ncontract GasPool {\n    constructor(IAddressesRegistry _addressesRegistry) {\n        IWETH WETH = _addressesRegistry.WETH();\n        IBorrowerOperations borrowerOperations = _addressesRegistry.borrowerOperations();\n        ITroveManager troveManager = _addressesRegistry.troveManager();\n\n        // Allow BorrowerOperations to refund gas compensation\n        WETH.approve(address(borrowerOperations), type(uint256).max);\n        // Allow TroveManager to pay gas compensation to liquidator\n        WETH.approve(address(troveManager), type(uint256).max);\n    }\n}\n"
    },
    "src/liquity/HintHelpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ICollateralRegistry.sol\";\nimport \"../dependencies/LiquityMath.sol\";\nimport \"../dependencies/Constants.sol\";\nimport \"../interfaces/IHintHelpers.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract HintHelpers is IHintHelpers {\n    string public constant NAME = \"HintHelpers\";\n\n    ICollateralRegistry public immutable collateralRegistry;\n\n    constructor(ICollateralRegistry _collateralRegistry) {\n        collateralRegistry = _collateralRegistry;\n    }\n\n    /* getApproxHint() - return id of a Trove that is, on average, (length / numTrials) positions away in the\n    sortedTroves list from the correct insert position of the Trove to be inserted. \n    \n    Note: The output id is worst-case O(n) positions away from the correct insert position, however, the function\n    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:\n\n    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput id will\n    be <= sqrt(length) positions away from the correct insert position.\n    */\n    function getApproxHint(uint256 _collIndex, uint256 _interestRate, uint256 _numTrials, uint256 _inputRandomSeed)\n        external\n        view\n        returns (uint256 hintId, uint256 diff, uint256 latestRandomSeed)\n    {\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        ISortedTroves sortedTroves = troveManager.sortedTroves();\n\n        uint256 arrayLength = troveManager.getTroveIdsCount();\n\n        if (arrayLength == 0) {\n            return (0, 0, _inputRandomSeed);\n        }\n\n        hintId = sortedTroves.getLast();\n        diff = LiquityMath._getAbsoluteDifference(_interestRate, troveManager.getTroveAnnualInterestRate(hintId));\n        latestRandomSeed = _inputRandomSeed;\n\n        for (uint256 i = 1; i < _numTrials; ++i) {\n            latestRandomSeed = uint256(keccak256(abi.encodePacked(latestRandomSeed)));\n\n            uint256 arrayIndex = latestRandomSeed % arrayLength;\n            uint256 currentId = troveManager.getTroveFromTroveIdsArray(arrayIndex);\n\n            // Skip this Trove if it's unredeeamable and not in the sorted list\n            if (!sortedTroves.contains(currentId)) continue;\n\n            uint256 currentInterestRate = troveManager.getTroveAnnualInterestRate(currentId);\n\n            // check if abs(current - IR) > abs(closest - IR), and update closest if current is closer\n            uint256 currentDiff = LiquityMath._getAbsoluteDifference(currentInterestRate, _interestRate);\n\n            if (currentDiff < diff) {\n                diff = currentDiff;\n                hintId = currentId;\n            }\n        }\n    }\n\n    function _calcUpfrontFee(uint256 _debt, uint256 _avgInterestRate) internal pure returns (uint256) {\n        return _debt * _avgInterestRate * UPFRONT_INTEREST_PERIOD / ONE_YEAR / DECIMAL_PRECISION;\n    }\n\n    function predictOpenTroveUpfrontFee(uint256 _collIndex, uint256 _borrowedAmount, uint256 _interestRate)\n        external\n        view\n        returns (uint256)\n    {\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        IActivePool activePool = troveManager.activePool();\n\n        TroveChange memory openTrove;\n        openTrove.debtIncrease = _borrowedAmount;\n        openTrove.newWeightedRecordedDebt = openTrove.debtIncrease * _interestRate;\n\n        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(openTrove);\n        return _calcUpfrontFee(openTrove.debtIncrease, avgInterestRate);\n    }\n\n    function predictAdjustInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)\n        external\n        view\n        returns (uint256)\n    {\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        IActivePool activePool = troveManager.activePool();\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);\n\n        if (block.timestamp >= trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN) {\n            return 0;\n        }\n\n        return _predictAdjustInterestRateUpfrontFee(activePool, trove, _newInterestRate);\n    }\n\n    function forcePredictAdjustInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)\n        external\n        view\n        returns (uint256)\n    {\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        IActivePool activePool = troveManager.activePool();\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);\n\n        return _predictAdjustInterestRateUpfrontFee(activePool, trove, _newInterestRate);\n    }\n\n    function _predictAdjustInterestRateUpfrontFee(\n        IActivePool _activePool,\n        LatestTroveData memory _trove,\n        uint256 _newInterestRate\n    ) internal view returns (uint256) {\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = _trove.redistBoldDebtGain;\n        troveChange.newWeightedRecordedDebt = _trove.entireDebt * _newInterestRate;\n        troveChange.oldWeightedRecordedDebt = _trove.weightedRecordedDebt;\n\n        uint256 avgInterestRate = _activePool.getNewApproxAvgInterestRateFromTroveChange(troveChange);\n        return _calcUpfrontFee(_trove.entireDebt, avgInterestRate);\n    }\n\n    function predictAdjustTroveUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _debtIncrease)\n        external\n        view\n        returns (uint256)\n    {\n        if (_debtIncrease == 0) return 0;\n\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        IActivePool activePool = troveManager.activePool();\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);\n        (,,,,,,,, address batchManager,) = troveManager.Troves(_troveId);\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.debtIncrease = _debtIncrease;\n\n        if (batchManager == address(0)) {\n            troveChange.newWeightedRecordedDebt = (trove.entireDebt + _debtIncrease) * trove.annualInterestRate;\n            troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n        } else {\n            LatestBatchData memory batch = troveManager.getLatestBatchData(batchManager);\n            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            troveChange.newWeightedRecordedDebt = (\n                batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain + _debtIncrease\n            ) * batch.annualInterestRate;\n            troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        }\n\n        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(troveChange);\n        return _calcUpfrontFee(_debtIncrease, avgInterestRate);\n    }\n\n    function predictAdjustBatchInterestRateUpfrontFee(\n        uint256 _collIndex,\n        address _batchAddress,\n        uint256 _newInterestRate\n    ) external view returns (uint256) {\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        IActivePool activePool = troveManager.activePool();\n        LatestBatchData memory batch = troveManager.getLatestBatchData(_batchAddress);\n\n        if (block.timestamp >= batch.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN) {\n            return 0;\n        }\n\n        TroveChange memory troveChange;\n        troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        troveChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * _newInterestRate;\n        troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n\n        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(troveChange);\n        return _calcUpfrontFee(batch.entireDebtWithoutRedistribution, avgInterestRate);\n    }\n\n    function predictOpenTroveAndJoinBatchUpfrontFee(uint256 _collIndex, uint256 _borrowedAmount, address _batchAddress)\n        external\n        view\n        returns (uint256)\n    {\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        IActivePool activePool = troveManager.activePool();\n        LatestBatchData memory batch = troveManager.getLatestBatchData(_batchAddress);\n\n        TroveChange memory openTrove;\n        openTrove.debtIncrease = _borrowedAmount;\n        openTrove.batchAccruedManagementFee = batch.accruedManagementFee;\n        openTrove.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        openTrove.newWeightedRecordedDebt =\n            (batch.entireDebtWithoutRedistribution + _borrowedAmount) * batch.annualInterestRate;\n\n        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(openTrove);\n        return _calcUpfrontFee(_borrowedAmount, avgInterestRate);\n    }\n\n    function predictJoinBatchInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, address _batchAddress)\n        external\n        view\n        returns (uint256)\n    {\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        IActivePool activePool = troveManager.activePool();\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);\n        LatestBatchData memory batch = troveManager.getLatestBatchData(_batchAddress);\n\n        if (block.timestamp >= trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN) {\n            return 0;\n        }\n\n        return _predictJoinBatchInterestRateUpfrontFee(activePool, trove, batch);\n    }\n\n    function forcePredictJoinBatchInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, address _batchAddress)\n        external\n        view\n        returns (uint256)\n    {\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        IActivePool activePool = troveManager.activePool();\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);\n        LatestBatchData memory batch = troveManager.getLatestBatchData(_batchAddress);\n\n        return _predictJoinBatchInterestRateUpfrontFee(activePool, trove, batch);\n    }\n\n    function _predictJoinBatchInterestRateUpfrontFee(\n        IActivePool _activePool,\n        LatestTroveData memory _trove,\n        LatestBatchData memory _batch\n    ) internal view returns (uint256) {\n        TroveChange memory newBatchTroveChange;\n        newBatchTroveChange.appliedRedistBoldDebtGain = _trove.redistBoldDebtGain;\n        newBatchTroveChange.batchAccruedManagementFee = _batch.accruedManagementFee;\n        newBatchTroveChange.oldWeightedRecordedDebt = _batch.weightedRecordedDebt + _trove.weightedRecordedDebt;\n        newBatchTroveChange.newWeightedRecordedDebt =\n            (_batch.entireDebtWithoutRedistribution + _trove.entireDebt) * _batch.annualInterestRate;\n\n        uint256 avgInterestRate = _activePool.getNewApproxAvgInterestRateFromTroveChange(newBatchTroveChange);\n        return _calcUpfrontFee(_trove.entireDebt, avgInterestRate);\n    }\n\n    function predictRemoveFromBatchUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)\n        external\n        view\n        returns (uint256)\n    {\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        IActivePool activePool = troveManager.activePool();\n        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);\n        (,,,,,,,, address batchManager,) = troveManager.Troves(_troveId);\n        LatestBatchData memory batch = troveManager.getLatestBatchData(batchManager);\n\n        if (\n            _newInterestRate == batch.annualInterestRate\n                || block.timestamp >= trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN\n        ) {\n            return 0;\n        }\n\n        TroveChange memory troveChange;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        troveChange.newWeightedRecordedDebt = (\n            batch.entireDebtWithoutRedistribution - (trove.entireDebt - trove.redistBoldDebtGain)\n        ) * batch.annualInterestRate + trove.entireDebt * _newInterestRate;\n\n        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(troveChange);\n        return _calcUpfrontFee(trove.entireDebt, avgInterestRate);\n    }\n}\n"
    },
    "src/liquity/MockInterestRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IInterestRouter.sol\";\n\ncontract MockInterestRouter is IInterestRouter {}\n"
    },
    "src/liquity/MultiTroveGetter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ICollateralRegistry.sol\";\nimport \"../interfaces/IMultiTroveGetter.sol\";\nimport \"../types/BatchId.sol\";\n\n/*  Helper contract for grabbing Trove data for the front end. Not part of the core Liquity system. */\ncontract MultiTroveGetter is IMultiTroveGetter {\n    ICollateralRegistry public immutable collateralRegistry;\n\n    constructor(ICollateralRegistry _collateralRegistry) {\n        collateralRegistry = _collateralRegistry;\n    }\n\n    function getMultipleSortedTroves(uint256 _collIndex, int256 _startIdx, uint256 _count)\n        external\n        view\n        returns (CombinedTroveData[] memory _troves)\n    {\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        require(address(troveManager) != address(0), \"Invalid collateral index\");\n\n        ISortedTroves sortedTroves = troveManager.sortedTroves();\n        assert(address(sortedTroves) != address(0));\n\n        uint256 startIdx;\n        bool descend;\n\n        if (_startIdx >= 0) {\n            startIdx = uint256(_startIdx);\n            descend = true;\n        } else {\n            startIdx = uint256(-(_startIdx + 1));\n            descend = false;\n        }\n\n        uint256 sortedTrovesSize = sortedTroves.getSize();\n\n        if (startIdx >= sortedTrovesSize) {\n            _troves = new CombinedTroveData[](0);\n        } else {\n            uint256 maxCount = sortedTrovesSize - startIdx;\n\n            if (_count > maxCount) {\n                _count = maxCount;\n            }\n\n            if (descend) {\n                _troves = _getMultipleSortedTrovesFromHead(troveManager, sortedTroves, startIdx, _count);\n            } else {\n                _troves = _getMultipleSortedTrovesFromTail(troveManager, sortedTroves, startIdx, _count);\n            }\n        }\n    }\n\n    function _getOneTrove(ITroveManager _troveManager, uint256 _id, CombinedTroveData memory _out) internal view {\n        _out.id = _id;\n\n        (\n            _out.debt,\n            _out.coll,\n            _out.stake,\n            , // status\n            , // arrayIndex\n            _out.annualInterestRate,\n            _out.lastDebtUpdateTime,\n            _out.lastInterestRateAdjTime,\n            _out.interestBatchManager,\n            //_out.batchDebtShares,\n        ) = _troveManager.Troves(_id);\n\n        (_out.snapshotETH, _out.snapshotBoldDebt) = _troveManager.rewardSnapshots(_id);\n    }\n\n    function _getMultipleSortedTrovesFromHead(\n        ITroveManager _troveManager,\n        ISortedTroves _sortedTroves,\n        uint256 _startIdx,\n        uint256 _count\n    ) internal view returns (CombinedTroveData[] memory _troves) {\n        uint256 currentTroveId = _sortedTroves.getFirst();\n\n        for (uint256 idx = 0; idx < _startIdx; ++idx) {\n            currentTroveId = _sortedTroves.getNext(currentTroveId);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint256 idx = 0; idx < _count; ++idx) {\n            _getOneTrove(_troveManager, currentTroveId, _troves[idx]);\n            currentTroveId = _sortedTroves.getNext(currentTroveId);\n        }\n    }\n\n    function _getMultipleSortedTrovesFromTail(\n        ITroveManager _troveManager,\n        ISortedTroves _sortedTroves,\n        uint256 _startIdx,\n        uint256 _count\n    ) internal view returns (CombinedTroveData[] memory _troves) {\n        uint256 currentTroveId = _sortedTroves.getLast();\n\n        for (uint256 idx = 0; idx < _startIdx; ++idx) {\n            currentTroveId = _sortedTroves.getPrev(currentTroveId);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint256 idx = 0; idx < _count; ++idx) {\n            _getOneTrove(_troveManager, currentTroveId, _troves[idx]);\n            currentTroveId = _sortedTroves.getPrev(currentTroveId);\n        }\n    }\n\n    function getDebtPerInterestRateAscending(uint256 _collIndex, uint256 _startId, uint256 _maxIterations)\n        external\n        view\n        returns (DebtPerInterestRate[] memory data, uint256 currId)\n    {\n        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);\n        require(address(troveManager) != address(0), \"Invalid collateral index\");\n\n        ISortedTroves sortedTroves = troveManager.sortedTroves();\n        assert(address(sortedTroves) != address(0));\n\n        data = new DebtPerInterestRate[](_maxIterations);\n        currId = sortedTroves.getPrev(_startId);\n\n        for (uint256 i = 0; i < _maxIterations; ++i) {\n            if (currId == 0) break;\n\n            (, uint256 prevId, BatchId interestBatchManager,) = sortedTroves.nodes(currId);\n            LatestTroveData memory trove = troveManager.getLatestTroveData(currId);\n            data[i].interestBatchManager = BatchId.unwrap(interestBatchManager);\n            data[i].interestRate = trove.annualInterestRate;\n            data[i].debt = trove.entireDebt;\n\n            currId = prevId;\n        }\n    }\n}\n"
    },
    "src/liquity/SortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/IAddressesRegistry.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IBorrowerOperations.sol\";\n\n// ID of head & tail of the list. Callers should stop iterating with `getNext()` / `getPrev()`\n// when encountering this node ID.\nuint256 constant ROOT_NODE_ID = 0;\n\n/*\n* A sorted doubly linked list with nodes sorted in descending order.\n*\n* Nodes map to active Troves in the system - the ID property is the address of a Trove owner.\n* Nodes are ordered according to the borrower's chosen annual interest rate.\n*\n* The list optionally accepts insert position hints.\n*\n* The annual interest rate is stored on the Trove struct in TroveManager, not directly on the Node.\n*\n* A node need only be re-inserted when the borrower adjusts their interest rate. Interest rate order is preserved\n* under all other system operations.\n*\n* The list is a modification of the following audited SortedDoublyLinkedList:\n* https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\n*\n* Changes made in the Bold implementation:\n*\n* - Keys have been removed from nodes\n*\n* - Ordering checks for insertion are performed by comparing an interest rate argument to the Trove's current interest rate.\n*\n* - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\n*/\ncontract SortedTroves is ISortedTroves {\n    string public constant NAME = \"SortedTroves\";\n\n    // Constants used for documentation purposes\n    uint256 constant UNINITIALIZED_ID = 0;\n    uint256 constant BAD_HINT = 0;\n\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n\n    address public immutable borrowerOperationsAddress;\n    ITroveManager public immutable troveManager;\n\n    // Information for a node in the list\n    struct Node {\n        uint256 nextId; // Id of next node (smaller interest rate) in the list\n        uint256 prevId; // Id of previous node (larger interest rate) in the list\n        BatchId batchId; // Id of this node's batch manager, or zero in case of non-batched nodes\n        bool exists;\n    }\n\n    struct Batch {\n        uint256 head;\n        uint256 tail;\n    }\n\n    struct Position {\n        uint256 prevId;\n        uint256 nextId;\n    }\n\n    // Current size of the list\n    uint256 public size;\n\n    // Stores the forward and reverse links of each node in the list.\n    // nodes[ROOT_NODE_ID] holds the head and tail of the list. This avoids the need for special\n    // handling when inserting into or removing from a terminal position (head or tail), inserting\n    // into an empty list or removing the element of a singleton list.\n    mapping(uint256 => Node) public nodes;\n\n    // Lookup batches by the address of their manager\n    mapping(BatchId => Batch) public batches;\n\n    constructor(IAddressesRegistry _addressesRegistry) {\n        // Technically, this is not needed as long as ROOT_NODE_ID is 0, but it doesn't hurt\n        nodes[ROOT_NODE_ID].nextId = ROOT_NODE_ID;\n        nodes[ROOT_NODE_ID].prevId = ROOT_NODE_ID;\n\n        troveManager = ITroveManager(_addressesRegistry.troveManager());\n        borrowerOperationsAddress = address(_addressesRegistry.borrowerOperations());\n\n        emit TroveManagerAddressChanged(address(troveManager));\n        emit BorrowerOperationsAddressChanged(borrowerOperationsAddress);\n    }\n\n    // Insert an entire list slice (such as a batch of Troves sharing the same interest rate)\n    // between adjacent nodes `_prevId` and `_nextId`.\n    // Can be used to insert a single node by passing its ID as both `_sliceHead` and `_sliceTail`.\n    function _insertSliceIntoVerifiedPosition(uint256 _sliceHead, uint256 _sliceTail, uint256 _prevId, uint256 _nextId)\n        internal\n    {\n        nodes[_prevId].nextId = _sliceHead;\n        nodes[_sliceHead].prevId = _prevId;\n        nodes[_sliceTail].nextId = _nextId;\n        nodes[_nextId].prevId = _sliceTail;\n    }\n\n    function _insertSlice(\n        ITroveManager _troveManager,\n        uint256 _sliceHead,\n        uint256 _sliceTail,\n        uint256 _annualInterestRate,\n        uint256 _prevId,\n        uint256 _nextId\n    ) internal {\n        if (!_validInsertPosition(_troveManager, _annualInterestRate, _prevId, _nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (_prevId, _nextId) = _findInsertPosition(_troveManager, _annualInterestRate, _prevId, _nextId);\n        }\n\n        _insertSliceIntoVerifiedPosition(_sliceHead, _sliceTail, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Add a Trove to the list\n     * @param _id Trove's id\n     * @param _annualInterestRate Trove's annual interest rate\n     * @param _prevId Id of previous Trove for the insert position\n     * @param _nextId Id of next Trove for the insert position\n     */\n    function insert(uint256 _id, uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId) external override {\n        _requireCallerIsBorrowerOperations();\n        require(!contains(_id), \"SortedTroves: List already contains the node\");\n        require(_id != ROOT_NODE_ID, \"SortedTroves: _id cannot be the root node's ID\");\n\n        _insertSlice(troveManager, _id, _id, _annualInterestRate, _prevId, _nextId);\n        nodes[_id].exists = true;\n        ++size;\n    }\n\n    // Remove the entire slice between `_sliceHead` and `_sliceTail` from the list while keeping\n    // the removed nodes connected to each other, such that they can be reinserted into a different\n    // position with `_insertSlice()`.\n    // Can be used to remove a single node by passing its ID as both `_sliceHead` and `_sliceTail`.\n    function _removeSlice(uint256 _sliceHead, uint256 _sliceTail) internal {\n        nodes[nodes[_sliceHead].prevId].nextId = nodes[_sliceTail].nextId;\n        nodes[nodes[_sliceTail].nextId].prevId = nodes[_sliceHead].prevId;\n    }\n\n    /*\n     * @dev Remove a non-batched Trove from the list\n     * @param _id Trove's id\n     */\n    function remove(uint256 _id) external override {\n        _requireCallerIsBOorTM();\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n        require(!isBatchedNode(_id), \"SortedTroves: Must use removeFromBatch() to remove batched node\");\n\n        _removeSlice(_id, _id);\n        delete nodes[_id];\n        --size;\n    }\n\n    function _reInsertSlice(\n        ITroveManager _troveManager,\n        uint256 _sliceHead,\n        uint256 _sliceTail,\n        uint256 _annualInterestRate,\n        uint256 _prevId,\n        uint256 _nextId\n    ) internal {\n        if (!_validInsertPosition(_troveManager, _annualInterestRate, _prevId, _nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (_prevId, _nextId) = _findInsertPosition(_troveManager, _annualInterestRate, _prevId, _nextId);\n        }\n\n        // Check that the new insert position isn't the same as the existing one\n        if (_nextId != _sliceHead && _prevId != _sliceTail) {\n            _removeSlice(_sliceHead, _sliceTail);\n            _insertSliceIntoVerifiedPosition(_sliceHead, _sliceTail, _prevId, _nextId);\n        }\n    }\n\n    /*\n     * @dev Re-insert a non-batched Trove at a new position, based on its new annual interest rate\n     * @param _id Trove's id\n     * @param _newAnnualInterestRate Trove's new annual interest rate\n     * @param _prevId Id of previous Trove for the new insert position\n     * @param _nextId Id of next Trove for the new insert position\n     */\n    function reInsert(uint256 _id, uint256 _newAnnualInterestRate, uint256 _prevId, uint256 _nextId)\n        external\n        override\n    {\n        _requireCallerIsBorrowerOperations();\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n        require(!isBatchedNode(_id), \"SortedTroves: Must not reInsert() batched node\");\n\n        _reInsertSlice(troveManager, _id, _id, _newAnnualInterestRate, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Add a Trove to a Batch within the list\n     * @param _troveId Trove's id\n     * @param _batchId Batch's id\n     * @param _annualInterestRate Batch's annual interest rate\n     * @param _prevId Id of previous Trove for the insert position, in case the Batch is empty\n     * @param _nextId Id of next Trove for the insert position, in case the Batch is empty\n     */\n    function insertIntoBatch(\n        uint256 _troveId,\n        BatchId _batchId,\n        uint256 _annualInterestRate,\n        uint256 _prevId,\n        uint256 _nextId\n    ) external override {\n        _requireCallerIsBorrowerOperations();\n        require(!contains(_troveId), \"SortedTroves: List already contains the node\");\n        require(_troveId != ROOT_NODE_ID, \"SortedTroves: _troveId cannot be the root node's ID\");\n        require(_batchId.isNotZero(), \"SortedTroves: _batchId cannot be zero\");\n\n        uint256 batchTail = batches[_batchId].tail;\n\n        if (batchTail == UNINITIALIZED_ID) {\n            _insertSlice(troveManager, _troveId, _troveId, _annualInterestRate, _prevId, _nextId);\n            // Initialize the batch by setting both its head & tail to its singular node\n            batches[_batchId].head = _troveId;\n            // (Tail will be set outside the \"if\")\n        } else {\n            _insertSliceIntoVerifiedPosition(_troveId, _troveId, batchTail, nodes[batchTail].nextId);\n        }\n\n        batches[_batchId].tail = _troveId;\n        nodes[_troveId].batchId = _batchId;\n        nodes[_troveId].exists = true;\n        ++size;\n    }\n\n    /*\n     * @dev Remove a batched Trove from the list\n     * @param _id Trove's id\n     */\n    function removeFromBatch(uint256 _id) external override {\n        _requireCallerIsBOorTM();\n        BatchId batchId = nodes[_id].batchId;\n        // batchId.isNotZero() implies that the list contains the node\n        require(batchId.isNotZero(), \"SortedTroves: Must use remove() to remove non-batched node\");\n\n        Batch memory batch = batches[batchId];\n\n        if (batch.head == _id && batch.tail == _id) {\n            // Remove singleton batch\n            delete batches[batchId];\n        } else if (batch.head == _id) {\n            batches[batchId].head = nodes[_id].nextId;\n        } else if (batch.tail == _id) {\n            batches[batchId].tail = nodes[_id].prevId;\n        }\n\n        _removeSlice(_id, _id);\n        delete nodes[_id];\n        --size;\n    }\n\n    /*\n     * @dev Re-insert an entire Batch of Troves at a new position, based on their new annual interest rate\n     * @param _id Batch's id\n     * @param _newAnnualInterestRate Trove's new annual interest rate\n     * @param _prevId Id of previous Trove for the new insert position\n     * @param _nextId Id of next Trove for the new insert position\n     */\n    function reInsertBatch(BatchId _id, uint256 _newAnnualInterestRate, uint256 _prevId, uint256 _nextId)\n        external\n        override\n    {\n        Batch memory batch = batches[_id];\n\n        _requireCallerIsBorrowerOperations();\n        require(batch.head != UNINITIALIZED_ID, \"SortedTroves: List does not contain the batch\");\n\n        _reInsertSlice(troveManager, batch.head, batch.tail, _newAnnualInterestRate, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Checks if the list contains a node\n     */\n    function contains(uint256 _id) public view override returns (bool) {\n        return nodes[_id].exists;\n    }\n\n    /*\n     * @dev Checks whether the node is part of a batch\n     */\n    function isBatchedNode(uint256 _id) public view override returns (bool) {\n        return nodes[_id].batchId.isNotZero();\n    }\n\n    function isEmptyBatch(BatchId _id) external view override returns (bool) {\n        return batches[_id].head == UNINITIALIZED_ID;\n    }\n\n    /*\n     * @dev Checks if the list is empty\n     */\n    function isEmpty() external view override returns (bool) {\n        return size == 0;\n    }\n\n    /*\n     * @dev Returns the current size of the list\n     */\n    function getSize() external view override returns (uint256) {\n        return size;\n    }\n\n    /*\n     * @dev Returns the first node in the list (node with the largest annual interest rate)\n     */\n    function getFirst() external view override returns (uint256) {\n        return nodes[ROOT_NODE_ID].nextId;\n    }\n\n    /*\n     * @dev Returns the last node in the list (node with the smallest annual interest rate)\n     */\n    function getLast() external view override returns (uint256) {\n        return nodes[ROOT_NODE_ID].prevId;\n    }\n\n    /*\n     * @dev Returns the next node (with a smaller interest rate) in the list for a given node\n     * @param _id Node's id\n     */\n    function getNext(uint256 _id) external view override returns (uint256) {\n        return nodes[_id].nextId;\n    }\n\n    /*\n     * @dev Returns the previous node (with a larger interest rate) in the list for a given node\n     * @param _id Node's id\n     */\n    function getPrev(uint256 _id) external view override returns (uint256) {\n        return nodes[_id].prevId;\n    }\n\n    /*\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given interest rate\n     * @param _annualInterestRate Node's annual interest rate\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function validInsertPosition(uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _validInsertPosition(troveManager, _annualInterestRate, _prevId, _nextId);\n    }\n\n    function _validInsertPosition(\n        ITroveManager _troveManager,\n        uint256 _annualInterestRate,\n        uint256 _prevId,\n        uint256 _nextId\n    ) internal view returns (bool) {\n        BatchId prevBatchId = nodes[_prevId].batchId;\n\n        // `(_prevId, _nextId)` is a valid insert position if:\n        return\n        // they are adjacent nodes\n        (\n            nodes[_prevId].nextId == _nextId && nodes[_nextId].prevId == _prevId\n            // they aren't part of the same batch\n            && (prevBatchId.notEquals(nodes[_nextId].batchId) || prevBatchId.isZero())\n            // `_annualInterestRate` falls between the two nodes' interest rates\n            && (_prevId == ROOT_NODE_ID || _troveManager.getTroveAnnualInterestRate(_prevId) >= _annualInterestRate)\n                && (_nextId == ROOT_NODE_ID || _annualInterestRate > _troveManager.getTroveAnnualInterestRate(_nextId))\n        );\n    }\n\n    function _skipToBatchTail(uint256 _id) internal view returns (uint256) {\n        BatchId batchId = nodes[_id].batchId;\n        return batchId.isNotZero() ? batches[batchId].tail : _id;\n    }\n\n    function _skipToBatchHead(uint256 _id) internal view returns (uint256) {\n        BatchId batchId = nodes[_id].batchId;\n        return batchId.isNotZero() ? batches[batchId].head : _id;\n    }\n\n    function _descendOne(ITroveManager _troveManager, uint256 _annualInterestRate, Position memory _pos)\n        internal\n        view\n        returns (bool found)\n    {\n        if (_pos.nextId == ROOT_NODE_ID || _annualInterestRate > _troveManager.getTroveAnnualInterestRate(_pos.nextId))\n        {\n            found = true;\n        } else {\n            _pos.prevId = _skipToBatchTail(_pos.nextId);\n            _pos.nextId = nodes[_pos.prevId].nextId;\n        }\n    }\n\n    function _ascendOne(ITroveManager _troveManager, uint256 _annualInterestRate, Position memory _pos)\n        internal\n        view\n        returns (bool found)\n    {\n        if (_pos.prevId == ROOT_NODE_ID || _troveManager.getTroveAnnualInterestRate(_pos.prevId) >= _annualInterestRate)\n        {\n            found = true;\n        } else {\n            _pos.nextId = _skipToBatchHead(_pos.prevId);\n            _pos.prevId = nodes[_pos.nextId].prevId;\n        }\n    }\n\n    /*\n     * @dev Descend the list (larger interest rates to smaller interest rates) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n     * @param _annualInterestRate Node's annual interest rate\n     * @param _startId Id of node to start descending the list from\n     */\n    function _descendList(ITroveManager _troveManager, uint256 _annualInterestRate, uint256 _startId)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        Position memory pos = Position(_startId, nodes[_startId].nextId);\n\n        while (!_descendOne(_troveManager, _annualInterestRate, pos)) {}\n        return (pos.prevId, pos.nextId);\n    }\n\n    /*\n     * @dev Ascend the list (smaller interest rates to larger interest rates) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n     * @param _annualInterestRate Node's annual interest rate\n     * @param _startId Id of node to start ascending the list from\n     */\n    function _ascendList(ITroveManager _troveManager, uint256 _annualInterestRate, uint256 _startId)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        Position memory pos = Position(nodes[_startId].prevId, _startId);\n\n        while (!_ascendOne(_troveManager, _annualInterestRate, pos)) {}\n        return (pos.prevId, pos.nextId);\n    }\n\n    function _descendAndAscendList(\n        ITroveManager _troveManager,\n        uint256 _annualInterestRate,\n        uint256 _descentStartId,\n        uint256 _ascentStartId\n    ) internal view returns (uint256 prevId, uint256 nextId) {\n        Position memory descentPos = Position(_descentStartId, nodes[_descentStartId].nextId);\n        Position memory ascentPos = Position(nodes[_ascentStartId].prevId, _ascentStartId);\n\n        for (;;) {\n            if (_descendOne(_troveManager, _annualInterestRate, descentPos)) {\n                return (descentPos.prevId, descentPos.nextId);\n            }\n\n            if (_ascendOne(_troveManager, _annualInterestRate, ascentPos)) {\n                return (ascentPos.prevId, ascentPos.nextId);\n            }\n        }\n\n        assert(false); // Should not reach\n    }\n\n    /*\n     * @dev Find the insert position for a new node with the given interest rate\n     * @param _annualInterestRate Node's annual interest rate\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function findInsertPosition(uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n        return _findInsertPosition(troveManager, _annualInterestRate, _prevId, _nextId);\n    }\n\n    // This function is optimized under the assumption that only one of the original neighbours has been (re)moved.\n    // In other words, we assume that the correct position can be found close to one of the two.\n    // Nevertheless, the function will always find the correct position, regardless of hints or interference.\n    function _findInsertPosition(\n        ITroveManager _troveManager,\n        uint256 _annualInterestRate,\n        uint256 _prevId,\n        uint256 _nextId\n    ) internal view returns (uint256, uint256) {\n        if (_prevId == ROOT_NODE_ID) {\n            // The original correct position was found before the head of the list.\n            // Assuming minimal interference, the new correct position is still close to the head.\n            return _descendList(_troveManager, _annualInterestRate, ROOT_NODE_ID);\n        } else {\n            if (!contains(_prevId) || _troveManager.getTroveAnnualInterestRate(_prevId) < _annualInterestRate) {\n                // `prevId` does not exist anymore or now has a smaller interest rate than the given interest rate\n                _prevId = BAD_HINT;\n            }\n        }\n\n        if (_nextId == ROOT_NODE_ID) {\n            // The original correct position was found after the tail of the list.\n            // Assuming minimal interference, the new correct position is still close to the tail.\n            return _ascendList(_troveManager, _annualInterestRate, ROOT_NODE_ID);\n        } else {\n            if (!contains(_nextId) || _annualInterestRate <= _troveManager.getTroveAnnualInterestRate(_nextId)) {\n                // `nextId` does not exist anymore or now has a larger interest rate than the given interest rate\n                _nextId = BAD_HINT;\n            }\n        }\n\n        if (_prevId == BAD_HINT && _nextId == BAD_HINT) {\n            // Both original neighbours have been moved or removed.\n            // We default to descending the list, starting from the head.\n            //\n            // TODO: should we revert instead, so as not to waste the user's gas?\n            //       We are unlikely to recover.\n            return _descendList(_troveManager, _annualInterestRate, ROOT_NODE_ID);\n        } else if (_prevId == BAD_HINT) {\n            // No `prevId` for hint - ascend list starting from `nextId`\n            return _ascendList(_troveManager, _annualInterestRate, _skipToBatchHead(_nextId));\n        } else if (_nextId == BAD_HINT) {\n            // No `nextId` for hint - descend list starting from `prevId`\n            return _descendList(_troveManager, _annualInterestRate, _skipToBatchTail(_prevId));\n        } else {\n            // The correct position is still somewhere between the 2 hints, so it's not obvious\n            // which of the 2 has been moved (assuming only one of them has been).\n            // We simultaneously descend & ascend in the hope that one of them is very close.\n            return _descendAndAscendList(\n                _troveManager, _annualInterestRate, _skipToBatchTail(_prevId), _skipToBatchHead(_nextId)\n            );\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBOorTM() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress || msg.sender == address(troveManager),\n            \"SortedTroves: Caller is not BorrowerOperations nor TroveManager\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"SortedTroves: Caller is not BorrowerOperations\");\n    }\n}\n"
    },
    "src/liquity/StabilityPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IStabilityPool.sol\";\nimport \"../interfaces/IAddressesRegistry.sol\";\nimport \"../interfaces/IStabilityPoolEvents.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IBoldToken.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../dependencies/LiquityBase.sol\";\n\n// import \"forge-std/console2.sol\";\n\n/*\n * The Stability Pool holds Bold tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its Bold debt gets offset with\n * Bold in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of Bold tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a Bold loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Coll gain, as the collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total Bold in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and Coll gains that has O(1) complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and Coll gain, we simply update two state variables:\n * a product P, and a sum S.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\n * and accumulated Coll gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated Coll gain is derived here:\n * https://github.com/liquity/dev/blob/main/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Coll gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Coll gain\n * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Coll gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n *\n * --- EPOCHS ---\n *\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n *\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n *\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n *\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n *\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion Bold has depleted to < 1 Bold).\n *\n *\n *  --- TRACKING DEPOSITOR'S Coll GAIN OVER SCALE CHANGES AND EPOCHS ---\n *\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\n *\n * This allows us to calculate a deposit's accumulated Coll gain, during the epoch in which the deposit was non-zero and earned Coll.\n *\n * We calculate the depositor's accumulated Coll gain for the scale at which they made the deposit, using the Coll gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated Coll gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n *\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Coll gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n *\n */\ncontract StabilityPool is LiquityBase, IStabilityPool, IStabilityPoolEvents {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"StabilityPool\";\n\n    IERC20 public immutable collToken;\n    ITroveManager public immutable troveManager;\n    IBoldToken public immutable boldToken;\n\n    uint256 internal collBalance; // deposited ether tracker\n\n    // Tracker for Bold held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalBoldDeposits;\n\n    // Total remaining Bold yield gains (from Trove interest mints) held by SP, and not yet paid out to depositors\n    // TODO: from the contract's perspective, this is a write-only variable. It is only ever read in tests, so it would\n    // be better to keep it outside the core contract.\n    uint256 internal yieldGainsOwed;\n    // Total remaining Bold yield gains (from Trove interest mints) held by SP, not yet paid out to depositors,\n    // and not accounted for because they were received when the total deposits were too small\n    uint256 internal yieldGainsPending;\n\n    // --- Data structures ---\n\n    struct Deposit {\n        uint256 initialValue;\n    }\n\n    struct Snapshots {\n        uint256 S; // Coll reward sum liqs\n        uint256 P;\n        uint256 B; // Bold reward sum from minted interest\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct\n    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\n    mapping(address => uint256) public stashedColl;\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n    * after a series of liquidations have occurred, each of which cancel some Bold debt with the deposit.\n    *\n    * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n    * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n    */\n    uint256 public P = DECIMAL_PRECISION;\n\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    /* Coll Gain sum 'S': During its lifetime, each deposit d_t earns an Coll gain of ( d_t * [S - S_t] )/P_t, where S_t\n    * is the depositor's snapshot of S taken at the time t when the deposit was made.\n    *\n    * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n    *\n    * - The inner mapping records the sum S at different scales\n    * - The outer mapping records the (scale => sum) mappings, for different epochs.\n    */\n    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToS;\n    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToB;\n\n    // Error trackers for the error correction in the offset calculation\n    uint256 public lastCollError_Offset;\n    uint256 public lastBoldLossError_Offset;\n\n    // Error tracker fror the error correction in the BOLD reward calculation\n    uint256 public lastYieldError;\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event BoldTokenAddressChanged(address _newBoldTokenAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) LiquityBase(_addressesRegistry) {\n        collToken = _addressesRegistry.collToken();\n        troveManager = _addressesRegistry.troveManager();\n        boldToken = _addressesRegistry.boldToken();\n\n        emit TroveManagerAddressChanged(address(troveManager));\n        emit BoldTokenAddressChanged(address(boldToken));\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getCollBalance() external view override returns (uint256) {\n        return collBalance;\n    }\n\n    function getTotalBoldDeposits() external view override returns (uint256) {\n        return totalBoldDeposits;\n    }\n\n    function getYieldGainsOwed() external view override returns (uint256) {\n        return yieldGainsOwed;\n    }\n\n    function getYieldGainsPending() external view override returns (uint256) {\n        return yieldGainsPending;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Increases deposit, and takes new snapshots of accumulators P and S\n    * - Sends depositor's accumulated Coll gains to depositor\n    */\n    function provideToSP(uint256 _topUp, bool _doClaim) external override {\n        _requireNonZeroAmount(_topUp);\n\n        activePool.mintAggInterest();\n\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n\n        uint256 currentCollGain = getDepositorCollGain(msg.sender);\n        uint256 currentYieldGain = getDepositorYieldGain(msg.sender);\n        uint256 compoundedBoldDeposit = getCompoundedBoldDeposit(msg.sender);\n        (uint256 keptYieldGain, uint256 yieldGainToSend) = _getYieldToKeepOrSend(currentYieldGain, _doClaim);\n        uint256 newDeposit = compoundedBoldDeposit + _topUp + keptYieldGain;\n        (uint256 newStashedColl, uint256 collToSend) =\n            _getNewStashedCollAndCollToSend(msg.sender, currentCollGain, _doClaim);\n\n        emit DepositOperation(\n            msg.sender,\n            Operation.provideToSP,\n            initialDeposit - compoundedBoldDeposit,\n            int256(_topUp),\n            currentYieldGain,\n            yieldGainToSend,\n            currentCollGain,\n            collToSend\n        );\n\n        _updateDepositAndSnapshots(msg.sender, newDeposit, newStashedColl);\n        boldToken.sendToPool(msg.sender, address(this), _topUp);\n        uint256 totalBoldDepositsCached = _updateTotalBoldDeposits(_topUp + keptYieldGain, 0);\n        _decreaseYieldGainsOwed(currentYieldGain);\n        _sendBoldtoDepositor(msg.sender, yieldGainToSend);\n        _sendCollGainToDepositor(collToSend);\n\n        // If there were pending yields and with the new deposit we are reaching the threshold, let’s move the yield to owed\n        uint256 yieldGainsPendingCached = yieldGainsPending;\n        if (yieldGainsPendingCached > 0 && totalBoldDepositsCached >= DECIMAL_PRECISION) {\n            _updateYieldRewardsSum(yieldGainsPendingCached, totalBoldDepositsCached);\n        }\n    }\n\n    function _getYieldToKeepOrSend(uint256 _currentYieldGain, bool _doClaim) internal pure returns (uint256, uint256) {\n        uint256 yieldToKeep;\n        uint256 yieldToSend;\n\n        if (_doClaim) {\n            yieldToKeep = 0;\n            yieldToSend = _currentYieldGain;\n        } else {\n            yieldToKeep = _currentYieldGain;\n            yieldToSend = 0;\n        }\n\n        return (yieldToKeep, yieldToSend);\n    }\n\n    /*  withdrawFromSP():\n    * - Calculates depositor's Coll gain\n    * - Calculates the compounded deposit\n    * - Sends the requested BOLD withdrawal to depositor\n    * - (If _amount > userDeposit, the user withdraws all of their compounded deposit)\n    * - Decreases deposit by withdrawn amount and takes new snapshots of accumulators P and S\n    */\n    function withdrawFromSP(uint256 _amount, bool _doClaim) external override {\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        activePool.mintAggInterest();\n\n        uint256 currentCollGain = getDepositorCollGain(msg.sender);\n        uint256 currentYieldGain = getDepositorYieldGain(msg.sender);\n        uint256 compoundedBoldDeposit = getCompoundedBoldDeposit(msg.sender);\n        uint256 boldToWithdraw = LiquityMath._min(_amount, compoundedBoldDeposit);\n        (uint256 keptYieldGain, uint256 yieldGainToSend) = _getYieldToKeepOrSend(currentYieldGain, _doClaim);\n        uint256 newDeposit = compoundedBoldDeposit - boldToWithdraw + keptYieldGain;\n        (uint256 newStashedColl, uint256 collToSend) =\n            _getNewStashedCollAndCollToSend(msg.sender, currentCollGain, _doClaim);\n\n        emit DepositOperation(\n            msg.sender,\n            Operation.withdrawFromSP,\n            initialDeposit - compoundedBoldDeposit,\n            -int256(boldToWithdraw),\n            currentYieldGain,\n            yieldGainToSend,\n            currentCollGain,\n            collToSend\n        );\n\n        _updateDepositAndSnapshots(msg.sender, newDeposit, newStashedColl);\n        _decreaseYieldGainsOwed(currentYieldGain);\n        uint256 totalBoldDepositsCached = _updateTotalBoldDeposits(keptYieldGain, boldToWithdraw);\n        _sendBoldtoDepositor(msg.sender, boldToWithdraw + yieldGainToSend);\n        _sendCollGainToDepositor(collToSend);\n\n        // If there were pending yields and with the new deposit we are reaching the threshold, let’s move the yield to owed\n        uint256 yieldGainsPendingCached = yieldGainsPending;\n        if (yieldGainsPendingCached > 0 && totalBoldDepositsCached >= DECIMAL_PRECISION) {\n            _updateYieldRewardsSum(yieldGainsPendingCached, totalBoldDepositsCached);\n        }\n    }\n\n    function _getNewStashedCollAndCollToSend(address _depositor, uint256 _currentCollGain, bool _doClaim)\n        internal\n        view\n        returns (uint256 newStashedColl, uint256 collToSend)\n    {\n        if (_doClaim) {\n            newStashedColl = 0;\n            collToSend = stashedColl[_depositor] + _currentCollGain;\n        } else {\n            newStashedColl = stashedColl[_depositor] + _currentCollGain;\n            collToSend = 0;\n        }\n    }\n\n    // This function is only needed in the case a user has no deposit but still has remaining stashed Coll gains.\n    function claimAllCollGains() external {\n        _requireUserHasNoDeposit(msg.sender);\n\n        activePool.mintAggInterest();\n\n        uint256 collToSend = stashedColl[msg.sender];\n        _requireNonZeroAmount(collToSend);\n        stashedColl[msg.sender] = 0;\n\n        emit DepositOperation(msg.sender, Operation.claimAllCollGains, 0, 0, 0, 0, 0, collToSend);\n        emit DepositUpdated(msg.sender, 0, 0, 0, 0, 0, 0, 0);\n\n        _sendCollGainToDepositor(collToSend);\n    }\n\n    // --- BOLD reward functions ---\n\n    function triggerBoldRewards(uint256 _boldYield) external {\n        _requireCallerIsActivePool();\n        assert(_boldYield > 0); // TODO: remove before deploying\n\n        uint256 totalBoldDepositsCached = totalBoldDeposits; // cached to save an SLOAD\n\n        // When total deposits is very small, B is not updated. In this case, the BOLD issued is hold\n        // until the total deposits reach 1 BOLD (remains in the balance of the SP).\n        if (totalBoldDepositsCached < DECIMAL_PRECISION) {\n            yieldGainsPending += _boldYield;\n            return;\n        }\n\n        _updateYieldRewardsSum(yieldGainsPending + _boldYield, totalBoldDepositsCached);\n    }\n\n    function _updateYieldRewardsSum(uint256 _accumulatedYield, uint256 _totalBoldDeposits) internal {\n        assert(_accumulatedYield > 0); // TODO: remove before deploying\n\n        yieldGainsOwed += _accumulatedYield;\n        yieldGainsPending = 0;\n\n        uint256 yieldPerUnitStaked = _computeYieldPerUnitStaked(_accumulatedYield, _totalBoldDeposits);\n\n        uint256 marginalYieldGain = yieldPerUnitStaked * P;\n        epochToScaleToB[currentEpoch][currentScale] = epochToScaleToB[currentEpoch][currentScale] + marginalYieldGain;\n\n        emit B_Updated(epochToScaleToB[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n\n    function _computeYieldPerUnitStaked(uint256 _yield, uint256 _totalBoldDeposits) internal returns (uint256) {\n        /*\n        * Calculate the BOLD-per-unit staked.  Division uses a \"feedback\" error correction, to keep the\n        * cumulative error low in the running total B:\n        *\n        * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratio.\n        * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store this error for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint256 yieldNumerator = _yield * DECIMAL_PRECISION + lastYieldError;\n\n        uint256 yieldPerUnitStaked = yieldNumerator / _totalBoldDeposits;\n        lastYieldError = yieldNumerator - yieldPerUnitStaked * _totalBoldDeposits;\n\n        return yieldPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n    * Cancels out the specified debt against the Bold contained in the Stability Pool (as far as possible)\n    * and transfers the Trove's Coll collateral from ActivePool to StabilityPool.\n    * Only called by liquidation functions in the TroveManager.\n    */\n    function offset(uint256 _debtToOffset, uint256 _collToAdd) external override {\n        _requireCallerIsTroveManager();\n        uint256 totalBold = totalBoldDeposits; // cached to save an SLOAD\n        if (totalBold == 0 || _debtToOffset == 0) return;\n\n        (uint256 collGainPerUnitStaked, uint256 boldLossPerUnitStaked) =\n            _computeCollRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalBold);\n\n        _updateCollRewardSumAndProduct(collGainPerUnitStaked, boldLossPerUnitStaked); // updates S and P\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n    function _computeCollRewardsPerUnitStaked(uint256 _collToAdd, uint256 _debtToOffset, uint256 _totalBoldDeposits)\n        internal\n        returns (uint256 collGainPerUnitStaked, uint256 boldLossPerUnitStaked)\n    {\n        /*\n        * Compute the Bold and Coll rewards. Uses a \"feedback\" error correction, to keep\n        * the cumulative error in the P and S state variables low:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint256 collNumerator = _collToAdd * DECIMAL_PRECISION + lastCollError_Offset;\n\n        assert(_debtToOffset <= _totalBoldDeposits);\n        if (_debtToOffset == _totalBoldDeposits) {\n            boldLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastBoldLossError_Offset = 0;\n        } else {\n            uint256 boldLossNumerator = _debtToOffset * DECIMAL_PRECISION - lastBoldLossError_Offset;\n            /*\n            * Add 1 to make error in quotient positive. We want \"slightly too much\" Bold loss,\n            * which ensures the error in any given compoundedBoldDeposit favors the Stability Pool.\n            */\n            boldLossPerUnitStaked = boldLossNumerator / _totalBoldDeposits + 1;\n            lastBoldLossError_Offset = boldLossPerUnitStaked * _totalBoldDeposits - boldLossNumerator;\n        }\n\n        collGainPerUnitStaked = collNumerator / _totalBoldDeposits;\n        lastCollError_Offset = collNumerator - collGainPerUnitStaked * _totalBoldDeposits;\n\n        return (collGainPerUnitStaked, boldLossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateCollRewardSumAndProduct(uint256 _collGainPerUnitStaked, uint256 _boldLossPerUnitStaked) internal {\n        uint256 currentP = P;\n        uint256 newP;\n\n        assert(_boldLossPerUnitStaked <= DECIMAL_PRECISION);\n        /*\n        * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool Bold in the liquidation.\n        * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - boldLossPerUnitStaked)\n        */\n        uint256 newProductFactor = uint256(DECIMAL_PRECISION) - _boldLossPerUnitStaked;\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentS = epochToScaleToS[currentEpochCached][currentScaleCached];\n\n        /*\n        * Calculate the new S first, before we update P.\n        * The Coll gain for any given depositor from a liquidation depends on the value of their deposit\n        * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n        *\n        * Since S corresponds to Coll gain, and P to deposit loss, we update S first.\n        */\n        uint256 marginalCollGain = _collGainPerUnitStaked * currentP;\n        uint256 newS = currentS + marginalCollGain;\n        epochToScaleToS[currentEpochCached][currentScaleCached] = newS;\n        emit S_Updated(newS, currentEpochCached, currentScaleCached);\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached + 1;\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP * newProductFactor / DECIMAL_PRECISION < SCALE_FACTOR) {\n            newP = currentP * newProductFactor * SCALE_FACTOR / DECIMAL_PRECISION;\n            currentScale = currentScaleCached + 1;\n\n            // Increment the scale again if it's still below the boundary. This ensures the invariant P >= 1e9 holds and addresses this issue\n            // from Liquity v1: https://github.com/liquity/dev/security/advisories/GHSA-m9f3-hrx8-x2g3\n            if (newP < SCALE_FACTOR) {\n                newP *= SCALE_FACTOR;\n                currentScale = currentScaleCached + 2;\n            }\n\n            emit ScaleUpdated(currentScale);\n            // If there's no scale change and no pool-emptying, just do a standard multiplication\n        } else {\n            newP = currentP * newProductFactor / DECIMAL_PRECISION;\n        }\n\n        assert(newP > 0);\n        P = newP;\n\n        emit P_Updated(newP);\n    }\n\n    function _moveOffsetCollAndDebt(uint256 _collToAdd, uint256 _debtToOffset) internal {\n        // Cancel the liquidated Bold debt with the Bold in the stability pool\n        _updateTotalBoldDeposits(0, _debtToOffset);\n\n        // Burn the debt that was successfully offset\n        boldToken.burn(address(this), _debtToOffset);\n\n        // Update internal Coll balance tracker\n        uint256 newCollBalance = collBalance + _collToAdd;\n        collBalance = newCollBalance;\n\n        // Pull Coll from Active Pool\n        activePool.sendColl(address(this), _collToAdd);\n\n        emit StabilityPoolCollBalanceUpdated(newCollBalance);\n    }\n\n    function _updateTotalBoldDeposits(uint256 _depositIncrease, uint256 _depositDecrease) internal returns (uint256) {\n        if (_depositIncrease == 0 && _depositDecrease == 0) return totalBoldDeposits;\n        uint256 newTotalBoldDeposits = totalBoldDeposits + _depositIncrease - _depositDecrease;\n        totalBoldDeposits = newTotalBoldDeposits;\n        emit StabilityPoolBoldBalanceUpdated(newTotalBoldDeposits);\n\n        return newTotalBoldDeposits;\n    }\n\n    function _decreaseYieldGainsOwed(uint256 _amount) internal {\n        if (_amount == 0) return;\n        uint256 newYieldGainsOwed = yieldGainsOwed - _amount;\n        yieldGainsOwed = newYieldGainsOwed;\n    }\n\n    // --- Reward calculator functions for depositor ---\n\n    /* Calculates the Coll gain earned by the deposit since its last snapshots were taken.\n    * Given by the formula:  E = d0 * (S - S(0))/P(0)\n    * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorCollGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) return 0;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint256 collGain = _getCollGainFromSnapshots(initialDeposit, snapshots);\n        return collGain;\n    }\n\n    function getDepositorYieldGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) return 0;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint256 yieldGain = _getYieldGainFromSnapshots(initialDeposit, snapshots);\n        return yieldGain;\n    }\n\n    function getDepositorYieldGainWithPending(address _depositor) external view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) return 0;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint256 pendingSPYield = activePool.calcPendingSPYield() + yieldGainsPending;\n        uint256 firstPortionPending;\n        uint256 secondPortionPending;\n\n        if (pendingSPYield > 0 && snapshots.epoch == currentEpoch && totalBoldDeposits >= DECIMAL_PRECISION) {\n            uint256 yieldNumerator = pendingSPYield * DECIMAL_PRECISION + lastYieldError;\n            uint256 yieldPerUnitStaked = yieldNumerator / totalBoldDeposits;\n            uint256 marginalYieldGain = yieldPerUnitStaked * P;\n\n            if (currentScale == snapshots.scale) firstPortionPending = marginalYieldGain;\n            else if (currentScale == snapshots.scale + 1) secondPortionPending = marginalYieldGain;\n        }\n\n        uint256 firstPortion = epochToScaleToB[snapshots.epoch][snapshots.scale] + firstPortionPending - snapshots.B;\n        uint256 secondPortion =\n            (epochToScaleToB[snapshots.epoch][snapshots.scale + 1] + secondPortionPending) / SCALE_FACTOR;\n\n        return initialDeposit * (firstPortion + secondPortion) / snapshots.P / DECIMAL_PRECISION;\n    }\n\n    function _getCollGainFromSnapshots(uint256 initialDeposit, Snapshots memory snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /*\n        * Grab the sum 'S' from the epoch at which the stake was made. The Coll gain may span up to one scale change.\n        * If it does, the second portion of the Coll gain is scaled by 1e9.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 S_Snapshot = snapshots.S;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToS[epochSnapshot][scaleSnapshot] - S_Snapshot;\n        uint256 secondPortion = epochToScaleToS[epochSnapshot][scaleSnapshot + 1] / SCALE_FACTOR;\n\n        uint256 collGain = initialDeposit * (firstPortion + secondPortion) / P_Snapshot / DECIMAL_PRECISION;\n\n        return collGain;\n    }\n\n    function _getYieldGainFromSnapshots(uint256 initialDeposit, Snapshots memory snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /*\n        * Grab the sum 'B' from the epoch at which the stake was made. The Bold gain may span up to one scale change.\n        * If it does, the second portion of the Bold gain is scaled by 1e9.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 B_Snapshot = snapshots.B;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToB[epochSnapshot][scaleSnapshot] - B_Snapshot;\n        uint256 secondPortion = epochToScaleToB[epochSnapshot][scaleSnapshot + 1] / SCALE_FACTOR;\n\n        uint256 yieldGain = initialDeposit * (firstPortion + secondPortion) / P_Snapshot / DECIMAL_PRECISION;\n\n        return yieldGain;\n    }\n\n    // --- Compounded deposit ---\n\n    /*\n    * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n    */\n    function getCompoundedBoldDeposit(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) return 0;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    // Internal function, used to calculcate compounded deposits and compounded front end stakes.\n    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots memory snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) return 0;\n\n        uint256 compoundedStake;\n        uint128 scaleDiff = currentScale - scaleSnapshot;\n\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n        * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n        * at least 1e-9 -- so return 0.\n        */\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake * P / snapshot_P;\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake * P / snapshot_P / SCALE_FACTOR;\n        } else {\n            // if scaleDiff >= 2\n            compoundedStake = 0;\n        }\n\n        /*\n        * If compounded deposit is less than a billionth of the initial deposit, return 0.\n        *\n        * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n        * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n        * than it's theoretical value.\n        *\n        * Thus it's unclear whether this line is still really needed.\n        */\n        if (compoundedStake < initialStake / 1e9) return 0;\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for Bold deposit and Coll gains ---\n\n    function _sendCollGainToDepositor(uint256 _collAmount) internal {\n        if (_collAmount == 0) return;\n\n        uint256 newCollBalance = collBalance - _collAmount;\n        collBalance = newCollBalance;\n        emit StabilityPoolCollBalanceUpdated(newCollBalance);\n        emit EtherSent(msg.sender, _collAmount);\n        collToken.safeTransfer(msg.sender, _collAmount);\n    }\n\n    // Send Bold to user and decrease Bold in Pool\n    function _sendBoldtoDepositor(address _depositor, uint256 _boldToSend) internal {\n        if (_boldToSend == 0) return;\n        boldToken.returnFromPool(address(this), _depositor, _boldToSend);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newDeposit, uint256 _newStashedColl) internal {\n        deposits[_depositor].initialValue = _newDeposit;\n        stashedColl[_depositor] = _newStashedColl;\n\n        if (_newDeposit == 0) {\n            delete depositSnapshots[_depositor];\n            emit DepositUpdated(_depositor, 0, _newStashedColl, 0, 0, 0, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        // Get S for the current epoch and current scale\n        uint256 currentS = epochToScaleToS[currentEpochCached][currentScaleCached];\n        uint256 currentB = epochToScaleToB[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum S for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].S = currentS;\n        depositSnapshots[_depositor].B = currentB;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositUpdated(\n            _depositor,\n            _newDeposit,\n            _newStashedColl,\n            currentP,\n            currentS,\n            currentB,\n            currentScaleCached,\n            currentEpochCached\n        );\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require(msg.sender == address(activePool), \"StabilityPool: Caller is not ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"StabilityPool: Caller is not TroveManager\");\n    }\n\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit > 0, \"StabilityPool: User must have a non-zero deposit\");\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, \"StabilityPool: User must have no deposit\");\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount > 0, \"StabilityPool: Amount must be non-zero\");\n    }\n}\n"
    },
    "src/liquity/TroveManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IAddressesRegistry.sol\";\nimport \"../interfaces/IStabilityPool.sol\";\nimport \"../interfaces/ICollSurplusPool.sol\";\nimport \"../interfaces/IBoldToken.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/ITroveEvents.sol\";\nimport \"../interfaces/ITroveNFT.sol\";\nimport \"../interfaces/ICollateralRegistry.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../dependencies/LiquityBase.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract TroveManager is LiquityBase, ITroveManager, ITroveEvents {\n    // --- Connected contract declarations ---\n\n    ITroveNFT public troveNFT;\n    IBorrowerOperations public borrowerOperations;\n    IStabilityPool public stabilityPool;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    IBoldToken internal boldToken;\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n    ICollateralRegistry internal collateralRegistry;\n    // Wrapped ETH for liquidation reserve (gas compensation)\n    IWETH internal immutable WETH;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied\n    uint256 public immutable CCR;\n\n    // Minimum collateral ratio for individual troves\n    uint256 internal immutable MCR;\n    // Shutdown system collateral ratio. If the system's total collateral ratio (TCR) for a given collateral falls below the SCR,\n    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.\n    uint256 internal immutable SCR;\n\n    // Liquidation penalty for troves offset to the SP\n    uint256 internal immutable LIQUIDATION_PENALTY_SP;\n    // Liquidation penalty for troves redistributed\n    uint256 internal immutable LIQUIDATION_PENALTY_REDISTRIBUTION;\n\n    // --- Data structures ---\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        Status status;\n        uint64 arrayIndex;\n        uint64 lastDebtUpdateTime;\n        uint64 lastInterestRateAdjTime;\n        uint256 annualInterestRate;\n        address interestBatchManager;\n        uint256 batchDebtShares;\n    }\n\n    mapping(uint256 => Trove) public Troves;\n\n    // Store the necessary data for an interest batch manager. We treat each batch as a “big trove”.\n    // Each trove has a share of the debt and a share of the coll of the global batch (will in general be different, as CRs are different).\n    struct Batch {\n        uint256 debt;\n        uint256 coll;\n        uint64 arrayIndex;\n        uint64 lastDebtUpdateTime;\n        uint64 lastInterestRateAdjTime;\n        uint256 annualInterestRate;\n        uint256 annualManagementFee;\n        uint256 totalDebtShares;\n    }\n\n    mapping(address => Batch) internal batches;\n\n    uint256 internal totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint256 internal totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint256 internal totalCollateralSnapshot;\n\n    /*\n    * L_coll and L_boldDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An Coll gain of ( stake * [L_coll - L_coll(0)] )\n    * A boldDebt increase  of ( stake * [L_boldDebt - L_boldDebt(0)] )\n    *\n    * Where L_coll(0) and L_boldDebt(0) are snapshots of L_coll and L_boldDebt for the active Trove taken at the instant the stake was made\n    */\n    uint256 internal L_coll;\n    uint256 internal L_boldDebt;\n\n    // Map active troves to their RewardSnapshot\n    mapping(uint256 => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the Coll and Bold snapshots for a given active trove\n    struct RewardSnapshot {\n        uint256 coll;\n        uint256 boldDebt;\n    }\n\n    // Array of all active trove addresses - used to compute an approximate hint off-chain, for the sorted list insertion\n    uint256[] internal TroveIds;\n    // Array of all batch managers - used to fetch them off-chain\n    address[] public batchIds;\n\n    // Error trackers for the trove redistribution calculation\n    uint256 internal lastCollError_Redistribution;\n    uint256 internal lastBoldDebtError_Redistribution;\n\n    // Timestamp at which branch was shut down. 0 if not shut down.\n    uint256 public shutdownTime;\n\n    /*\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\".\n    **/\n\n    struct LiquidationValues {\n        uint256 collGasCompensation;\n        uint256 debtToOffset;\n        uint256 collToSendToSP;\n        uint256 debtToRedistribute;\n        uint256 collToRedistribute;\n        uint256 collSurplus;\n        uint256 ETHGasCompensation;\n        uint256 oldWeightedRecordedDebt;\n        uint256 newWeightedRecordedDebt;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct SingleRedemptionValues {\n        uint256 troveId;\n        address batchAddress;\n        uint256 boldLot;\n        uint256 collLot;\n        uint256 collFee;\n        uint256 appliedRedistBoldDebtGain;\n        uint256 oldWeightedRecordedDebt;\n        uint256 newWeightedRecordedDebt;\n        uint256 newStake;\n        LatestTroveData trove;\n        LatestBatchData batch;\n    }\n\n    // --- Errors ---\n\n    error EmptyData();\n    error NothingToLiquidate();\n    error CallerNotBorrowerOperations();\n    error CallerNotCollateralRegistry();\n    error OnlyOneTroveLeft();\n    error NotShutDown();\n    error NotEnoughBoldBalance();\n    error MinCollNotReached(uint256 _coll);\n\n    // --- Events ---\n\n    event TroveNFTAddressChanged(address _newTroveNFTAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event BoldTokenAddressChanged(address _newBoldTokenAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event CollateralRegistryAddressChanged(address _collateralRegistryAddress);\n\n    constructor(IAddressesRegistry _addressesRegistry) LiquityBase(_addressesRegistry) {\n        CCR = _addressesRegistry.CCR();\n        MCR = _addressesRegistry.MCR();\n        SCR = _addressesRegistry.SCR();\n        LIQUIDATION_PENALTY_SP = _addressesRegistry.LIQUIDATION_PENALTY_SP();\n        LIQUIDATION_PENALTY_REDISTRIBUTION = _addressesRegistry.LIQUIDATION_PENALTY_REDISTRIBUTION();\n\n        troveNFT = _addressesRegistry.troveNFT();\n        borrowerOperations = _addressesRegistry.borrowerOperations();\n        stabilityPool = _addressesRegistry.stabilityPool();\n        gasPoolAddress = _addressesRegistry.gasPoolAddress();\n        collSurplusPool = _addressesRegistry.collSurplusPool();\n        boldToken = _addressesRegistry.boldToken();\n        sortedTroves = _addressesRegistry.sortedTroves();\n        WETH = _addressesRegistry.WETH();\n        collateralRegistry = _addressesRegistry.collateralRegistry();\n\n        emit TroveNFTAddressChanged(address(troveNFT));\n        emit BorrowerOperationsAddressChanged(address(borrowerOperations));\n        emit StabilityPoolAddressChanged(address(stabilityPool));\n        emit GasPoolAddressChanged(gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(address(collSurplusPool));\n        emit BoldTokenAddressChanged(address(boldToken));\n        emit SortedTrovesAddressChanged(address(sortedTroves));\n        emit CollateralRegistryAddressChanged(address(collateralRegistry));\n    }\n\n    // --- Getters ---\n\n    function getTroveIdsCount() external view override returns (uint256) {\n        return TroveIds.length;\n    }\n\n    function getTroveFromTroveIdsArray(uint256 _index) external view override returns (uint256) {\n        return TroveIds[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove\n    function _liquidate(\n        IDefaultPool _defaultPool,\n        uint256 _troveId,\n        uint256 _boldInStabPool,\n        uint256 _price,\n        LatestTroveData memory trove,\n        LiquidationValues memory singleLiquidation\n    ) internal {\n        address owner = troveNFT.ownerOf(_troveId);\n\n        _getLatestTroveData(_troveId, trove);\n        address batchAddress = _getBatchManager(_troveId);\n        bool isTroveInBatch = batchAddress != address(0);\n        LatestBatchData memory batch;\n        if (isTroveInBatch) _getLatestBatchData(batchAddress, batch);\n\n        _movePendingTroveRewardsToActivePool(_defaultPool, trove.redistBoldDebtGain, trove.redistCollGain);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(trove.entireColl);\n        uint256 collToLiquidate = trove.entireColl - singleLiquidation.collGasCompensation;\n\n        (\n            singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute,\n            singleLiquidation.collSurplus\n        ) = _getOffsetAndRedistributionVals(trove.entireDebt, collToLiquidate, _boldInStabPool, _price);\n\n        TroveChange memory troveChange;\n        troveChange.collDecrease = trove.entireColl;\n        troveChange.debtDecrease = trove.entireDebt;\n        troveChange.appliedRedistCollGain = trove.redistCollGain;\n        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;\n        _closeTrove(\n            _troveId,\n            troveChange,\n            batchAddress,\n            batch.entireCollWithoutRedistribution,\n            batch.entireDebtWithoutRedistribution,\n            Status.closedByLiquidation\n        );\n\n        if (isTroveInBatch) {\n            singleLiquidation.oldWeightedRecordedDebt =\n                batch.weightedRecordedDebt + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualInterestRate;\n            singleLiquidation.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n            // Mint batch management fee\n            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee\n                + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee =\n                batch.entireDebtWithoutRedistribution * batch.annualManagementFee;\n            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, batchAddress);\n        } else {\n            singleLiquidation.oldWeightedRecordedDebt = trove.weightedRecordedDebt;\n        }\n\n        // Differencen between liquidation penalty and liquidation threshold\n        if (singleLiquidation.collSurplus > 0) {\n            collSurplusPool.accountSurplus(owner, singleLiquidation.collSurplus);\n        }\n\n        // Wipe out state in BO\n        borrowerOperations.onLiquidateTrove(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: 0,\n            _coll: 0,\n            _stake: 0,\n            _annualInterestRate: 0,\n            _snapshotOfTotalCollRedist: 0,\n            _snapshotOfTotalDebtRedist: 0\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.liquidate,\n            _annualInterestRate: 0,\n            _debtIncreaseFromRedist: trove.redistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: 0,\n            _debtChangeFromOperation: -int256(trove.entireDebt),\n            _collIncreaseFromRedist: trove.redistCollGain,\n            _collChangeFromOperation: -int256(trove.entireColl)\n        });\n\n        if (isTroveInBatch) {\n            emit BatchUpdated({\n                _interestBatchManager: batchAddress,\n                _operation: BatchOperation.exitBatch,\n                _debt: batches[batchAddress].debt,\n                _coll: batches[batchAddress].coll,\n                _annualInterestRate: batch.annualInterestRate,\n                _annualManagementFee: batch.annualManagementFee,\n                _totalDebtShares: batches[batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        }\n    }\n\n    // Return the amount of Coll to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(uint256 _entireColl) internal pure returns (uint256) {\n        return LiquityMath._min(_entireColl / COLL_GAS_COMPENSATION_DIVISOR, COLL_GAS_COMPENSATION_CAP);\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n    * redistributed to active troves.\n    */\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        uint256 _collToLiquidate, // gas compensation is already subtracted\n        uint256 _boldInStabPool,\n        uint256 _price\n    )\n        internal\n        view\n        returns (\n            uint256 debtToOffset,\n            uint256 collToSendToSP,\n            uint256 debtToRedistribute,\n            uint256 collToRedistribute,\n            uint256 collSurplus\n        )\n    {\n        uint256 collSPPortion;\n        /*\n         * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n         * between all active troves.\n         *\n         *  If the trove's debt is larger than the deposited Bold in the Stability Pool:\n         *\n         *  - Offset an amount of the trove's debt equal to the Bold in the Stability Pool\n         *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n         *\n         */\n        if (_boldInStabPool > 0) {\n            debtToOffset = LiquityMath._min(_entireTroveDebt, _boldInStabPool);\n            collSPPortion = _collToLiquidate * debtToOffset / _entireTroveDebt;\n            (collToSendToSP, collSurplus) =\n                _getCollPenaltyAndSurplus(collSPPortion, debtToOffset, LIQUIDATION_PENALTY_SP, _price);\n        }\n\n        // Redistribution\n        debtToRedistribute = _entireTroveDebt - debtToOffset;\n        if (debtToRedistribute > 0) {\n            uint256 collRedistributionPortion = _collToLiquidate - collSPPortion;\n            if (collRedistributionPortion > 0) {\n                (collToRedistribute, collSurplus) = _getCollPenaltyAndSurplus(\n                    collRedistributionPortion + collSurplus, // Coll surplus from offset can be eaten up by red. penalty\n                    debtToRedistribute,\n                    LIQUIDATION_PENALTY_REDISTRIBUTION, // _penaltyRatio\n                    _price\n                );\n            }\n        }\n        // assert(_collToLiquidate == collToSendToSP + collToRedistribute + collSurplus);\n    }\n\n    function _getCollPenaltyAndSurplus(\n        uint256 _collToLiquidate,\n        uint256 _debtToLiquidate,\n        uint256 _penaltyRatio,\n        uint256 _price\n    ) internal pure returns (uint256 seizedColl, uint256 collSurplus) {\n        uint256 maxSeizedColl = _debtToLiquidate * (DECIMAL_PRECISION + _penaltyRatio) / _price;\n        if (_collToLiquidate > maxSeizedColl) {\n            seizedColl = maxSeizedColl;\n            collSurplus = _collToLiquidate - maxSeizedColl;\n        } else {\n            seizedColl = _collToLiquidate;\n            collSurplus = 0;\n        }\n    }\n\n    /*\n     * Attempt to liquidate a custom list of troves provided by the caller.\n     */\n    function batchLiquidateTroves(uint256[] memory _troveArray) public override {\n        if (_troveArray.length == 0) {\n            revert EmptyData();\n        }\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        TroveChange memory troveChange;\n        LiquidationValues memory totals;\n\n        (uint256 price,) = priceFeed.fetchPrice();\n        uint256 boldInStabPool = stabilityPoolCached.getTotalBoldDeposits();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        _batchLiquidateTroves(defaultPoolCached, price, boldInStabPool, _troveArray, totals, troveChange);\n\n        if (troveChange.debtDecrease == 0) {\n            revert NothingToLiquidate();\n        }\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, address(0));\n\n        // Move liquidated Coll and Bold to the appropriate pools\n        if (totals.debtToOffset > 0 || totals.collToSendToSP > 0) {\n            stabilityPoolCached.offset(totals.debtToOffset, totals.collToSendToSP);\n        }\n        // we check amount is not zero inside\n        _redistributeDebtAndColl(\n            activePoolCached, defaultPoolCached, totals.debtToRedistribute, totals.collToRedistribute\n        );\n        if (totals.collSurplus > 0) {\n            activePoolCached.sendColl(address(collSurplusPool), totals.collSurplus);\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.collGasCompensation);\n\n        emit Liquidation(\n            totals.debtToOffset,\n            totals.debtToRedistribute,\n            totals.ETHGasCompensation,\n            totals.collGasCompensation,\n            totals.collToSendToSP,\n            totals.collToRedistribute,\n            totals.collSurplus,\n            L_coll,\n            L_boldDebt,\n            price\n        );\n\n        // Send gas compensation to caller\n        _sendGasCompensation(activePoolCached, msg.sender, totals.ETHGasCompensation, totals.collGasCompensation);\n    }\n\n    function _isLiquidatableStatus(Status _status) internal pure returns (bool) {\n        return _status == Status.active || _status == Status.unredeemable;\n    }\n\n    function _batchLiquidateTroves(\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _boldInStabPool,\n        uint256[] memory _troveArray,\n        LiquidationValues memory totals,\n        TroveChange memory troveChange\n    ) internal {\n        uint256 remainingBoldInStabPool = _boldInStabPool;\n\n        for (uint256 i = 0; i < _troveArray.length; i++) {\n            uint256 troveId = _troveArray[i];\n\n            // Skip non-liquidatable troves\n            if (!_isLiquidatableStatus(Troves[troveId].status)) continue;\n\n            uint256 ICR = getCurrentICR(troveId, _price);\n\n            if (ICR < MCR) {\n                LiquidationValues memory singleLiquidation;\n                LatestTroveData memory trove;\n\n                _liquidate(_defaultPool, troveId, remainingBoldInStabPool, _price, trove, singleLiquidation);\n                remainingBoldInStabPool -= singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                _addLiquidationValuesToTotals(trove, singleLiquidation, totals, troveChange);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    // Adds all values from `singleLiquidation` to their respective totals in `totals` in-place\n    function _addLiquidationValuesToTotals(\n        LatestTroveData memory _trove,\n        LiquidationValues memory _singleLiquidation,\n        LiquidationValues memory totals,\n        TroveChange memory troveChange\n    ) internal pure {\n        // Tally all the values with their respective running totals\n        totals.collGasCompensation += _singleLiquidation.collGasCompensation;\n        totals.ETHGasCompensation += ETH_GAS_COMPENSATION;\n        troveChange.debtDecrease += _trove.entireDebt;\n        troveChange.collDecrease += _trove.entireColl;\n        troveChange.appliedRedistBoldDebtGain += _trove.redistBoldDebtGain;\n        troveChange.oldWeightedRecordedDebt += _singleLiquidation.oldWeightedRecordedDebt;\n        troveChange.newWeightedRecordedDebt += _singleLiquidation.newWeightedRecordedDebt;\n        totals.debtToOffset += _singleLiquidation.debtToOffset;\n        totals.collToSendToSP += _singleLiquidation.collToSendToSP;\n        totals.debtToRedistribute += _singleLiquidation.debtToRedistribute;\n        totals.collToRedistribute += _singleLiquidation.collToRedistribute;\n        totals.collSurplus += _singleLiquidation.collSurplus;\n    }\n\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, uint256 _eth, uint256 _coll) internal {\n        if (_eth > 0) {\n            WETH.transferFrom(gasPoolAddress, _liquidator, _eth);\n        }\n\n        if (_coll > 0) {\n            _activePool.sendColl(_liquidator, _coll);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(IDefaultPool _defaultPool, uint256 _bold, uint256 _coll) internal {\n        if (_bold > 0) {\n            _defaultPool.decreaseBoldDebt(_bold);\n        }\n\n        if (_coll > 0) {\n            _defaultPool.sendCollToActivePool(_coll);\n        }\n    }\n\n    // --- Redemption functions ---\n\n    function _applySingleRedemption(\n        IDefaultPool _defaultPool,\n        SingleRedemptionValues memory _singleRedemption,\n        bool _isTroveInBatch\n    ) internal returns (uint256) {\n        // Decrease the debt and collateral of the current Trove according to the Bold lot and corresponding ETH to send\n        uint256 newDebt = _singleRedemption.trove.entireDebt - _singleRedemption.boldLot;\n        uint256 newColl = _singleRedemption.trove.entireColl - _singleRedemption.collLot;\n\n        _singleRedemption.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;\n\n        if (_isTroveInBatch) {\n            _getLatestBatchData(_singleRedemption.batchAddress, _singleRedemption.batch);\n            // We know boldLot <= trove entire debt, so this subtraction is safe\n            uint256 newAmountForWeightedDebt = _singleRedemption.batch.entireDebtWithoutRedistribution\n                + _singleRedemption.trove.redistBoldDebtGain - _singleRedemption.boldLot;\n            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.batch.weightedRecordedDebt;\n            _singleRedemption.newWeightedRecordedDebt =\n                newAmountForWeightedDebt * _singleRedemption.batch.annualInterestRate;\n\n            TroveChange memory troveChange;\n            troveChange.debtDecrease = _singleRedemption.boldLot;\n            troveChange.collDecrease = _singleRedemption.collLot;\n            troveChange.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;\n            troveChange.appliedRedistCollGain = _singleRedemption.trove.redistCollGain;\n            // batchAccruedManagementFee is handled in the outer function\n            troveChange.oldWeightedRecordedBatchManagementFee =\n                _singleRedemption.batch.weightedRecordedBatchManagementFee;\n            troveChange.newWeightedRecordedBatchManagementFee =\n                newAmountForWeightedDebt * _singleRedemption.batch.annualManagementFee;\n\n            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, _singleRedemption.batchAddress);\n\n            Troves[_singleRedemption.troveId].coll = newColl;\n            // interest and fee were updated in the outer function\n            _updateBatchShares(\n                _singleRedemption.troveId,\n                _singleRedemption.batchAddress,\n                troveChange,\n                _singleRedemption.batch.entireCollWithoutRedistribution,\n                _singleRedemption.batch.entireDebtWithoutRedistribution\n            );\n        } else {\n            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.trove.weightedRecordedDebt;\n            _singleRedemption.newWeightedRecordedDebt = newDebt * _singleRedemption.trove.annualInterestRate;\n            Troves[_singleRedemption.troveId].debt = newDebt;\n            Troves[_singleRedemption.troveId].coll = newColl;\n            Troves[_singleRedemption.troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        }\n\n        _singleRedemption.newStake = _updateStakeAndTotalStakes(_singleRedemption.troveId, newColl);\n        _movePendingTroveRewardsToActivePool(\n            _defaultPool, _singleRedemption.trove.redistBoldDebtGain, _singleRedemption.trove.redistCollGain\n        );\n        _updateTroveRewardSnapshots(_singleRedemption.troveId);\n\n        if (_isTroveInBatch) {\n            emit BatchedTroveUpdated({\n                _troveId: _singleRedemption.troveId,\n                _interestBatchManager: _singleRedemption.batchAddress,\n                _batchDebtShares: Troves[_singleRedemption.troveId].batchDebtShares,\n                _coll: newColl,\n                _stake: _singleRedemption.newStake,\n                _snapshotOfTotalCollRedist: L_coll,\n                _snapshotOfTotalDebtRedist: L_boldDebt\n            });\n        } else {\n            emit TroveUpdated({\n                _troveId: _singleRedemption.troveId,\n                _debt: newDebt,\n                _coll: newColl,\n                _stake: _singleRedemption.newStake,\n                _annualInterestRate: _singleRedemption.trove.annualInterestRate,\n                _snapshotOfTotalCollRedist: L_coll,\n                _snapshotOfTotalDebtRedist: L_boldDebt\n            });\n        }\n\n        emit TroveOperation({\n            _troveId: _singleRedemption.troveId,\n            _operation: Operation.redeemCollateral,\n            _annualInterestRate: _singleRedemption.trove.annualInterestRate,\n            _debtIncreaseFromRedist: _singleRedemption.trove.redistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: 0,\n            _debtChangeFromOperation: -int256(_singleRedemption.boldLot),\n            _collIncreaseFromRedist: _singleRedemption.trove.redistCollGain,\n            _collChangeFromOperation: -int256(_singleRedemption.collLot)\n        });\n\n        if (_isTroveInBatch) {\n            emit BatchUpdated({\n                _interestBatchManager: _singleRedemption.batchAddress,\n                _operation: BatchOperation.troveChange,\n                _debt: batches[_singleRedemption.batchAddress].debt,\n                _coll: batches[_singleRedemption.batchAddress].coll,\n                _annualInterestRate: _singleRedemption.batch.annualInterestRate,\n                _annualManagementFee: _singleRedemption.batch.annualManagementFee,\n                _totalDebtShares: batches[_singleRedemption.batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        }\n\n        emit RedemptionFeePaidToTrove(_singleRedemption.troveId, _singleRedemption.collFee);\n\n        return newDebt;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for Bold up to _maxBoldamount\n    function _redeemCollateralFromTrove(\n        IDefaultPool _defaultPool,\n        SingleRedemptionValues memory _singleRedemption,\n        uint256 _maxBoldamount,\n        uint256 _price,\n        uint256 _redemptionRate\n    ) internal {\n        _getLatestTroveData(_singleRedemption.troveId, _singleRedemption.trove);\n\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove\n        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);\n\n        // Get the amount of Coll equal in USD value to the boldLot redeemed\n        uint256 correspondingColl = _singleRedemption.boldLot * DECIMAL_PRECISION / _price;\n        // Calculate the collFee separately (for events)\n        _singleRedemption.collFee = correspondingColl * _redemptionRate / DECIMAL_PRECISION;\n        // Get the final collLot to send to redeemer, leaving the fee in the Trove\n        _singleRedemption.collLot = correspondingColl - _singleRedemption.collFee;\n\n        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);\n        uint256 newDebt = _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);\n\n        // Make Trove unredeemable if it's tiny, in order to prevent griefing future (normal, sequential) redemptions\n        if (newDebt < MIN_DEBT) {\n            Troves[_singleRedemption.troveId].status = Status.unredeemable;\n            if (isTroveInBatch) {\n                sortedTroves.removeFromBatch(_singleRedemption.troveId);\n            } else {\n                sortedTroves.remove(_singleRedemption.troveId);\n            }\n        }\n    }\n\n    function _updateBatchInterestPriorToRedemption(IActivePool _activePool, address _batchAddress) internal {\n        LatestBatchData memory batch;\n        _getLatestBatchData(_batchAddress, batch);\n        batches[_batchAddress].debt = batch.entireDebtWithoutRedistribution;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n        // As we are updating the batch, we update the ActivePool weighted sum too\n        TroveChange memory batchTroveChange;\n        batchTroveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;\n        batchTroveChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;\n        batchTroveChange.batchAccruedManagementFee = batch.accruedManagementFee;\n        batchTroveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;\n        batchTroveChange.newWeightedRecordedBatchManagementFee =\n            batch.entireDebtWithoutRedistribution * batch.annualManagementFee;\n\n        _activePool.mintAggInterestAndAccountForTroveChange(batchTroveChange, _batchAddress);\n    }\n\n    /* Send _boldamount Bold to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies redistribution gains to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    *\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    *\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    *\n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining Bold amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        address _redeemer,\n        uint256 _boldamount,\n        uint256 _price,\n        uint256 _redemptionRate,\n        uint256 _maxIterations\n    ) external override returns (uint256 _redemeedAmount) {\n        _requireCallerIsCollateralRegistry();\n\n        IActivePool activePoolCached = activePool;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        TroveChange memory totalsTroveChange;\n        uint256 totalCollFee;\n\n        uint256 remainingBold = _boldamount;\n\n        SingleRedemptionValues memory singleRedemption;\n        singleRedemption.troveId = sortedTrovesCached.getLast();\n        address lastBatchUpdatedInterest = address(0);\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of Bold is exchanged for collateral\n        if (_maxIterations == 0) _maxIterations = type(uint256).max;\n        while (singleRedemption.troveId != 0 && remainingBold > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the uint256 of the Trove preceding the current one\n            uint256 nextUserToCheck = sortedTrovesCached.getPrev(singleRedemption.troveId);\n            // Skip if ICR < 100%, to make sure that redemptions always improve the CR of hit Troves\n            if (getCurrentICR(singleRedemption.troveId, _price) < _100pct) {\n                singleRedemption.troveId = nextUserToCheck;\n                continue;\n            }\n\n            // If it’s in a batch, we need to update interest first\n            // We do it here outside, to avoid repeating for each trove in the same batch\n            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);\n            if (\n                singleRedemption.batchAddress != address(0) && singleRedemption.batchAddress != lastBatchUpdatedInterest\n            ) {\n                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);\n                lastBatchUpdatedInterest = singleRedemption.batchAddress;\n            }\n\n            _redeemCollateralFromTrove(defaultPool, singleRedemption, remainingBold, _price, _redemptionRate);\n\n            totalsTroveChange.collDecrease += singleRedemption.collLot;\n            totalsTroveChange.debtDecrease += singleRedemption.boldLot;\n            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;\n            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,\n            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove's recorded\n            // (and weighted recorded) debt, but the accrued interest increases it.\n            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;\n            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;\n            totalCollFee += singleRedemption.collFee;\n\n            remainingBold -= singleRedemption.boldLot;\n            singleRedemption.troveId = nextUserToCheck;\n        }\n\n        // We are removing this condition to prevent blocking redemptions\n        //require(totals.totalCollDrawn > 0, \"TroveManager: Unable to redeem any amount\");\n\n        emit Redemption(\n            _boldamount, totalsTroveChange.debtDecrease, totalsTroveChange.collDecrease, totalCollFee, _price\n        );\n\n        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));\n\n        // Send the redeemed Coll to sender\n        activePoolCached.sendColl(_redeemer, totalsTroveChange.collDecrease);\n        // We’ll burn all the Bold together out in the CollateralRegistry, to save gas\n\n        return totalsTroveChange.debtDecrease;\n    }\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for Bold up to _maxBoldamount\n    function _urgentRedeemCollateralFromTrove(\n        IDefaultPool _defaultPool,\n        uint256 _maxBoldamount,\n        uint256 _price,\n        SingleRedemptionValues memory _singleRedemption\n    ) internal {\n        _getLatestTroveData(_singleRedemption.troveId, _singleRedemption.trove);\n\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);\n\n        // Get the amount of ETH equal in USD value to the BOLD lot redeemed\n        _singleRedemption.collLot = _singleRedemption.boldLot * (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS) / _price;\n        // As here we can redeem when CR < 100%, we need to cap by collateral too\n        if (_singleRedemption.collLot > _singleRedemption.trove.entireColl) {\n            _singleRedemption.collLot = _singleRedemption.trove.entireColl;\n            _singleRedemption.boldLot =\n                _singleRedemption.trove.entireColl * _price / (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS);\n        }\n\n        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);\n        _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);\n\n        // No need to make this Trove unredeemable if it has tiny debt, since:\n        // - This collateral branch has shut down and urgent redemptions are enabled\n        // - Urgent redemptions aren't sequential, so they can't be griefed by tiny Troves.\n    }\n\n    function urgentRedemption(uint256 _boldAmount, uint256[] calldata _troveIds, uint256 _minCollateral) external {\n        _requireIsShutDown();\n        _requireBoldBalanceCoversRedemption(boldToken, msg.sender, _boldAmount);\n\n        IActivePool activePoolCached = activePool;\n        TroveChange memory totalsTroveChange;\n\n        (uint256 price,) = priceFeed.fetchPrice();\n\n        uint256 remainingBold = _boldAmount;\n        for (uint256 i = 0; i < _troveIds.length; i++) {\n            SingleRedemptionValues memory singleRedemption;\n            singleRedemption.troveId = _troveIds[i];\n\n            // If it’s in a batch, we need to update interest first\n            // As we don’t have them ordered now, we cannot avoid repeating for each trove in the same batch\n            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);\n            if (singleRedemption.batchAddress != address(0)) {\n                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);\n            }\n\n            _urgentRedeemCollateralFromTrove(defaultPool, remainingBold, price, singleRedemption);\n\n            totalsTroveChange.collDecrease += singleRedemption.collLot;\n            totalsTroveChange.debtDecrease += singleRedemption.boldLot;\n            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;\n            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,\n            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove's recorded\n            // (and weighted recorded) debt, but the accrued interest increases it.\n            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;\n            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;\n\n            remainingBold -= singleRedemption.boldLot;\n            if (remainingBold == 0) break;\n        }\n\n        if (totalsTroveChange.collDecrease < _minCollateral) {\n            revert MinCollNotReached(totalsTroveChange.collDecrease);\n        }\n\n        emit Redemption(_boldAmount, totalsTroveChange.debtDecrease, totalsTroveChange.collDecrease, 0, price);\n\n        // Since this branch is shut down, this will mint 0 interest.\n        // We call this only to update the aggregate debt and weighted debt trackers.\n        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));\n\n        // Send the redeemed coll to caller\n        activePoolCached.sendColl(msg.sender, totalsTroveChange.collDecrease);\n        // Burn bold\n        boldToken.burn(msg.sender, totalsTroveChange.debtDecrease);\n    }\n\n    function shutdown() external {\n        _requireCallerIsBorrowerOperations();\n        shutdownTime = block.timestamp;\n        activePool.setShutdownFlag();\n    }\n\n    // --- Helper functions ---\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(uint256 _troveId, uint256 _price) public view override returns (uint256) {\n        LatestTroveData memory trove;\n        _getLatestTroveData(_troveId, trove);\n        return LiquityMath._computeCR(trove.entireColl, trove.entireDebt, _price);\n    }\n\n    function _updateTroveRewardSnapshots(uint256 _troveId) internal {\n        rewardSnapshots[_troveId].coll = L_coll;\n        rewardSnapshots[_troveId].boldDebt = L_boldDebt;\n    }\n\n    // Return the Troves entire debt and coll, including redistribution gains from redistributions.\n    function _getLatestTroveData(uint256 _troveId, LatestTroveData memory trove) internal view {\n        // If trove belongs to a batch, we fetch the batch and apply its share to obtained values\n        address batchAddress = _getBatchManager(_troveId);\n        if (batchAddress != address(0)) {\n            LatestBatchData memory batch;\n            _getLatestBatchData(batchAddress, batch);\n            _getLatestTroveDataFromBatch(_troveId, batchAddress, trove, batch);\n            return;\n        }\n\n        uint256 stake = Troves[_troveId].stake;\n        trove.redistBoldDebtGain = stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;\n        trove.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;\n\n        trove.recordedDebt = Troves[_troveId].debt;\n        trove.annualInterestRate = Troves[_troveId].annualInterestRate;\n        trove.weightedRecordedDebt = trove.recordedDebt * trove.annualInterestRate;\n\n        uint256 period = _getInterestPeriod(Troves[_troveId].lastDebtUpdateTime);\n        trove.accruedInterest = _calcInterest(trove.weightedRecordedDebt, period);\n\n        trove.entireDebt = trove.recordedDebt + trove.redistBoldDebtGain + trove.accruedInterest;\n        trove.entireColl = Troves[_troveId].coll + trove.redistCollGain;\n        trove.lastInterestRateAdjTime = Troves[_troveId].lastInterestRateAdjTime;\n    }\n\n    function _getLatestTroveDataFromBatch(\n        uint256 _troveId,\n        address _batchAddress,\n        LatestTroveData memory _latestTroveData,\n        LatestBatchData memory _latestBatchData\n    ) internal view {\n        Trove memory trove = Troves[_troveId];\n        Batch memory batch = batches[_batchAddress];\n        uint256 batchDebtShares = trove.batchDebtShares;\n        uint256 totalDebtShares = batch.totalDebtShares;\n\n        uint256 stake = trove.stake;\n        //uint256 batchRedistBoldDebtGain = stake * (L_boldDebt - rewardBatchSnapshots[_batchAddress].boldDebt) / DECIMAL_PRECISION;\n        _latestTroveData.redistBoldDebtGain =\n            stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;\n        _latestTroveData.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;\n\n        if (totalDebtShares > 0) {\n            _latestTroveData.recordedDebt = _latestBatchData.recordedDebt * batchDebtShares / totalDebtShares;\n            _latestTroveData.weightedRecordedDebt =\n                _latestBatchData.weightedRecordedDebt * batchDebtShares / totalDebtShares;\n            _latestTroveData.accruedInterest = _latestBatchData.accruedInterest * batchDebtShares / totalDebtShares;\n            _latestTroveData.accruedBatchManagementFee =\n                _latestBatchData.accruedManagementFee * batchDebtShares / totalDebtShares;\n        }\n        _latestTroveData.annualInterestRate = _latestBatchData.annualInterestRate;\n\n        // We can’t do pro-rata batch entireDebt, because redist gains are proportional to coll, not to debt\n        _latestTroveData.entireDebt = _latestTroveData.recordedDebt + _latestTroveData.redistBoldDebtGain\n            + _latestTroveData.accruedInterest + _latestTroveData.accruedBatchManagementFee;\n        _latestTroveData.entireColl = trove.coll + _latestTroveData.redistCollGain;\n        _latestTroveData.lastInterestRateAdjTime =\n            LiquityMath._max(_latestBatchData.lastInterestRateAdjTime, trove.lastInterestRateAdjTime);\n    }\n\n    function getLatestTroveData(uint256 _troveId) external view returns (LatestTroveData memory trove) {\n        _getLatestTroveData(_troveId, trove);\n    }\n\n    function getTroveAnnualInterestRate(uint256 _troveId) external view returns (uint256) {\n        Trove memory trove = Troves[_troveId];\n        address batchAddress = _getBatchManager(trove);\n        if (batchAddress != address(0)) {\n            return batches[batchAddress].annualInterestRate;\n        }\n        return trove.annualInterestRate;\n    }\n\n    function _getBatchManager(uint256 _troveId) internal view returns (address) {\n        return Troves[_troveId].interestBatchManager;\n    }\n\n    function _getBatchManager(Trove memory trove) internal pure returns (address) {\n        return trove.interestBatchManager;\n    }\n\n    // Return the Batch entire debt and coll, including redistribution gains from redistributions.\n    function _getLatestBatchData(address _batchAddress, LatestBatchData memory latestBatchData) internal view {\n        Batch memory batch = batches[_batchAddress];\n\n        latestBatchData.recordedDebt = batch.debt;\n        latestBatchData.annualInterestRate = batch.annualInterestRate;\n        latestBatchData.weightedRecordedDebt = latestBatchData.recordedDebt * latestBatchData.annualInterestRate;\n        uint256 period = _getInterestPeriod(batch.lastDebtUpdateTime);\n        latestBatchData.accruedInterest = _calcInterest(latestBatchData.weightedRecordedDebt, period);\n        latestBatchData.annualManagementFee = batch.annualManagementFee;\n        latestBatchData.weightedRecordedBatchManagementFee =\n            latestBatchData.recordedDebt * latestBatchData.annualManagementFee;\n        latestBatchData.accruedManagementFee = _calcInterest(latestBatchData.weightedRecordedBatchManagementFee, period);\n\n        latestBatchData.entireDebtWithoutRedistribution =\n            latestBatchData.recordedDebt + latestBatchData.accruedInterest + latestBatchData.accruedManagementFee;\n        latestBatchData.entireCollWithoutRedistribution = batch.coll;\n        latestBatchData.lastDebtUpdateTime = batch.lastDebtUpdateTime;\n        latestBatchData.lastInterestRateAdjTime = batch.lastInterestRateAdjTime;\n    }\n\n    function getLatestBatchData(address _batchAddress) external view returns (LatestBatchData memory batch) {\n        _getLatestBatchData(_batchAddress, batch);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(uint256 _troveId, uint256 _coll) internal returns (uint256 newStake) {\n        newStake = _computeNewStake(_coll);\n        uint256 oldStake = Troves[_troveId].stake;\n        Troves[_troveId].stake = newStake;\n\n        totalStakes = totalStakes - oldStake + newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint256 _coll) internal view returns (uint256) {\n        uint256 stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove\n            * - When we close or liquidate a trove, we redistribute the redistribution gains, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            // assert(totalStakesSnapshot > 0);\n            stake = _coll * totalStakesSnapshot / totalCollateralSnapshot;\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _debtToRedistribute,\n        uint256 _collToRedistribute\n    ) internal {\n        if (_debtToRedistribute == 0) return;\n\n        /*\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n        * error correction, to keep the cumulative error low in the running totals L_coll and L_boldDebt:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint256 collNumerator = _collToRedistribute * DECIMAL_PRECISION + lastCollError_Redistribution;\n        uint256 boldDebtNumerator = _debtToRedistribute * DECIMAL_PRECISION + lastBoldDebtError_Redistribution;\n\n        // Get the per-unit-staked terms\n        uint256 collRewardPerUnitStaked = collNumerator / totalStakes;\n        uint256 boldDebtRewardPerUnitStaked = boldDebtNumerator / totalStakes;\n\n        lastCollError_Redistribution = collNumerator - collRewardPerUnitStaked * totalStakes;\n        lastBoldDebtError_Redistribution = boldDebtNumerator - boldDebtRewardPerUnitStaked * totalStakes;\n\n        // Add per-unit-staked terms to the running totals\n        L_coll = L_coll + collRewardPerUnitStaked;\n        L_boldDebt = L_boldDebt + boldDebtRewardPerUnitStaked;\n\n        _defaultPool.increaseBoldDebt(_debtToRedistribute);\n        _activePool.sendCollToDefaultPool(_collToRedistribute);\n    }\n\n    /*\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint256 _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint256 activeColl = _activePool.getCollBalance();\n        uint256 liquidatedColl = defaultPool.getCollBalance();\n        totalCollateralSnapshot = activeColl - _collRemainder + liquidatedColl;\n    }\n\n    /*\n    * Remove a Trove owner from the TroveIds array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\n    */\n    function _removeTroveId(uint256 _troveId, uint256 TroveIdsArrayLength) internal {\n        uint64 index = Troves[_troveId].arrayIndex;\n        uint256 idxLast = TroveIdsArrayLength - 1;\n\n        // assert(index <= idxLast);\n\n        uint256 idToMove = TroveIds[idxLast];\n\n        TroveIds[index] = idToMove;\n        Troves[idToMove].arrayIndex = index;\n\n        TroveIds.pop();\n    }\n\n    function getTroveStatus(uint256 _troveId) external view override returns (Status) {\n        return Troves[_troveId].status;\n    }\n\n    // --- Interest rate calculations ---\n\n    function _getInterestPeriod(uint256 _lastDebtUpdateTime) internal view returns (uint256) {\n        if (shutdownTime == 0) {\n            // If branch is not shut down, interest is earned up to now.\n            return block.timestamp - _lastDebtUpdateTime;\n        } else if (shutdownTime > 0 && _lastDebtUpdateTime < shutdownTime) {\n            // If branch is shut down and the Trove was not updated since shut down, interest is earned up to the shutdown time.\n            return shutdownTime - _lastDebtUpdateTime;\n        } else {\n            // if (shutdownTime > 0 && _lastDebtUpdateTime >= shutdownTime)\n            // If branch is shut down and the Trove was updated after shutdown, no interest is earned since.\n            return 0;\n        }\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != address(borrowerOperations)) {\n            revert CallerNotBorrowerOperations();\n        }\n    }\n\n    function _requireCallerIsCollateralRegistry() internal view {\n        if (msg.sender != address(collateralRegistry)) {\n            revert CallerNotCollateralRegistry();\n        }\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint256 TroveIdsArrayLength) internal pure {\n        if (TroveIdsArrayLength == 1) {\n            revert OnlyOneTroveLeft();\n        }\n    }\n\n    function _requireIsShutDown() internal view {\n        if (shutdownTime == 0) {\n            revert NotShutDown();\n        }\n    }\n\n    function _requireBoldBalanceCoversRedemption(IBoldToken _boldToken, address _redeemer, uint256 _amount)\n        internal\n        view\n    {\n        uint256 boldBalance = _boldToken.balanceOf(_redeemer);\n        if (boldBalance < _amount) {\n            revert NotEnoughBoldBalance();\n        }\n    }\n\n    // --- Trove property getters ---\n\n    function getUnbackedPortionPriceAndRedeemability() external returns (uint256, uint256, bool) {\n        uint256 totalDebt = getEntireSystemDebt();\n        uint256 spSize = stabilityPool.getTotalBoldDeposits();\n        uint256 unbackedPortion = totalDebt > spSize ? totalDebt - spSize : 0;\n\n        (uint256 price,) = priceFeed.fetchPrice();\n        // It's redeemable if the TCR is above the shutdown threshold, and branch has not been shut down\n        bool redeemable = _getTCR(price) >= SCR && shutdownTime == 0;\n\n        return (unbackedPortion, price, redeemable);\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function onOpenTrove(address _owner, uint256 _troveId, TroveChange memory _troveChange, uint256 _annualInterestRate)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        uint256 newStake = _computeNewStake(_troveChange.collIncrease);\n\n        // Trove memory newTrove;\n        Troves[_troveId].debt = _troveChange.debtIncrease + _troveChange.upfrontFee;\n        Troves[_troveId].coll = _troveChange.collIncrease;\n        Troves[_troveId].stake = newStake;\n        Troves[_troveId].status = Status.active;\n        Troves[_troveId].arrayIndex = uint64(TroveIds.length);\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n        Troves[_troveId].annualInterestRate = _annualInterestRate;\n\n        // Push the trove's id to the Trove list\n        TroveIds.push(_troveId);\n\n        uint256 newTotalStakes = totalStakes + newStake;\n        totalStakes = newTotalStakes;\n\n        // mint ERC721\n        troveNFT.mint(_owner, _troveId);\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _troveChange.debtIncrease + _troveChange.upfrontFee,\n            _coll: _troveChange.collIncrease,\n            _stake: newStake,\n            _annualInterestRate: _annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.openTrove,\n            _annualInterestRate: _annualInterestRate,\n            _debtIncreaseFromRedist: 0,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease),\n            _collIncreaseFromRedist: 0,\n            _collChangeFromOperation: int256(_troveChange.collIncrease)\n        });\n    }\n\n    function onOpenTroveAndJoinBatch(\n        address _owner,\n        uint256 _troveId,\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _batchColl,\n        uint256 _batchDebt\n    ) external {\n        _requireCallerIsBorrowerOperations();\n        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);\n\n        uint256 newStake = _computeNewStake(_troveChange.collIncrease);\n\n        // Trove memory newTrove;\n        Troves[_troveId].coll = _troveChange.collIncrease;\n        Troves[_troveId].stake = newStake;\n        Troves[_troveId].status = Status.active;\n        Troves[_troveId].arrayIndex = uint64(TroveIds.length);\n        Troves[_troveId].interestBatchManager = _batchAddress;\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        // Push the trove's id to the Trove list\n        TroveIds.push(_troveId);\n\n        _updateBatchShares(_troveId, _batchAddress, _troveChange, _batchColl, _batchDebt);\n\n        uint256 newTotalStakes = totalStakes + newStake;\n        totalStakes = newTotalStakes;\n\n        // mint ERC721\n        troveNFT.mint(_owner, _troveId);\n\n        emit BatchedTroveUpdated({\n            _troveId: _troveId,\n            _interestBatchManager: _batchAddress,\n            _batchDebtShares: Troves[_troveId].batchDebtShares,\n            _coll: _troveChange.collIncrease,\n            _stake: newStake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.openTroveAndJoinBatch,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: 0,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease),\n            _collIncreaseFromRedist: 0,\n            _collChangeFromOperation: int256(_troveChange.collIncrease)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.joinBatch,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            // Although the Trove joining the batch pays an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function setTroveStatusToActive(uint256 _troveId) external {\n        _requireCallerIsBorrowerOperations();\n        Troves[_troveId].status = Status.active;\n    }\n\n    function onAdjustTroveInterestRate(\n        uint256 _troveId,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        TroveChange calldata _troveChange\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newColl;\n        Troves[_troveId].debt = _newDebt;\n        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: _newAnnualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTroveInterestRate,\n            _annualInterestRate: _newAnnualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n    }\n\n    function onAdjustTrove(uint256 _troveId, uint256 _newColl, uint256 _newDebt, TroveChange calldata _troveChange)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newColl;\n        Troves[_troveId].debt = _newDebt;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newColl);\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _stake: newStake,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTrove,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n    }\n\n    function onCloseTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt // entire, with interest and batch fee\n    ) external override {\n        _requireCallerIsBorrowerOperations();\n        _closeTrove(_troveId, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt, Status.closedByOwner);\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: 0,\n            _coll: 0,\n            _stake: 0,\n            _annualInterestRate: 0,\n            _snapshotOfTotalCollRedist: 0,\n            _snapshotOfTotalDebtRedist: 0\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.closeTrove,\n            _annualInterestRate: 0,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n\n        if (_batchAddress != address(0)) {\n            emit BatchUpdated({\n                _interestBatchManager: _batchAddress,\n                _operation: BatchOperation.exitBatch,\n                _debt: batches[_batchAddress].debt,\n                _coll: batches[_batchAddress].coll,\n                _annualInterestRate: batches[_batchAddress].annualInterestRate,\n                _annualManagementFee: batches[_batchAddress].annualManagementFee,\n                _totalDebtShares: batches[_batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        }\n    }\n\n    function _closeTrove(\n        uint256 _troveId,\n        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        Status closedStatus\n    ) internal {\n        // assert(closedStatus == Status.closedByLiquidation || closedStatus == Status.closedByOwner);\n\n        uint256 TroveIdsArrayLength = TroveIds.length;\n        _requireMoreThanOneTroveInSystem(TroveIdsArrayLength);\n\n        _removeTroveId(_troveId, TroveIdsArrayLength);\n\n        Trove memory trove = Troves[_troveId];\n\n        // If trove belongs to a batch, remove from it\n        if (_batchAddress != address(0)) {\n            if (trove.status == Status.active) {\n                sortedTroves.removeFromBatch(_troveId);\n            }\n\n            _removeTroveSharesFromBatch(\n                _troveId,\n                _troveChange.collDecrease,\n                _troveChange.debtDecrease,\n                _troveChange,\n                _batchAddress,\n                _newBatchColl,\n                _newBatchDebt\n            );\n        } else {\n            if (trove.status == Status.active) {\n                sortedTroves.remove(_troveId);\n            }\n        }\n\n        uint256 newTotalStakes = totalStakes - trove.stake;\n        totalStakes = newTotalStakes;\n\n        // Zero Trove properties\n        delete Troves[_troveId];\n        Troves[_troveId].status = closedStatus;\n\n        // Zero Trove snapshots\n        delete rewardSnapshots[_troveId];\n\n        // burn ERC721\n        troveNFT.burn(_troveId);\n    }\n\n    function onAdjustTroveInsideBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution and trove change\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl, // without trove change\n        uint256 _newBatchDebt // entire (with interest, batch fee), but without trove change nor upfront fee nor redistribution\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        // Trove\n        Troves[_troveId].coll = _newTroveColl;\n        _updateTroveRewardSnapshots(_troveId);\n        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newTroveColl);\n\n        // Batch\n        _updateBatchShares(_troveId, _batchAddress, _troveChange, _newBatchColl, _newBatchDebt);\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit BatchedTroveUpdated({\n            _troveId: _troveId,\n            _interestBatchManager: _batchAddress,\n            _batchDebtShares: Troves[_troveId].batchDebtShares,\n            _coll: _newTroveColl,\n            _stake: newStake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.adjustTrove,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.troveChange,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            // Although the Trove being adjusted may pay an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function onApplyTroveInterest(\n        uint256 _troveId,\n        uint256 _newTroveColl,\n        uint256 _newTroveDebt,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt,\n        TroveChange calldata _troveChange\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        Troves[_troveId].coll = _newTroveColl;\n\n        if (_batchAddress != address(0)) {\n            _updateBatchShares(_troveId, _batchAddress, _troveChange, _newBatchColl, _newBatchDebt);\n\n            emit BatchUpdated({\n                _interestBatchManager: _batchAddress,\n                _operation: BatchOperation.applyBatchInterestAndFee,\n                _debt: _newBatchDebt,\n                _coll: _newBatchColl,\n                _annualInterestRate: batches[_batchAddress].annualInterestRate,\n                _annualManagementFee: batches[_batchAddress].annualManagementFee,\n                _totalDebtShares: batches[_batchAddress].totalDebtShares,\n                _debtIncreaseFromUpfrontFee: 0\n            });\n        } else {\n            Troves[_troveId].debt = _newTroveDebt;\n            Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        }\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        _updateTroveRewardSnapshots(_troveId);\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newTroveDebt,\n            _coll: _newTroveColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.applyPendingDebt,\n            _annualInterestRate: Troves[_troveId].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)\n        });\n    }\n\n    function onRegisterBatchManager(address _account, uint256 _annualInterestRate, uint256 _annualManagementFee)\n        external\n    {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_account].arrayIndex = uint64(batchIds.length);\n        batches[_account].annualInterestRate = _annualInterestRate;\n        batches[_account].annualManagementFee = _annualManagementFee;\n        batches[_account].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        batchIds.push(_account);\n\n        emit BatchUpdated({\n            _interestBatchManager: _account,\n            _operation: BatchOperation.registerBatchManager,\n            _debt: 0,\n            _coll: 0,\n            _annualInterestRate: _annualInterestRate,\n            _annualManagementFee: _annualManagementFee,\n            _totalDebtShares: 0,\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function onLowerBatchManagerAnnualFee(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualManagementFee\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_batchAddress].coll = _newColl;\n        batches[_batchAddress].debt = _newDebt;\n        batches[_batchAddress].annualManagementFee = _newAnnualManagementFee;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.lowerBatchManagerAnnualFee,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: _newAnnualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function onSetBatchManagerAnnualInterestRate(\n        address _batchAddress,\n        uint256 _newColl,\n        uint256 _newDebt,\n        uint256 _newAnnualInterestRate,\n        uint256 _upfrontFee\n    ) external {\n        _requireCallerIsBorrowerOperations();\n\n        batches[_batchAddress].coll = _newColl;\n        batches[_batchAddress].debt = _newDebt;\n        batches[_batchAddress].annualInterestRate = _newAnnualInterestRate;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n        batches[_batchAddress].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.setBatchManagerAnnualInterestRate,\n            _debt: _newDebt,\n            _coll: _newColl,\n            _annualInterestRate: _newAnnualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            _debtIncreaseFromUpfrontFee: _upfrontFee\n        });\n    }\n\n    function onSetInterestBatchManager(OnSetInterestBatchManagerParams calldata _params) external {\n        _requireCallerIsBorrowerOperations();\n        TroveChange memory _troveChange = _params.troveChange;\n\n        // assert(batchIds[batches[_params.newBatchAddress].arrayIndex] == _params.newBatchAddress);\n\n        _updateTroveRewardSnapshots(_params.troveId);\n\n        // Clean Trove state\n        Troves[_params.troveId].debt = 0;\n        Troves[_params.troveId].annualInterestRate = 0;\n        Troves[_params.troveId].lastDebtUpdateTime = 0;\n        Troves[_params.troveId].coll = _params.troveColl;\n\n        Troves[_params.troveId].interestBatchManager = _params.newBatchAddress;\n        Troves[_params.troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _troveChange.collIncrease = _params.troveColl - _troveChange.appliedRedistCollGain;\n        _troveChange.debtIncrease = _params.troveDebt - _troveChange.appliedRedistBoldDebtGain - _troveChange.upfrontFee;\n        _updateBatchShares(\n            _params.troveId, _params.newBatchAddress, _troveChange, _params.newBatchColl, _params.newBatchDebt\n        );\n\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit BatchedTroveUpdated({\n            _troveId: _params.troveId,\n            _interestBatchManager: _params.newBatchAddress,\n            _batchDebtShares: Troves[_params.troveId].batchDebtShares,\n            _coll: _params.troveColl,\n            _stake: Troves[_params.troveId].stake,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _params.troveId,\n            _operation: Operation.setInterestBatchManager,\n            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _params.newBatchAddress,\n            _operation: BatchOperation.joinBatch,\n            _debt: batches[_params.newBatchAddress].debt,\n            _coll: batches[_params.newBatchAddress].coll,\n            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,\n            _annualManagementFee: batches[_params.newBatchAddress].annualManagementFee,\n            _totalDebtShares: batches[_params.newBatchAddress].totalDebtShares,\n            // Although the Trove joining the batch may pay an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function _updateBatchShares(\n        uint256 _troveId,\n        address _batchAddress,\n        TroveChange memory _troveChange,\n        uint256 _batchColl, // without trove change\n        uint256 _batchDebt // entire (with interest, batch fee), but without trove change, nor upfront fee nor redist\n    ) internal {\n        // Debt\n        uint256 currentBatchDebtShares = batches[_batchAddress].totalDebtShares;\n        uint256 batchDebtSharesDelta;\n        uint256 debtIncrease =\n            _troveChange.debtIncrease + _troveChange.upfrontFee + _troveChange.appliedRedistBoldDebtGain;\n        uint256 debtDecrease;\n        if (debtIncrease > _troveChange.debtDecrease) {\n            debtIncrease -= _troveChange.debtDecrease;\n        } else {\n            debtDecrease = _troveChange.debtDecrease - debtIncrease;\n            debtIncrease = 0;\n        }\n\n        if (debtIncrease == 0 && debtDecrease == 0) {\n            batches[_batchAddress].debt = _batchDebt;\n        } else {\n            if (debtIncrease > 0) {\n                // Add debt\n                if (_batchDebt == 0) {\n                    batchDebtSharesDelta = debtIncrease;\n                } else {\n                    batchDebtSharesDelta = currentBatchDebtShares * debtIncrease / _batchDebt;\n                }\n\n                Troves[_troveId].batchDebtShares += batchDebtSharesDelta;\n                batches[_batchAddress].debt = _batchDebt + debtIncrease;\n                batches[_batchAddress].totalDebtShares = currentBatchDebtShares + batchDebtSharesDelta;\n            } else if (debtDecrease > 0) {\n                // Subtract debt\n                batchDebtSharesDelta = currentBatchDebtShares * debtDecrease / _batchDebt;\n\n                Troves[_troveId].batchDebtShares -= batchDebtSharesDelta;\n                batches[_batchAddress].debt = _batchDebt - debtDecrease;\n                batches[_batchAddress].totalDebtShares = currentBatchDebtShares - batchDebtSharesDelta;\n            }\n        }\n        // Update debt checkpoint\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        // Collateral\n        uint256 collIncrease = _troveChange.collIncrease + _troveChange.appliedRedistCollGain;\n        uint256 collDecrease;\n        if (collIncrease > _troveChange.collDecrease) {\n            collIncrease -= _troveChange.collDecrease;\n        } else {\n            collDecrease = _troveChange.collDecrease - collIncrease;\n            collIncrease = 0;\n        }\n\n        if (collIncrease == 0 && collDecrease == 0) {\n            batches[_batchAddress].coll = _batchColl;\n        } else {\n            if (collIncrease > 0) {\n                // Add coll\n                batches[_batchAddress].coll = _batchColl + collIncrease;\n            } else if (collDecrease > 0) {\n                // Subtract coll\n                batches[_batchAddress].coll = _batchColl - collDecrease;\n            }\n        }\n    }\n\n    function onRemoveFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl,\n        uint256 _newBatchDebt, // entire, with interest and batch fee\n        uint256 _newAnnualInterestRate\n    ) external {\n        _requireCallerIsBorrowerOperations();\n        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);\n\n        // Subtract from batch\n        _removeTroveSharesFromBatch(\n            _troveId, _newTroveColl, _newTroveDebt, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt\n        );\n\n        // Restore Trove state\n        Troves[_troveId].debt = _newTroveDebt;\n        Troves[_troveId].coll = _newTroveColl;\n        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);\n        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;\n        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);\n\n        _updateTroveRewardSnapshots(_troveId);\n        _movePendingTroveRewardsToActivePool(\n            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain\n        );\n\n        emit TroveUpdated({\n            _troveId: _troveId,\n            _debt: _newTroveDebt,\n            _coll: _newTroveColl,\n            _stake: Troves[_troveId].stake,\n            _annualInterestRate: _newAnnualInterestRate,\n            _snapshotOfTotalCollRedist: L_coll,\n            _snapshotOfTotalDebtRedist: L_boldDebt\n        });\n\n        emit TroveOperation({\n            _troveId: _troveId,\n            _operation: Operation.removeFromBatch,\n            _annualInterestRate: _newAnnualInterestRate,\n            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,\n            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,\n            _debtChangeFromOperation: 0,\n            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,\n            _collChangeFromOperation: 0\n        });\n\n        emit BatchUpdated({\n            _interestBatchManager: _batchAddress,\n            _operation: BatchOperation.exitBatch,\n            _debt: batches[_batchAddress].debt,\n            _coll: batches[_batchAddress].coll,\n            _annualInterestRate: batches[_batchAddress].annualInterestRate,\n            _annualManagementFee: batches[_batchAddress].annualManagementFee,\n            _totalDebtShares: batches[_batchAddress].totalDebtShares,\n            // Although the Trove leaving the batch may pay an upfront fee,\n            // it is an individual fee, so we don't include it here\n            _debtIncreaseFromUpfrontFee: 0\n        });\n    }\n\n    function _removeTroveSharesFromBatch(\n        uint256 _troveId,\n        uint256 _newTroveColl, // entire, with redistribution\n        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution\n        TroveChange memory _troveChange,\n        address _batchAddress,\n        uint256 _newBatchColl, // without trove change\n        uint256 _newBatchDebt // entire (with interest and batch fee), but without trove change\n    ) internal {\n        // As we are removing:\n        // assert(_newBatchDebt > 0 || _newBatchColl > 0);\n\n        Trove memory trove = Troves[_troveId];\n\n        // We don’t need to increase the shares corresponding to redistribution first, because they would be subtracted immediately after\n        // We don’t need to account for interest nor batch fee because it’s proportional to debt shares\n        uint256 batchDebtDecrease = _newTroveDebt - _troveChange.upfrontFee - _troveChange.appliedRedistBoldDebtGain;\n        uint256 batchCollDecrease = _newTroveColl - _troveChange.appliedRedistCollGain;\n\n        batches[_batchAddress].totalDebtShares -= trove.batchDebtShares;\n        batches[_batchAddress].debt = _newBatchDebt - batchDebtDecrease;\n        batches[_batchAddress].coll = _newBatchColl - batchCollDecrease;\n        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);\n\n        Troves[_troveId].interestBatchManager = address(0);\n        Troves[_troveId].batchDebtShares = 0;\n    }\n}\n"
    },
    "src/liquity/TroveNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/ITroveNFT.sol\";\nimport \"../interfaces/IAddressesRegistry.sol\";\n\nimport {IMetadataNFT} from \"../nft_metadata/MetadataNFT.sol\";\nimport {ITroveManager} from \"../interfaces/ITroveManager.sol\";\n\n// import \"forge-std/console2.sol\";\n\ncontract TroveNFT is ERC721, ITroveNFT {\n    ITroveManager public immutable troveManager;\n    IERC20Metadata internal immutable collToken;\n\n    IMetadataNFT public immutable metadataNFT;\n\n    constructor(IAddressesRegistry _addressesRegistry)\n        ERC721(\n            string.concat(\"Liquity v2 Trove - \", _addressesRegistry.collToken().name()),\n            string.concat(\"Lv2T_\", _addressesRegistry.collToken().symbol())\n        )\n    {\n        troveManager = _addressesRegistry.troveManager();\n        collToken = _addressesRegistry.collToken();\n        metadataNFT = _addressesRegistry.metadataNFT();\n    }\n\n    function tokenURI(uint256 _tokenId) public view override(ERC721, IERC721Metadata) returns (string memory) {\n        (uint256 debt, uint256 coll,, ITroveManager.Status status,,,, uint256 annualInterestRate,,) =\n            troveManager.Troves(_tokenId);\n\n        IMetadataNFT.TroveData memory troveData = IMetadataNFT.TroveData({\n            _tokenId: _tokenId,\n            _owner: ownerOf(_tokenId),\n            _collToken: address(collToken),\n            _collAmount: coll,\n            _debtAmount: debt,\n            _interestRate: annualInterestRate,\n            _status: status\n        });\n\n        return metadataNFT.uri(troveData);\n    }\n\n    function mint(address _owner, uint256 _troveId) external override {\n        _requireCallerIsTroveManager();\n        _mint(_owner, _troveId);\n    }\n\n    function burn(uint256 _troveId) external override {\n        _requireCallerIsTroveManager();\n        _burn(_troveId);\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"TroveNFT: Caller is not the TroveManager contract\");\n    }\n}\n"
    },
    "src/mock/mUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// @title mUSDC\n// @author UniPay\n// @notice This contract is used to mock USDC\ncontract mUSDC is ERC20 {\n    address public owner;\n\n    constructor(address anOwner) ERC20(\"mUSDC\", \"mUSDC\") {\n        owner = anOwner;\n        _mint(owner, 100000000 ether);\n    }\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n}   "
    },
    "src/nft_metadata/MetadataNFT.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"solady/utils/SSTORE2.sol\";\nimport \"./utils/JSON.sol\";\n\nimport \"./utils/baseSVG.sol\";\nimport \"./utils/bauhaus.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ITroveManager} from \"../interfaces/ITroveManager.sol\";\n\ninterface IMetadataNFT {\n    struct TroveData {\n        uint256 _tokenId;\n        address _owner;\n        address _collToken;\n        uint256 _collAmount;\n        uint256 _debtAmount;\n        uint256 _interestRate;\n        ITroveManager.Status _status;\n    }\n\n    function uri(TroveData memory _troveData) external view returns (string memory);\n}\n\ncontract MetadataNFT is IMetadataNFT {\n    FixedAssetReader public immutable assetReader;\n\n    string public constant name = \"Liquity V2 Trove\";\n    string public constant description = \"Liquity V2 Trove position\";\n\n    constructor(FixedAssetReader _assetReader) {\n        assetReader = _assetReader;\n    }\n\n    function uri(TroveData memory _troveData) public view returns (string memory) {\n        return json.formattedMetadata(name, description, renderSVGImage(_troveData));\n    }\n\n    function renderSVGImage(TroveData memory _troveData) internal view returns (string memory) {\n        return svg._svg(\n            baseSVG._svgProps(),\n            string.concat(baseSVG._baseElements(assetReader), bauhaus._bauhaus(), dynamicTextComponents(_troveData))\n        );\n    }\n\n    function dynamicTextComponents(TroveData memory _troveData) public view returns (string memory) {\n        string memory id = LibString.toHexString(_troveData._tokenId);\n        id = string.concat(LibString.slice(id, 0, 6), \"...\", LibString.slice(id, 38, 42));\n\n        return string.concat(\n            baseSVG._formattedIdEl(id),\n            baseSVG._formattedAddressEl(_troveData._owner),\n            baseSVG._collLogo(IERC20Metadata(_troveData._collToken).symbol(), assetReader),\n            baseSVG._statusEl(_status2Str(_troveData._status)),\n            baseSVG._dynamicTextEls(_troveData._debtAmount, _troveData._collAmount, _troveData._interestRate)\n        );\n    }\n\n    function _status2Str(ITroveManager.Status status) internal pure returns (string memory) {\n        if (status == ITroveManager.Status.active) return \"Active\";\n        if (status == ITroveManager.Status.closedByOwner) return \"Closed\";\n        if (status == ITroveManager.Status.closedByLiquidation) return \"Liquidated\";\n        if (status == ITroveManager.Status.unredeemable) return \"Unredeemable\";\n        return \"\";\n    }\n}\n"
    },
    "src/nft_metadata/utils/baseSVG.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity  ^0.8.0;\n\nimport {svg} from \"./SVG.sol\";\nimport {utils, LibString, numUtils} from \"./Utils.sol\";\nimport \"./FixedAssets.sol\";\n\nlibrary baseSVG {\n    string constant GEIST = 'style=\"font-family: Geist\" ';\n\n    function _svgProps() internal pure returns (string memory) {\n        return string.concat(\n            svg.prop(\"width\", \"300\"),\n            svg.prop(\"height\", \"484\"),\n            svg.prop(\"viewBox\", \"0 0 300 484\"),\n            svg.prop(\"style\", \"background:none\")\n        );\n    }\n\n    function _baseElements(FixedAssetReader _assetReader) internal view returns (string memory) {\n        return string.concat(\n            svg.rect(\n                string.concat(\n                    svg.prop(\"fill\", \"#1C1D4F\"),\n                    svg.prop(\"rx\", \"8\"),\n                    svg.prop(\"width\", \"300\"),\n                    svg.prop(\"height\", \"484\")\n                )\n            ),\n            _styles(_assetReader),\n            _leverageLogo(),\n            _boldLogo(_assetReader),\n            _staticTextEls()\n        );\n    }\n\n    function _styles(FixedAssetReader _assetReader) private view returns (string memory) {\n        return svg.el(\n            \"style\",\n            utils.NULL,\n            string.concat(\n                '@font-face { font-family: \"Geist\"; src: url(\"data:font/woff2;utf-8;base64,',\n                _assetReader.readAsset(bytes4(keccak256(\"geist\"))),\n                '\"); }'\n            )\n        );\n    }\n\n    function _leverageLogo() internal pure returns (string memory) {\n        return string.concat(\n            svg.path(\n                \"M22.2 30.2C21.1 31.4 19.6 32 18 32L18 20C19.6 20 21.1 20.6 22.2 21.7C23.4 22.9 24 24.4 24 26C24 27.6 23.4 29.1 22.2 30.2Z\",\n                svg.prop(\"fill\", \"#DEE4FB\")\n            ),\n            svg.path(\n                \"M24 26C24 24.4 24.6 22.9 25.8 21.7C27 20.6 28.4 20 30 20V32C28.4 32 27 31.4 26 30.2C24.6 29.1 24 27.6 24 26Z\",\n                svg.prop(\"fill\", \"#DEE4FB\")\n            )\n        );\n    }\n\n    function _boldLogo(FixedAssetReader _assetReader) internal view returns (string memory) {\n        return svg.el(\n            \"image\",\n            string.concat(\n                svg.prop(\"x\", \"264\"),\n                svg.prop(\"y\", \"374.5\"),\n                svg.prop(\"width\", \"20\"),\n                svg.prop(\"height\", \"20\"),\n                svg.prop(\n                    \"href\",\n                    string.concat(\"data:image/svg+xml;base64,\", _assetReader.readAsset(bytes4(keccak256(\"BOLD\"))))\n                )\n            )\n        );\n    }\n\n    function _staticTextEls() internal pure returns (string memory) {\n        return string.concat(\n            svg.text(\n                string.concat(\n                    GEIST,\n                    svg.prop(\"x\", \"16\"),\n                    svg.prop(\"y\", \"358\"),\n                    svg.prop(\"font-size\", \"14\"),\n                    svg.prop(\"fill\", \"white\")\n                ),\n                \"Collateral\"\n            ),\n            svg.text(\n                string.concat(\n                    GEIST,\n                    svg.prop(\"x\", \"16\"),\n                    svg.prop(\"y\", \"390\"),\n                    svg.prop(\"font-size\", \"14\"),\n                    svg.prop(\"fill\", \"white\")\n                ),\n                \"Debt\"\n            ),\n            svg.text(\n                string.concat(\n                    GEIST,\n                    svg.prop(\"x\", \"16\"),\n                    svg.prop(\"y\", \"418\"),\n                    svg.prop(\"font-size\", \"14\"),\n                    svg.prop(\"fill\", \"white\")\n                ),\n                \"Interest Rate\"\n            ),\n            svg.text(\n                string.concat(\n                    GEIST,\n                    svg.prop(\"x\", \"264\"),\n                    svg.prop(\"y\", \"418\"),\n                    svg.prop(\"font-size\", \"20\"),\n                    svg.prop(\"fill\", \"white\")\n                ),\n                \"%\"\n            ),\n            svg.text(\n                string.concat(\n                    GEIST,\n                    svg.prop(\"x\", \"16\"),\n                    svg.prop(\"y\", \"462\"),\n                    svg.prop(\"font-size\", \"14\"),\n                    svg.prop(\"fill\", \"white\")\n                ),\n                \"Owner\"\n            )\n        );\n    }\n\n    function _formattedDynamicEl(string memory _value, uint256 _x, uint256 _y) internal pure returns (string memory) {\n        return svg.text(\n            string.concat(\n                GEIST,\n                svg.prop(\"text-anchor\", \"end\"),\n                svg.prop(\"x\", LibString.toString(_x)),\n                svg.prop(\"y\", LibString.toString(_y)),\n                svg.prop(\"font-size\", \"20\"),\n                svg.prop(\"fill\", \"white\")\n            ),\n            _value\n        );\n    }\n\n    function _formattedIdEl(string memory _id) internal pure returns (string memory) {\n        return svg.text(\n            string.concat(\n                GEIST,\n                svg.prop(\"text-anchor\", \"end\"),\n                svg.prop(\"x\", \"283\"),\n                svg.prop(\"y\", \"31\"),\n                svg.prop(\"font-size\", \"14\"),\n                svg.prop(\"fill\", \"white\")\n            ),\n            _id\n        );\n    }\n\n    function _formattedAddressEl(address _address) internal pure returns (string memory) {\n        return svg.text(\n            string.concat(\n                GEIST,\n                svg.prop(\"x\", \"196\"),\n                svg.prop(\"y\", \"462\"),\n                svg.prop(\"font-size\", \"14\"),\n                svg.prop(\"fill\", \"white\")\n            ),\n            string.concat(\n                LibString.slice(LibString.toHexStringChecksummed(_address), 0, 6),\n                \"...\",\n                LibString.slice(LibString.toHexStringChecksummed(_address), 38, 42)\n            )\n        );\n    }\n\n    function _collLogo(string memory _collName, FixedAssetReader _assetReader) internal view returns (string memory) {\n        return svg.el(\n            \"image\",\n            string.concat(\n                svg.prop(\"x\", \"264\"),\n                svg.prop(\"y\", \"343.5\"),\n                svg.prop(\"width\", \"20\"),\n                svg.prop(\"height\", \"20\"),\n                svg.prop(\n                    \"href\",\n                    string.concat(\n                        \"data:image/svg+xml;base64,\", _assetReader.readAsset(bytes4(keccak256(bytes(_collName))))\n                    )\n                )\n            )\n        );\n    }\n\n    function _statusEl(string memory _status) internal pure returns (string memory) {\n        return svg.text(\n            string.concat(\n                GEIST, svg.prop(\"x\", \"40\"), svg.prop(\"y\", \"33\"), svg.prop(\"font-size\", \"14\"), svg.prop(\"fill\", \"white\")\n            ),\n            _status\n        );\n    }\n\n    function _dynamicTextEls(uint256, /*_debt*/ uint256 _coll, uint256 _annualInterestRate)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string.concat(\n            _formattedDynamicEl(numUtils.toLocaleString(_coll, 18, 3), 256, 360),\n            _formattedDynamicEl(numUtils.toLocaleString(_coll, 18, 3), 256, 392),\n            _formattedDynamicEl(numUtils.toLocaleString(_annualInterestRate, 16, 2), 256, 420)\n        );\n    }\n}\n"
    },
    "src/nft_metadata/utils/bauhaus.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity  ^0.8.0;\n\nimport \"./SVG.sol\";\n\nlibrary bauhaus {\n    function _bauhaus() internal pure returns (string memory) {\n        return string.concat(_rects(), _circles());\n    }\n\n    function _circles() internal pure returns (string memory) {\n        return string.concat(\n            svg.circle(\n                string.concat(\n                    svg.prop(\"cx\", \"91\"), svg.prop(\"cy\", \"130\"), svg.prop(\"r\", \"75\"), svg.prop(\"fill\", \"#F5D93A\")\n                )\n            ),\n            svg.path(\n                \"M284 264 166 264 166 263C166 232 193 206 225 205C258 206 284 232 284 264C284 264 284 264 284 264Z\",\n                svg.prop(\"fill\", \"#95CBF3\")\n            ),\n            svg.path(\n                \"M284 323 166 323 166 323C166 290 193 265 225 264C258 265 284 290 284 323C284 323 284 323 284 323Z\",\n                svg.prop(\"fill\", \"#F5D93A\")\n            )\n        );\n    }\n\n    function _rects() internal pure returns (string memory) {\n        return string.concat(\n            svg.rect(\n                string.concat(\n                    svg.prop(\"x\", \"16\"),\n                    svg.prop(\"y\", \"205\"),\n                    svg.prop(\"width\", \"75\"),\n                    svg.prop(\"height\", \"118\"),\n                    svg.prop(\"fill\", \"#405AE5\")\n                )\n            ),\n            svg.rect(\n                string.concat(\n                    svg.prop(\"x\", \"91\"),\n                    svg.prop(\"y\", \"205\"),\n                    svg.prop(\"width\", \"136\"),\n                    svg.prop(\"height\", \"59\"),\n                    svg.prop(\"fill\", \"#FB7C59\")\n                )\n            ),\n            svg.rect(\n                string.concat(\n                    svg.prop(\"x\", \"166\"),\n                    svg.prop(\"y\", \"180\"),\n                    svg.prop(\"width\", \"118\"),\n                    svg.prop(\"height\", \"25\"),\n                    svg.prop(\"fill\", \"#405AE5\")\n                )\n            ),\n            svg.rect(\n                string.concat(\n                    svg.prop(\"x\", \"166\"),\n                    svg.prop(\"y\", \"55\"),\n                    svg.prop(\"width\", \"118\"),\n                    svg.prop(\"height\", \"126\"),\n                    svg.prop(\"fill\", \"#63D77D\")\n                )\n            ) /*,\n            //box to check the size of the bauhaus image\n            svg.rect(\n                string.concat(\n                    svg.prop(\"x\", \"16)),\n                    svg.prop(\"y\", \"55)),\n                    svg.prop(\"width\", \"268)),\n                    svg.prop(\"height\", \"268)),\n                    svg.prop(\"fill\", \"none\"),\n                    svg.prop(\"stroke\", \"white\")\n                ),\n                LibString.NULL\n            )*/\n        );\n    }\n}\n"
    },
    "src/nft_metadata/utils/FixedAssets.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity  ^0.8.0;\n\nimport \"solady/utils/SSTORE2.sol\";\n\ncontract FixedAssetReader {\n    struct Asset {\n        uint128 start;\n        uint128 end;\n    }\n\n    address public immutable pointer;\n\n    mapping(bytes4 => Asset) public assets;\n\n    function readAsset(bytes4 _sig) public view returns (string memory) {\n        return string(SSTORE2.read(pointer, uint256(assets[_sig].start), uint256(assets[_sig].end)));\n    }\n\n    constructor(address _pointer, bytes4[] memory _sigs, Asset[] memory _assets) {\n        pointer = _pointer;\n        require(_sigs.length == _assets.length, \"FixedAssetReader: Invalid input\");\n        for (uint256 i = 0; i < _sigs.length; i++) {\n            assets[_sigs[i]] = _assets[i];\n        }\n    }\n}\n"
    },
    "src/nft_metadata/utils/JSON.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// JSON utilities for base64 encoded ERC721 JSON metadata scheme\nlibrary json {\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    /// @dev JSON requires that double quotes be escaped or JSONs will not build correctly\n    /// string.concat also requires an escape, use \\\\\" or the constant DOUBLE_QUOTES to represent \" in JSON\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    string constant DOUBLE_QUOTES = '\\\\\"';\n\n    function formattedMetadata(string memory name, string memory description, string memory svgImg)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string.concat(\n            \"data:application/json;base64,\",\n            encode(\n                bytes(\n                    string.concat(\"{\", _prop(\"name\", name), _prop(\"description\", description), _xmlImage(svgImg), \"}\")\n                )\n            )\n        );\n    }\n\n    function _xmlImage(string memory _svgImg) internal pure returns (string memory) {\n        return _prop(\"image\", string.concat(\"data:image/svg+xml;base64,\", encode(bytes(_svgImg))), true);\n    }\n\n    function _prop(string memory _key, string memory _val) internal pure returns (string memory) {\n        return string.concat('\"', _key, '\": ', '\"', _val, '\", ');\n    }\n\n    function _prop(string memory _key, string memory _val, bool last) internal pure returns (string memory) {\n        if (last) {\n            return string.concat('\"', _key, '\": ', '\"', _val, '\"');\n        } else {\n            return string.concat('\"', _key, '\": ', '\"', _val, '\", ');\n        }\n    }\n\n    function _object(string memory _key, string memory _val) internal pure returns (string memory) {\n        return string.concat('\"', _key, '\": ', \"{\", _val, \"}\");\n    }\n\n    /**\n     * taken from Openzeppelin\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {} {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 { mstore8(sub(resultPtr, 1), 0x3d) }\n        }\n\n        return result;\n    }\n}\n"
    },
    "src/nft_metadata/utils/SVG.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {utils, LibString} from \"./Utils.sol\";\n\n// Core SVG utility library which helps us construct\n// onchain SVG's with a simple, web-like API.\nlibrary svg {\n    /* GLOBAL CONSTANTS */\n    string internal constant _SVG = 'xmlns=\"http://www.w3.org/2000/svg\"';\n    string internal constant _HTML = 'xmlns=\"http://www.w3.org/1999/xhtml\"';\n    string internal constant _XMLNS = \"http://www.w3.org/2000/xmlns/ \";\n    string internal constant _XLINK = \"http://www.w3.org/1999/xlink \";\n\n    /* MAIN ELEMENTS */\n    function g(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"g\", _props, _children);\n    }\n\n    function _svg(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"svg\", string.concat(_SVG, \" \", _props), _children);\n    }\n\n    function style(string memory _title, string memory _props) internal pure returns (string memory) {\n        return el(\"style\", string.concat(\".\", _title, \" \", _props));\n    }\n\n    function path(string memory _d) internal pure returns (string memory) {\n        return el(\"path\", prop(\"d\", _d, true));\n    }\n\n    function path(string memory _d, string memory _props) internal pure returns (string memory) {\n        return el(\"path\", string.concat(prop(\"d\", _d), _props));\n    }\n\n    function path(string memory _d, string memory _props, string memory _children)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\"path\", string.concat(prop(\"d\", _d), _props), _children);\n    }\n\n    function text(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"text\", _props, _children);\n    }\n\n    function line(string memory _props) internal pure returns (string memory) {\n        return el(\"line\", _props);\n    }\n\n    function line(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"line\", _props, _children);\n    }\n\n    function circle(string memory _props) internal pure returns (string memory) {\n        return el(\"circle\", _props);\n    }\n\n    function circle(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"circle\", _props, _children);\n    }\n\n    function circle(string memory cx, string memory cy, string memory r) internal pure returns (string memory) {\n        return el(\"circle\", string.concat(prop(\"cx\", cx), prop(\"cy\", cy), prop(\"r\", r, true)));\n    }\n\n    function circle(string memory cx, string memory cy, string memory r, string memory _children)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\"circle\", string.concat(prop(\"cx\", cx), prop(\"cy\", cy), prop(\"r\", r, true)), _children);\n    }\n\n    function circle(string memory cx, string memory cy, string memory r, string memory _props, string memory _children)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\"circle\", string.concat(prop(\"cx\", cx), prop(\"cy\", cy), prop(\"r\", r), _props), _children);\n    }\n\n    function ellipse(string memory _props) internal pure returns (string memory) {\n        return el(\"ellipse\", _props);\n    }\n\n    function ellipse(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"ellipse\", _props, _children);\n    }\n\n    function polygon(string memory _props) internal pure returns (string memory) {\n        return el(\"polygon\", _props);\n    }\n\n    function polygon(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"polygon\", _props, _children);\n    }\n\n    function polyline(string memory _props) internal pure returns (string memory) {\n        return el(\"polyline\", _props);\n    }\n\n    function polyline(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"polyline\", _props, _children);\n    }\n\n    function rect(string memory _props) internal pure returns (string memory) {\n        return el(\"rect\", _props);\n    }\n\n    function rect(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"rect\", _props, _children);\n    }\n\n    function filter(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"filter\", _props, _children);\n    }\n\n    function cdata(string memory _content) internal pure returns (string memory) {\n        return string.concat(\"<![CDATA[\", _content, \"]]>\");\n    }\n\n    /* GRADIENTS */\n    function radialGradient(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"radialGradient\", _props, _children);\n    }\n\n    function linearGradient(string memory _props, string memory _children) internal pure returns (string memory) {\n        return el(\"linearGradient\", _props, _children);\n    }\n\n    function gradientStop(uint256 offset, string memory stopColor, string memory _props)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\n            \"stop\",\n            string.concat(\n                prop(\"stop-color\", stopColor),\n                \" \",\n                prop(\"offset\", string.concat(LibString.toString(offset), \"%\")),\n                \" \",\n                _props\n            ),\n            utils.NULL\n        );\n    }\n\n    /* ANIMATION */\n    function animateTransform(string memory _props) internal pure returns (string memory) {\n        return el(\"animateTransform\", _props);\n    }\n\n    function animate(string memory _props) internal pure returns (string memory) {\n        return el(\"animate\", _props);\n    }\n\n    /* COMMON */\n    // A generic element, can be used to construct any SVG (or HTML) element\n    function el(string memory _tag, string memory _props, string memory _children)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string.concat(\"<\", _tag, \" \", _props, \">\", _children, \"</\", _tag, \">\");\n    }\n\n    // A generic element, can be used to construct SVG (or HTML) elements without children\n    function el(string memory _tag, string memory _props) internal pure returns (string memory) {\n        return string.concat(\"<\", _tag, \" \", _props, \"/>\");\n    }\n\n    // an SVG attribute\n    function prop(string memory _key, string memory _val) internal pure returns (string memory) {\n        return string.concat(_key, \"=\", '\"', _val, '\" ');\n    }\n\n    function prop(string memory _key, string memory _val, bool last) internal pure returns (string memory) {\n        if (last) {\n            return string.concat(_key, \"=\", '\"', _val, '\"');\n        } else {\n            return string.concat(_key, \"=\", '\"', _val, '\" ');\n        }\n    }\n}\n"
    },
    "src/nft_metadata/utils/Utils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity  ^0.8.0;\n\nimport \"solady/utils/LibString.sol\";\n\nlibrary numUtils {\n    function toLocale(string memory _wholeNumber) internal pure returns (string memory) {\n        bytes memory b = bytes(_wholeNumber);\n        uint256 len = b.length;\n        if (len < 4) return _wholeNumber;\n\n        uint256 numCommas = (len - 1) / 3;\n\n        bytes memory result = new bytes(len + numCommas);\n\n        uint256 j = result.length - 1;\n        uint256 k = len;\n        for (uint256 i = 0; i < len; i++) {\n            result[j] = b[k - 1];\n            j = j > 1 ? j - 1 : 0;\n            k--;\n            if (k > 0 && (len - k) % 3 == 0) {\n                result[j] = \",\";\n                j = j > 1 ? j - 1 : 0;\n            }\n        }\n\n        return string(result);\n    }\n\n    // TODO handle underflow\n    function toLocaleString(uint256 _value, uint8 _divisor, uint8 _precision) internal pure returns (string memory) {\n        uint256 whole = _value / 10 ** _divisor;\n        uint256 fraction = (_value % 10 ** _divisor) / 10 ** (_divisor - _precision);\n\n        string memory wholeStr = toLocale(LibString.toString(whole));\n\n        if (fraction == 0) {\n            return wholeStr;\n        }\n\n        string memory fractionStr = LibString.slice(LibString.toString(fraction), 0, _precision);\n\n        return string.concat(wholeStr, \".\", fractionStr);\n    }\n}\n\n// Core utils used extensively to format CSS and numbers.\nlibrary utils {\n    // used to simulate empty strings\n    string internal constant NULL = \"\";\n\n    // formats a CSS variable line. includes a semicolon for formatting.\n    function setCssVar(string memory _key, string memory _val) internal pure returns (string memory) {\n        return string.concat(\"--\", _key, \":\", _val, \";\");\n    }\n\n    // formats getting a css variable\n    function getCssVar(string memory _key) internal pure returns (string memory) {\n        return string.concat(\"var(--\", _key, \")\");\n    }\n\n    // formats getting a def URL\n    function getDefURL(string memory _id) internal pure returns (string memory) {\n        return string.concat(\"url(#\", _id, \")\");\n    }\n\n    // formats rgba white with a specified opacity / alpha\n    function white_a(uint256 _a) internal pure returns (string memory) {\n        return rgba(255, 255, 255, _a);\n    }\n\n    // formats rgba black with a specified opacity / alpha\n    function black_a(uint256 _a) internal pure returns (string memory) {\n        return rgba(0, 0, 0, _a);\n    }\n\n    // formats generic rgba color in css\n    function rgba(uint256 _r, uint256 _g, uint256 _b, uint256 _a) internal pure returns (string memory) {\n        string memory formattedA = _a < 100 ? string.concat(\"0.\", LibString.toString(_a)) : \"1\";\n        return string.concat(\n            \"rgba(\",\n            LibString.toString(_r),\n            \",\",\n            LibString.toString(_g),\n            \",\",\n            LibString.toString(_b),\n            \",\",\n            formattedA,\n            \")\"\n        );\n    }\n\n    function cssBraces(string memory _attribute, string memory _value) internal pure returns (string memory) {\n        return string.concat(\" {\", _attribute, \": \", _value, \"}\");\n    }\n\n    function cssBraces(string[] memory _attributes, string[] memory _values) internal pure returns (string memory) {\n        require(_attributes.length == _values.length, \"Utils: Unbalanced Arrays\");\n\n        uint256 len = _attributes.length;\n\n        string memory results = \" {\";\n\n        for (uint256 i = 0; i < len; i++) {\n            results = string.concat(results, _attributes[i], \": \", _values[i], \"; \");\n        }\n\n        return string.concat(results, \"}\");\n    }\n\n    //deals with integers (i.e. no decimals)\n    function points(uint256[2][] memory pointsArray) internal pure returns (string memory) {\n        require(pointsArray.length >= 3, \"Utils: Array too short\");\n\n        uint256 len = pointsArray.length - 1;\n\n        string memory results = 'points=\"';\n\n        for (uint256 i = 0; i < len; i++) {\n            results = string.concat(\n                results, LibString.toString(pointsArray[i][0]), \",\", LibString.toString(pointsArray[i][1]), \" \"\n            );\n        }\n\n        return string.concat(\n            results, LibString.toString(pointsArray[len][0]), \",\", LibString.toString(pointsArray[len][1]), '\"'\n        );\n    }\n\n    // allows for a uniform precision to be applied to all points\n    function points(uint256[2][] memory pointsArray, uint256 decimalPrecision) internal pure returns (string memory) {\n        require(pointsArray.length >= 3, \"Utils: Array too short\");\n\n        uint256 len = pointsArray.length - 1;\n\n        string memory results = 'points=\"';\n\n        for (uint256 i = 0; i < len; i++) {\n            results = string.concat(\n                results,\n                toString(pointsArray[i][0], decimalPrecision),\n                \",\",\n                toString(pointsArray[i][1], decimalPrecision),\n                \" \"\n            );\n        }\n\n        return string.concat(\n            results,\n            toString(pointsArray[len][0], decimalPrecision),\n            \",\",\n            toString(pointsArray[len][1], decimalPrecision),\n            '\"'\n        );\n    }\n\n    // checks if two strings are equal\n    function stringsEqual(string memory _a, string memory _b) internal pure returns (bool) {\n        return keccak256(abi.encodePacked(_a)) == keccak256(abi.encodePacked(_b));\n    }\n\n    // returns the length of a string in characters\n    function utfStringLength(string memory _str) internal pure returns (uint256 length) {\n        uint256 i = 0;\n        bytes memory string_rep = bytes(_str);\n\n        while (i < string_rep.length) {\n            if (string_rep[i] >> 7 == 0) {\n                i += 1;\n            } else if (string_rep[i] >> 5 == bytes1(uint8(0x6))) {\n                i += 2;\n            } else if (string_rep[i] >> 4 == bytes1(uint8(0xE))) {\n                i += 3;\n            } else if (string_rep[i] >> 3 == bytes1(uint8(0x1E))) {\n                i += 4;\n            }\n            //For safety\n            else {\n                i += 1;\n            }\n\n            length++;\n        }\n    }\n\n    // allows the insertion of a decimal point in the returned string at precision\n    function toString(uint256 value, uint256 precision) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        require(precision <= digits && precision > 0, \"Utils: precision invalid\");\n        precision == digits ? digits += 2 : digits++; //adds a space for the decimal point, 2 if it is the whole uint\n\n        uint256 decimalPlacement = digits - precision - 1;\n        bytes memory buffer = new bytes(digits);\n\n        buffer[decimalPlacement] = 0x2E; // add the decimal point, ASCII 46/hex 2E\n        if (decimalPlacement == 1) {\n            buffer[0] = 0x30;\n        }\n\n        while (value != 0) {\n            digits -= 1;\n            if (digits != decimalPlacement) {\n                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n                value /= 10;\n            }\n        }\n\n        return string(buffer);\n    }\n}\n"
    },
    "src/types/BatchId.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype BatchId is address;\n\nusing {\n    // TODO: use as operators if we ever upgrade to ^0.8.19\n    equals, // as ==\n    notEquals, // as !=\n    isZero,\n    isNotZero\n} for BatchId global;\n\nfunction equals(BatchId a, BatchId b) pure returns (bool) {\n    return BatchId.unwrap(a) == BatchId.unwrap(b);\n}\n\nfunction notEquals(BatchId a, BatchId b) pure returns (bool) {\n    return !a.equals(b);\n}\n\nfunction isZero(BatchId x) pure returns (bool) {\n    return x.equals(BATCH_ID_ZERO);\n}\n\nfunction isNotZero(BatchId x) pure returns (bool) {\n    return !x.isZero();\n}\n\nBatchId constant BATCH_ID_ZERO = BatchId.wrap(address(0));\n"
    },
    "src/types/LatestBatchData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nstruct LatestBatchData {\n    uint256 entireDebtWithoutRedistribution;\n    uint256 entireCollWithoutRedistribution;\n    uint256 accruedInterest;\n    uint256 recordedDebt;\n    uint256 annualInterestRate;\n    uint256 weightedRecordedDebt;\n    uint256 annualManagementFee;\n    uint256 accruedManagementFee;\n    uint256 weightedRecordedBatchManagementFee;\n    uint256 lastDebtUpdateTime;\n    uint256 lastInterestRateAdjTime;\n}\n"
    },
    "src/types/LatestTroveData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nstruct LatestTroveData {\n    uint256 entireDebt;\n    uint256 entireColl;\n    uint256 redistBoldDebtGain;\n    uint256 redistCollGain;\n    uint256 accruedInterest;\n    uint256 recordedDebt;\n    uint256 annualInterestRate;\n    uint256 weightedRecordedDebt;\n    uint256 accruedBatchManagementFee;\n    uint256 lastInterestRateAdjTime;\n}\n"
    },
    "src/types/TroveChange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nstruct TroveChange {\n    uint256 appliedRedistBoldDebtGain;\n    uint256 appliedRedistCollGain;\n    uint256 collIncrease;\n    uint256 collDecrease;\n    uint256 debtIncrease;\n    uint256 debtDecrease;\n    uint256 newWeightedRecordedDebt;\n    uint256 oldWeightedRecordedDebt;\n    uint256 upfrontFee;\n    uint256 batchAccruedManagementFee;\n    uint256 newWeightedRecordedBatchManagementFee;\n    uint256 oldWeightedRecordedBatchManagementFee;\n}\n"
    },
    "src/types/TroveId.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ROOT_NODE_ID} from \"../liquity/SortedTroves.sol\";\n\ntype TroveId is uint256;\n\nusing {\n    // TODO: use as operators if we ever upgrade to ^0.8.19\n    equals, // as ==\n    notEquals, // as !=\n    isEndOfList,\n    isNotEndOfList\n} for TroveId global;\n\nfunction equals(TroveId a, TroveId b) pure returns (bool) {\n    return TroveId.unwrap(a) == TroveId.unwrap(b);\n}\n\nfunction notEquals(TroveId a, TroveId b) pure returns (bool) {\n    return !a.equals(b);\n}\n\nfunction isEndOfList(TroveId x) pure returns (bool) {\n    return x.equals(TROVE_ID_END_OF_LIST);\n}\n\nfunction isNotEndOfList(TroveId x) pure returns (bool) {\n    return !x.isEndOfList();\n}\n\nTroveId constant TROVE_ID_ZERO = TroveId.wrap(0);\nTroveId constant TROVE_ID_END_OF_LIST = TroveId.wrap(ROOT_NODE_ID);\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}